---
title: C++_高级特性
date: 2019-09-07 19:16:38
tags:
categories:
---

C++中的高级特性

<!--more-->

# 类的继承   

继承可以理解为父子，子类继承父类的的基因，父类又称作基类，子类又称作派生类  

派生类的写法：class A : B ;  

## 内存中的派生类  

在内存中派生类实际上是基类的内容加上自己的内容。  

## protected  

派生类可以访问到基类的保护成员，但不可以访问私有成员  

## 基类访问控制  

在定义派生类的基类列表时，可以指定对基类访问控制的类型，即继承方式。

1. 公有继承时：原基类的非私有成员访问属性在派生类中不变

2. 私有继承时：原基类的非私有成员访问属性在派生类中变为私有成员  

3. 保护继承时：原基类的非私有成员访问属性在派生类中变为保护成员

## 构造与析构  

派生类不会继承基类的构造函数和析构函数  

## 基类的初始化  

派生类可以在构造函数中使用初始值列表对基类进行初始化  

## 默认构造函数  

隐式的默认构造函数创建有两个条件  

1. 用户没有为该类创建任何构造函数  

2. 如果为派生类，其基类必须要有默认构造函数，否则不知道如何初始化基类  

## 派生类的析构  

析构的顺序为：基类的构造在派生类之前，析构在派生类之后。

## 名字隐藏  

实质上就是跟探讨作用域的问题一样  

派生类就如同局部，基类为全局;如果一个派生类和基类有一个数据成员一样，那么编译器会先找到派生类的数据成员，并且使用他。如若在派生类找不到才会向基类再去寻找。  

# 类的多态性  

继承与虚函数构成了多态性。

## 向上转换  

派生类可以转换为基类，但是基类不可以转换成派生类 

## 向下转换  

有时候，我们知道当前指针指向的对象为什么类型，可以使用强制转换完成向下转换  

向下转换必须显式的向编译器提出，向下转换具有一定的风险，如果给定的并非是一个派生类的对象，那么，将他进行强制转换，是不可预料的。  

## 虚函数  

关键字virtual用以声明基类的某个函数为虚函数  

我们通常把基类虚函数的实现称作“覆盖”。  

## 虚析构函数  

如果基类的虚析构函数不是虚函数，针对基类的析构操作将无法引起派生类的析构。  

保险起见，一般建议将基类的析构函数声明为虚的

## 纯虚函数  

纯虚函数是一种特殊的虚函数，它没有函数的实现。  

virtual void say() = 0;  

注意区分函数体为空的情形，不可再为虚函数定义函数体  

## 抽象类  

具有纯虚函数的类即为抽象类。抽象类不能被实例化  

抽象类一般用来设计一套统一的接口，派生类必须实现其中的虚函数，才能被实例化。  

## 多级继承  

派生类的继承可以是任何一个合法的类，也可以继承于某一个派生类。  

## 虚函数的多次填充  

虚函数的特性是自动遗传的，也就是说，在基类定义了某个虚函数，不管派生类覆盖不覆盖这个函数，其属性仍然是虚的，那么，虚函数可以随着多级继承而被多次填充  

## 多继承   

派生类可以继承多个基类  

## 多继承带来的问题  

二义性和内存冗余即可能会在派生类的对象同时保存基类的多份复制  

## 虚拟继承  

可以实现多个派生类之间共同享受某个相同的基类  

在要继承的基类名之前加virtual  

在UML使用虚线表示虚拟继承  

# 模板  

函数模板即带有参数的函数

模板的参数与函数的参数相似与不同  

1. 函数的参数列表由()引起,模板的参数列表由<>括起

2. 函数的参数为对象，模板的参数大部分为类型，例如：typename T。T的类型必须是typename或者class。  

3. 函数的参数是0～N个，而模板的参数是1～N个  

4. 函数模板也可以被重载  

5. 使用模板时，可以不指定模板的参数。编译器根据实际调用正确猜测出模板参数的值  

6. 模板的参数不能具有默认值，但是类模板中模板参数可以有默认值  

## 函数模板的实例化  

函数模板必须被实例化才能被正常调用 

注意函数的实例化可以隐式完成  

## 函数模板的重载   

函数模板可以重载  

普通的函数与模板函数同名同参数时，C++会优先选择普通函数  

## 函数模板的特化  

可以针对某个类型进行特化（？特殊化）。特化的函数以“template<>”开头  

## 类模板  

类模板的成员函数定义之前必须包含一段模板参数的声明  

类模板可以声明多个参数  

可以具有默认参数类型  

# 异常处理  

## 抛出异常  

使用异常机制，就是在错误的地方，抛出一个异常变量。  

throw关键字用以抛出一个异常，这个异常可以是任何类型的对象。  

## 捕获异常  

可以使用try...catch捕获抛出的异常。try中文含义为尝试，catch为捕获，意思就是先尝试执行一段代码，如果捕获到异常，则执行catch的代码。

## 捕获不同类型的异常  

异常可以由程序员自定义异常类。  

## 捕获所有异常  

可以使用带有省略号的catch语句块，它用以捕获所有未经捕获的异常。  

## 在catch块抛出异常  

我们可以在catch语句块中再次抛出异常  

## 未经捕获的异常  

异常不一定都被捕获  

如果一个异常没有被捕获，C++不知道怎么处理这个异常的情况下。它将会调用temiante()函数，默认情况下，该函数只会简单的调用abort()函数，用以中断程序的执行。  

## 定制terminate()的行为  

可以认为terminate()函数使用一个全局的函数指针进行调用  

因此，可以使用set_terminate()函数来指定一个新的处理函数。  

## 对抛出异常的声明  

当声明函数的时候，可以同时指明该函数可能会抛出的异常  

对抛出异常作出声明不是强制性的

1. 如果一个函数可能抛出异常，不一定要使用throw抛出异常，反之一样  

2. 声明的异常不必与实际抛出的类型相符  

3. 在catch语句中，其捕获的异常不必与函数声明的异常中的类型相符  

对抛出的异常作出声明，只是为了指导意义，为了让使用者知道调用此函数可能会带来的风险。  

# 名字空间与域  

用以解决名字冲突问题  

## 名字空间定义  

可以定义一个名字空间，将自己的类、和对象括起来。  

## using声明  

using声明告诉编译器尝试从名字空间查找对象  

## using指令   

可以直接声明待使用的名字空间的成员名

## 名字空间的别名  

可以使用namespace为已定义的名字空间指定别名  

## 作用域  

C++支持三种作用域  

## 局部作用域  

1. 每段语句块都包含一个局部的作用域，在语句块声明的对象只在本语句块内部其作用  

2. 局部变量的存储类型  

局部变量可以具有不同的存储类型  

- 自动存储类型：当程序执行超出当前作用域，变量自动销毁  

- 寄存器存储类型：将变量存储在寄存器中进行存取，可以提高函数的执行程度，但是编译器有可能会选择其他方式处理  

- 静态存储类型：超出局部作用域，静态局部变量不会被销毁  

## 名字空间域  

1. 由名字空间所指定的作用域  

2. 外部存储类型：extern，可以在a源文件声明b源文件的对象  

3. 最外成的空间即全局域  

## 类域 

类域包括定义体和所有的成员函数体  

类可以具有static数据成员  

作用域、语句块、名字空间、类都可以嵌套  

语句块中定义的类为内部类  

## 对象的生命周期  

生命周期与作用域有某种关系，如：一段语句块中定义的自动对象在离开当前局部作用域的时候，总会被销毁。  

# C++标准库  

## 字符串库<string>

1. 字符串的构造和赋值  

由多个重复的字符构成的string：string s(8,'f')  

2. 字符串连接  

可以使用+号将两个字符串连接起来  

3. 字符串可以用运算符直接比较  

4. 字符串的下标  

可以通过字符串的下标来访问字符串中的某个字符  

通过length()获取字符串的长度  

5. 子串：字符串中的一部分  

6. 字符串的查找  

可以从字符串中查找某个字串，并返回字串所在的位置，使用是string类的find()方法，查找失败返回-1  

7. string与C-style字符串：可以通过c_str()函数获取string的字符数组，c_str返回的是一个const的字符指针，指向string内部的实际存储地址，值会随着string的改变。  

8. 空字符串：不包含任何内容，使用clear()清空字符串，empty()判断字符串是否为空  

## 复数类<complex>  

1. 复数的构造  

complex是一个类模板，它可以采用float、double、long double 3种类型进行定制，如：complex<double> c(1,2)  

2. 复数可以进行四则运算  

3. 复数的操作函数  

real()返回复数的实部  

imag()返回复数的虚部  

abs(x)返回复数x的模  

arg(x)返回复数x的相角  

conj(x)返回复数x的共軛复数  

narm(x)返回复数x的模的平方  

## 异常类<stdexcept>

包含了C++中各种各样的异常  

# C标准库  

## assert宏  

在<cassert>中定义一个很有用的宏：assert()用以调试代码  

如果想取消掉assert()的功能，可以在包含<cassert>头文件之前定义NDEBUG宏：  

## 类型函数  

<cctype>定义了一堆字符处理函数和宏

- isdigit(c):判断c是否为数字

- isupper(c):判断c是否为大写字母

- islower(c):判断c是否为小写字母  

- isalpha(c):判断c是否为字母

- isalnum(c):判断c是否为字母或者数字  

- isprint(c):判断c是否是可显示的ASCII字符  

- isspace(c):判断c是否为空字符

- touper(c):将c转换成大写字符 

- tolower(c):将c转换成小写字符 

## 类型转换函数  

- double atof(char*a):将字符串a转换成浮点数并返回  

- int atoi(char*a):将字符串a转换成整数并返回  

- long atol(char*a):将字符串a转换成长整型并返回  

- char *itoa(int value,char *string,int radix):将整数value转换成字符串存入string  

## 随机数函数  

随机数函数定义在<stdlib>  

rang()返回0～RAND_MAX中随机的一个整数  

rang()的产生依赖于一个发生器序列，一般需要调用srand()函数初始化，初始值一般被称作随机种子  

## 可变参数处理  

<cstdarg>提供了几个宏和类型，以支持可变参数  

- va_list：记录参数类型  

- va_start(list,p0):建议扫描参数表的起始指针，并保存参数信息至va_list的变量list  

- va_arg(list,type):提取参数表list中的参数，并转换成type类型  

- va_end(list):结束可变参数处理  

## 内存操作函数  

<cstring>和<cstdlib>中定义了如下内存操作函数  

- void *memchr(buffer,c,count):在内存中查找指定字符  

- int memcmp(buf1,buf2,count):比较两块内存中的字符  

- void *memcpy(dest,src,count):拷贝源内存块至目的的内存块  

- void *memmove(dest,src,count):移动源内存块至目的内存块  

- void *memset(dest,c,count):使用指定数值设置内存块的内容  

- void *malloc(size):分配一块内存  

- void *calloc(size,n):分配size\*n字节的内存，并清零  

- void *free(buffer):释放分配的内存  

## 系统控制函数  

<cstdlib>  

- void abort():异常终止程序  

- int exit(int status):终止当前程序  

- int system(chat *command):执行Shell命令  

# C++流  

## 格式化输出流  

iostream提供了格式化输出函数，用以制定输出的格式  

- width(n):将输出宽度设置为n个字符，默认情况下，输出宽度等于字符串实际长度  

- idth():获取当前的宽度设置  

- fill(ch):设置填充字符为ch，默认情况为空格  

- fill():获取当前的填充字符  

- precision(p):设置浮点数精度为p

- precision():获取浮点数精度  

- setf(m):打开格式化标志m  

- unsetf(m):关闭格式化标志m  

- setf(m1,m2):打开m1,关闭m2  

格式化标志可以上网搜索

## 格式操纵符  

可以直接使用<<输出  

格式操纵符见互联网  

## 文件流  

使用ofstream对象写入文件  

open打开文件 -> <<或者write函数写入文件 -> close关闭文件  

使用ifstream对象读取文件  

open打开文件 -> >>或者read函数读取文件 -> close关闭文件  

打开文件的模式包括  

ios::app:追加模式  

ios::ate:打开文件定位到文件尾  

ios::binary:二进制方式打开  

ios::in:输入方式打开  

ios::out:输出方式打开  

可以配合|使用  

- 文件的定位  

ifstream& seekg(streampos pos);
