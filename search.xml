<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux基本知识]]></title>
    <url>%2F2019%2F06%2F05%2FLinux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录初学Linux所学习的知识 特点 命令区分大小写 使用Tab来补全命令,按两下显示可补全的命令 上下键可以查看历史命令 Ctrl + L可以清屏 使用分号隔开语句可以实现多条命令 \可以断开长命令，增强可读性 命令后加一个&amp;可使命令后台运行 Linux文件系统目录结构 目录 说明 / 根目录 /bin 存放必要的命令的目录 /dev 任何硬件与接口设备以文件的形式放在这个目录下 /etc 存放系统配置文件的目录 /home 系统默认的普通用户家目录 /lib 存放必要运行库的目录 /mnt 各项设备的文件系统挂载点 /proc 存放存储进程和系统信息的目录 /root 系统管理员的家目录 /sbin 存放系统管理员的目录 /tmp 临时文件的存放位置，可供所有用户执行写入操作的特有权限 /usr UNIX software resource的缩写，是操作系统软件资源所默认放置的目录 绝对命令与相对命令绝对命令是从/开始的，也就是根目录;而相对路径是从当前目录开始 Linux基本命令大部分的命令可以参考我的另一篇文章，下面补充一些其他的命令： 1.]]></content>
      <categories>
        <category>Linuxu</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ note3]]></title>
    <url>%2F2019%2F06%2F04%2FC%2B%2B%20note3%2F</url>
    <content type="text"><![CDATA[关于面向对象编程的笔记 面向对象 new 动态内存分配1234567891011int* i = new int; //类型*变量 = new 类型int* ip = new int[5];//分配数组int* (*ip)[5] = new int[5][4] //分配多维数组delete [] ip; //数组的销毁方式/**思考题 *1、new如何动态分配多维数组？ int (*ipp)[4] = new int[5][4]; *2、分配出来的多维数组如何销毁？ delete[] ipp; **/delete i; //销毁地址 常见错误 忘记销毁new出来的地址，会造成内存泄露 多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过； 1234if(ip)&#123; delete ip; ip = 0;&#125; 销毁一段非new分配的内存 使用被delete的内存 务必要记住，new和delete必须要成对使用 new的对象不要盲目使用自增运算符 取值运算需要加上取值操作符* 默认参数 C++函数中可以带有默认参数 12345678double Add(int num1,int num2 = 0)&#123; return num1 + num2;&#125;· 所有参数都可以具有默认参数· 默认参数必须从最右边开始· 不可以使用形参作为默认参数· 一般来说，默认参数一般使用在函数参数很多的情况下，它避免了函数调用者必须记住太多太长的参数 可变参数 C++提供一种“可变参数”的机制，即允许参数的数目是可变的。 1234567891011121314151617181920212223242526272829/* 要定义一个支持可变参数的函数，需要用到头文件&lt;cstdarg&gt;中的一些东西 */#include &lt;iostream&gt;#include &lt;cstdarg&gt;using namespace std;int Add(int first...);int main() &#123; int sum = Add(11, 22, 33, -1);&#125;int Add(int first...) &#123; //准备读取可变参数 va_list nums; va_start(nums, first); //使用&lt;cstdarg&gt;中的va_xxx宏函数处理可变参数 int sum = 0; int num = first; //依次读取参数，-1表示结束 while (num != -1) &#123; cout &lt;&lt; &quot;+&quot; &lt;&lt; num &lt;&lt; endl; sum += num; num = va_arg(nums, int); &#125; va_end(nums); return sum;&#125;------------以上主要思想是使用va_xxx读取参数列表，并进行加和。遇到-1结束，可变参数处理起来比较麻烦。 内联函数 在进行函数调用前，会将调用函数的地址和参数列表等信息保留在堆栈中，以便在函数执行结束后，可以返回到原先调用的程序继续执行。因此对于某些频繁调用的小型函数来说，这些堆栈存取动作，会降低的程序的执行效率，此时即可使用内敛函数解决问题。内联函数允许函数内部的内容正在调用点直接展开，这样就避免了传统调用函数过程带来的性能损失。123456789101112131415inline int add(int,int);void add(int a,int b)&#123; cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl; cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;&#125;int main()&#123; add(1,2); /*编译器会改写成*/ cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl; cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl; ---------- 实际上，inline只是对编译器进行优化的一个建议， 编译器完全可能会不理会该建议，所以，不要滥用inl ine函数&#125; 函数重载 函数名相同，参数列表不同，就是函数的重载特性12345678910111213141516函数重载经常出现的错误示例：int add(int a)&#123; return a；&#125;float add(int a)&#123; return a&#125;//不能依赖于返回值的类型不同选定一个函数//实参与形参类型不同//不要认为的制造二义性冲突，例如int add(int a)&#123; return a;&#125;int add(int a,int b = 10)&#123; return a + b; &#125; 安全连接和名字重组自行百度了解 递归函数 函数自己调用自己，即递归函数12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;void test(int);int main() &#123; test(10);&#125;void test(int num1) &#123; cout &lt;&lt; &quot;函数开始&quot; &lt;&lt; endl; if (num1 == 0) return; test(num1 / 2); cout &lt;&lt; &quot;函数结束&quot; &lt;&lt; endl;&#125;输出结果如下:函数开始函数开始函数开始函数开始函数开始函数结束函数结束--gg函数结束函数结束--------------个人是这样理解的,递归就是一个函数嵌套的过程，像上面的程序有五个函数开始，这是在执行递归之前的语句，也就是说算上第一次进入函数，这个函数执行了五次，但对应的函数结束却只出现了四次，那是因为最后一次执行了 return语句，直接跳出了函数，也就没有后面的语句的执行。结合理解使用调试功能进行观察效果会更好。 函数指针 在C++中提供函数指针，它用以指向一个函数 123456void (*fp)(); //声明一个类型为void，没有参数的函数指针fp = &amp;add; //指向add函数的地址fp = add //等同与指向//调用的方法fp(); //相当于add()(*fp)(); //相当于add()，一般用这种来区别这是一个函数指针的调用 理解函数指针 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int add(int a ,int b) &#123; return a + b;&#125;int min(int a, int b);int main() &#123; void (*fp1)(int); int (*fp2)(int, int); cout &lt;&lt; typeid(fp1).name() &lt;&lt; endl; cout &lt;&lt; typeid(fp2).name() &lt;&lt; endl; cout &lt;&lt; typeid(add).name() &lt;&lt; endl; cout &lt;&lt; typeid(min).name() &lt;&lt; endl;&#125;int min(int a, int b) &#123; return a - b;&#125;------------利用typeid输出函数指针类型来理解它根据这样的特性，我们可以定义函数指针数字组int (*fp[])(int ,int ) = &#123;&amp;add,&amp;min&#125;函数指针的定义有点繁琐，建议用typedef来改善可读性。typedef int (*fp)(int,int);fp fp1 = add;fp fp2 = &amp;min;fp fp3[] = &#123;&amp;add,&amp;min&#125;; 函数与值传递 1234·值传递有三种方式：传值方式，引用方式，传址方式·向函数传递参数的时候，除了引用方式外，其他方式都是在函数内部将参数内容复制一份使用。 类的设计 类是对象的类型，对象是类的实例 类的设计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071· 类的语法定义：class 类名&#123;访问控制符: 成员列表&#125;;· 类也可以先声明后定义，声明方式如下class 类名;· 对象的定义类名 对象名;类名 * 对象名 = new 类名();//类的两种实例化方法还可以定义类对象的指针和引用类名 * 指针名 = &amp;对象名;类名 &amp; 引用名 = 对象名;· 数据成员的访问可以使用&quot;.&quot;来访问数据成员对象指针用&quot;-&gt;&quot;来访问还支持用&quot;::&quot;域名操作符访问成员，但常用以上两种· 成员访问控制访问控制符一般包括两种public:共有的，可以在任意地方访问成员private:私有的，只能在类的内部访问成员有一种不成文的规矩，就是把私有的数据成员加上下划线· 成员函数成员函数其实与普通的函数没有太大的差别，它可以被内联，也可以被重载，也可以使用默认参数，唯一的区别就是定义是要加上类域的帽子，但声明不需要，如class A&#123; void a();&#125;;void A :: a()&#123; //数据类型 所属类名 :: 函数名 cout &lt;&lt; &quot;我属于A类&quot; &lt;&lt; endl;&#125;· this指针在成员函数体内，有一种特殊的指针，this指针。this指针指向当前类对象本身，可以用this调用对象的成员：this -&gt; a();注意:this不能被改变，也不能在类作用域以外的地方使用· 内存中的类类包括数据成员和成员函数，但内存中的类只包括其数据成员，成员函数其实并不属于对象，它只是一个特殊的全局函数。· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：#include &lt;iostream&gt;using namespace std;class A &#123;public: int a; int b; char c; char d;&#125;;class B &#123;public: int a; char c; int b; char d;&#125;;int main() &#123; cout &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; sizeof(B) &lt;&lt; endl;&#125;输出如下：1216为了程序运行的效率，编译器在一定的设置下可能对成员排放位置做一些调整，使得整个结构体为一个字节长的整数倍，这就是所谓的“字节对齐”，上面演示了这种布局的差异，可以看出来，，不同的排列方式会引起类字节长度的差别，大家写代码一定要考虑这一点。 UML类图可以表示一个类，便于理解，如 私有是”-“前缀，共有则是”+”前缀 类名 数据成员 函数成员 类的讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657· 类与结构C++中提供结构和类。在数据成员上，它们唯一的差别在于：结构成员的默认访问控制为public，类的默认访问控制为private。class是一个全新的概念，所以人们更愿意接受class是真正的面向对象概念。而对于struct，人们更愿意用来描述那些没有行为或者行为能力很弱的数据结构体。· 抽象性在软件开发的分析、设计时对具体问题进行归纳、概括，并将这一类对象的公共特性加以条理化和严格描述，它主张集中思想和精力，考虑关键、主要、实质性的问题，去掉非主要的部分，便于开发人员对整个问题准确地认识。为具体的对象定义一个类的过程就是抽象。· 封装性保证程序员用正确的方式操作对象，并将一些操作细节隐藏起来。主要体现如下方面:--- 保护私有数据:不允许外部程序直接访问私有的数据--- 隐藏了操作细节:提供公用成员函数提供外部调用根据这两个方面,我们可以举一个例子来说明:#include &lt;iostream&gt;using namespace std;class A &#123; /** *声明一个A类，包含两个数据成员并封装成4个成员函数 *这里使用this指针加深印象 **/ string _name; string _sex;public: void setname(string name) &#123; this -&gt;_name = name; &#125; void setsex(string sex) &#123; this-&gt;_sex = sex; &#125; string getname() &#123; return this -&gt;_name; &#125; string getsex() &#123; return this -&gt;_sex; &#125;&#125;;int main() &#123; /** *使用指针的方法实例化A的一个对象 *定义两个string临时变量 *调用公共的数据成员封装函数进行赋值和输出 **/ A * a1 = new A(); string temp1,temp2; cout &lt;&lt; &quot;请输入你的姓名&quot;; cin &gt;&gt; temp1; a1-&gt;setname(temp1); cout &lt;&lt; &quot;请输入你的性别&quot;; cin &gt;&gt; temp2; a1-&gt;setsex(temp2); cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; a1-&gt;getname() &lt;&lt; endl; cout &lt;&lt; &quot;性别:&quot; &lt;&lt; a1-&gt;getsex() &lt;&lt; endl;&#125;程序员的责任就是封装复杂的数据和操作，以简单明了的共有函数的方式为外部程序提供对象操作接口]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ note1]]></title>
    <url>%2F2019%2F06%2F04%2FC%2B%2B%20note1-1%2F</url>
    <content type="text"><![CDATA[函数的一些积累 常用头文件#include -&gt; 包含头文件:输入输出流详情了解cin请点击传送门 using namespace std -&gt; std命名空间 #include -&gt; 包含向量的头文件 #include -&gt; 包含排序方法sort() -&gt; 数组升序排序reverse() -&gt; 数组逆序排序 #include -&gt; 迭代器 #include -&gt; 设置输出格式12setw(2) //设置字符宽度为2个字节 setiosflags(ios::left) //设置文字左对齐 #include -&gt; 字符串操作 123456789#include &lt;string&gt;string s; //定义string对象ss.length() //返回字符串长度，即字符个数s.empty() //判读字符串是否为空串s.at(i) //返回字符串的第i个字符s[i] //等同于s.at(i)s.substr(int i,int j) //获取从i到j的字符串其他方法getline(cin\cout,变量) //输入或输出变量 常用函数 memset() -&gt; 数组初始化函数]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ note2]]></title>
    <url>%2F2019%2F06%2F04%2FC%2B%2B%20note2%2F</url>
    <content type="text"><![CDATA[C++的一些知识补充 1 C++笔记学习方法 学习C++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C++源程序。一旦发现了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、高效的C++程序。 条件操作符 用法 :: &lt;表达式1#?&lt;表达式2#:&lt;表达式3#如果表达式为true，返回表达式2的值；否则返回表达式3的值 typeid操作符 用法 :: typeid(类型 || 变量).name()通过name()函数获取该类型或变量的名字。 安全使用数组下标 当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。 安全使用字符串 字符数组不是C++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子: 1234567891011char str1[] = &quot;hello&quot;;cout &lt;&lt; str1 &lt;&lt; endl;str1[5] = &apos;!&apos;;cout &lt;&lt; str1 &lt;&lt; endl;改代码输出了str1的末字符，输出如下:hello hello!烫烫烫？很显然，这不是我们想要的结果。使用&apos;\0&apos;作为字符串时C++的非强制性约定，编译器不负责字符串的安全。另一方面，由于字符串本身就是字符数组，也会带来越界访问的隐患。 void*指针 一种特殊的指针类型，可以存放任意对象的地址 注意:void*指针地址存放一个内存地址，地址指向内容不确定void*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void*指针 引用12int i;int &amp; ri = i; //类型 &amp; 变量 = 引用对象 结构常见错误 使用了未初始化的结构成员 指定了太多的初始值 枚举 枚举采用关键字enum，用来定义一组常量 12345678enum Arrow&#123; UP,DOWN,LEFT,RIGHT&#125;;Arrow a1 = UP; //okArrow a2 = 100; //errorcout &lt;&lt; a1 &lt;&lt; endl;输出结果为:0 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个枚举值。 typedef typedef提供了为某种既有类型取别名的功能。 123456789typedef int zhengxing;int t1;zhengxing t2; //int == zhengxing常见用法· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。· 另外一种就是函数的指针的类型定义，如：在Windows线程编程中，就有类似的线程函数接口定义：typedef void * LPVOID;typedef DWORD WINARI ThreadProc(LPVOID 1pParamter); 定义带参数的main()函数 main()函数支持另外一种原型 1234567891011int main(int argc,char * argv[]) &#123; cout &lt;&lt; &quot;参数数目:\t&quot; &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) &#123; cout &lt;&lt; &quot;参数&quot; &lt;&lt; i &lt;&lt; &quot;:\t\t&quot; &lt;&lt; argv[i] &lt;&lt; endl; &#125; return 0;&#125;输出结果为exe文件所在目录可以打开命令窗口进入到程序所在目录输入命令程序名+空格+bluejoe+vcer.net会输出程序的参数列表 预处理指令1234567891011121314预处理器一般完成如下操作：· 格式化代码，去多余的空格和注释；· 进行一些宏替换· 包含另外一段代码· 通过一些条件的判断，动态决定是否编译某段代码预处理指令#define //定义宏#undef //取消宏的定义#if //判断#else #elif#endif#error //输出错误信息#include //包含文件 宏指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657· 一般的，定义宏的时候可以为其指定替换的文本· 也可以把宏定义成某个表达式· rand()函数可以返回一个0~RAND_MAX之间的随机整数，RAND_MAX是由标准库函数定义的宏。如果需要取指定范围的随机数可以用到RAND_MAX,如int i = rand * 10 / RAND_MAX; //0~10之间的数· 宏可以包含参数，这样的宏也可以叫做宏函数，如：#define S(x) x * xint main()&#123; cout &lt;&lt; &quot;9的平方是:&quot; &lt;&lt; S(9) &lt;&lt; endl;&#125;· 宏函数具有一个很明显的优点，那就是避免了C++的强类型检测，如#define S(a,b) a+bint main() &#123; string s1 = &quot;Hello&quot;; string s2 = &quot;World&quot;; cout &lt;&lt; S(s1, s2) &lt;&lt; endl;&#125;· 宏与常量很相似，所以不能引用和指向宏定义的常量· 宏函数也是会有副作用的，如#define S(x) ((x) * (x))int i = 100;cout &lt;&lt; &quot;S(101);&quot; &lt;&lt; S(i++) &lt;&lt; endl;输出如下: S(101): 10000结果并不是我们期待的101*101，避免副作用的方法，那就是正确运用宏，把宏看成一种预编译时期的文本替换，而这，也正是宏原本的含义。· #操作符如果宏定义中出现了‘#’，预处理器会将#后面的参数括成一个字符串进行替换，如#define S(i) cout &lt;&lt; &quot;S(&quot;#i&quot;)&quot; &lt;&lt; ((i) * (i)) &lt;&lt; endl;S(90);//等同于cout &lt;&lt; &quot;S(&quot;90&quot;)&quot; &lt;&lt; ((90) * (90)) &lt;&lt; endl;· #操作符“#”用于将两侧的参数合并成一个。如#define RGB(rr,gg,bb) 0x#rr#gg#bbint red = RGB(FF,00,00);//会被替换成int red = 0xFF0000;· 取消宏“#undef”用于取消指定名字的宏，然后修改宏的值吐槽一下：个人不知道为什么不能直接删除然后修改· C++预定义宏_LINE_ //整数，代表代号所在行号 _FILE_ //字符串，代表当前代码所在的文件路径_DATe_ //字符串代表当前文件的编译日期_TIME_ //字符串代表当前文件的编译时间_STDC_ //代表是否为标准C_cplusplus_ //当前当前的C++版本· 可以使用这些宏实现特定的功能bool ok = false;if(!ok)&#123; cout &lt;&lt; &quot;发生错误:&quot; &lt;&lt; _FILE_ &lt;&lt; &quot;(&quot; &lt;&lt; _LINK_ &lt;&lt; &quot;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;该软件最后发布时间：&quot; &lt;&lt; _DATE_ &lt;&lt; &quot; &quot; &lt;&lt; _TIME_ &lt;&lt; endl;&#125; 条件编译指令 预处理通过某些条件的判断有选择的进行处理 123456789101112131415161718192021222324252627282930· #if···#endif(条件编译的结尾) · #else 和 #elif 与if语句相似分别与if语句中的else和else if相似#define IS 9int main()&#123;#if IS &lt; 10 cout &lt;&lt; &quot;TEST&quot; &lt;&lt; endl;#elif Is &lt; 5 cout &lt;&lt; &quot;TEST2&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;#endif return 0;&#125;· #if define 和 #if !define前者用于检测指定的宏是否定义#if define IS cout &lt;&lt; &quot;已定义&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;#endif这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）还可以使用&quot;!&quot;操作符，指定某个宏没有被定义的情形，也就是#if !define.(个人感觉等同于#undef)#if !define IS cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;#endif· #ifdef 和 #ifndef前者等价于#if define,后者等价于#if !define：相当于缩写 文件包含指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647· #include用于包含一个源文件文件名用&lt;#时，它指示预处理器从预设的标准路径中搜索指定的头文件。预设路径一般是编译器自带的include目录，当前也可以自己添加其他的目录文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。在一些编译器中，还可以使用相对路径查找头文件· C标准库头文件&lt;cassert# //assert宏的定义 &lt;cctype# //字符操作函数的操作&lt;cerrno# //错误码的定义&lt;cmath# //数学函数库&lt;setjmp# //错误处理库&lt;cstdarg# //可变参数处理宏的定义&lt;stdio# //标准输入输出的声明&lt;stdlib# //数字函数、内存管理函数、系统函数、随 机函数等的声明&lt;cstring# //C类型的字符串的操作函数的声明&lt;ctime# //日期、时间操作函数的声明· C++标准库的头文件&lt;string# //字符串&lt;iostream# //流操作&lt;fstream# //文件流&lt;complex# //复数&lt;stdexcept# //标准异常STL //标准模板库· 合理的使用头文件考虑如下情况：a.h 包含 point.h b.h 包含 point.hc.h 包含 a.h 和 b.h这种情况下，当编译器处理c.h时，重复定义就出现了解决办法是，类似如下的办法，重新设计point.h的内容#ifndef _HEADER_POINt_H_#define _HEADER_POINt_H_头文件内容#endif以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通过它来 判断当前文件是否已经被包含。这样一来，即使poin.h被包含多次，由#ifndef...#endif定义的point.h文件的内容也不会被包含多次· #error当编译器遇到#error指令时，会停止下来，并在编译窗口输出#error后面的信息· #line用于改变当前行的行号和文件名· #pragma属于自定义指令，每个编译器可以自己定义自己的功能 位域 定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省内存。 12345678struct Time&#123; unsigned hour : 5; //5 bits,0~31 unsigned minute : 6; //6 bits,0~63 unsigned second : 6; //6 bits,0~63&#125;;cout &lt;&lt; sizeof(Time) &lt;&lt;endl;输出结果：4 数据类型修饰符 const 中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量， 它具有自己的内存地址，不过它不可以被修改。 int i = 100; int m = 200; int* ip0 = &amp;i; //非const int* const ip1 = &amp;i; //const 修饰int* int const * ip2 = &amp;i; //const 修饰int const int* ip3 = &amp;i; //const 修饰int const int* const ip4 = &amp;i; //const 同时修饰ip4和*ip4 ip0 = &amp;m; *ip0 = 101; //ip1 = &amp;m; *ip1 = 101; ip2 = &amp;m; //*ip2 = 101; ip3 = &amp;m; //*ip3 = 101; //ip4 = &amp;m; //*ip4 = 101; 注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2 和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip 3恰恰相反。它们本身可以被指来指去，但是它们指向的内 容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。 ·常见用法 取代宏，定义一些不可更改的值 volatile不多见，一般情况下，只有底层才会有到，有兴趣可以百度。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell_note1]]></title>
    <url>%2F2019%2F06%2F02%2Fshell-note1%2F</url>
    <content type="text"><![CDATA[忘记了就进来看看 常用系统工作命令 echo命令 输出字符串或变量提取后的值，常用格式如下:echo 字符串 : 输出字符串在终端屏幕上echo $变量 : 输出变量提取过后的值 date显示及设置系统的时间或日期,常用格式如下:date : 默认格式查看系统时间date -d 字符串 : 给出字符串描述的时间，如date -d “2019-9-9” +参数参数(作用) : date –help 帮助信息 reboot重启系统，使用管理权限sudo reboot : 管理员权限重启系统 poweroff关闭系统，使用管理员权限sudo poweroff : 管理员权限关闭系统 wget在终端中下载网络文件，格式为wget 参数 下载地址-b : 后台下载模式-p : 下载到制定目录-t : 最大尝试次数-c : 断电续传-p : 下载页面内所有资源，包括图片，视频等-r : 递归下载 ps查看系统中的进程状态，格式为ps 参数-a : 显示所有进程-u : 用户以及其他详细信息-x : 显示没有控制终端的进程5种常见的进程状态:R 运行S 中断D 不可中断Z 僵死T 停止 top动态地监控进程活动与系统负载等信息–强化版任务管理器 pidof查询某个指定服务进程的PID值pifof 参数 服务名称 kill终止某个指定PID的服务进程kill 参数 进程PID killall终止某个指定名称的服务所对应的全部进程killall 参数 进程名称 系统状态检测命令 ifconfig获取网卡配置与网络状态等信息ifconfig 网络设备 参数 usame查看系统内核与系统版本等信息uname 参数 uptimeuptime查看系统的负载信息 free显示当前系统中内存的使用量信息free 参数 who查看当前登入主机的用户终端信息who 参数 last查看所有系统的登录记录last 参数 history显示历史执行过的命令history 参数 sosreport收集系统配置及架构信息并输出诊断文档 工作目录切换命令 pwd显示用户当前所在工作目录pwd 选项 cd切换工作路径cd 目录名称cd ~ 回到home目录cd / 回到根目录下cd .. 返回上一级目录 ls显示目录中的文件信息ls 选项 文件 文本文件编辑命令 cat查看内容较少的纯文本文件cat 选项 文件 more查看内容较多的纯文本文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[折腾manjaro的记录(一)]]></title>
    <url>%2F2019%2F06%2F02%2F%E6%8A%98%E8%85%BEmanjaro%E7%9A%84%E8%AE%B0%E5%BD%95-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[唉，终于还是要用Linux。。。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类的案例]]></title>
    <url>%2F2019%2F05%2F25%2FC-%E7%B1%BB%E7%9A%84%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。 项目截图下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ) 做项目需要的思维及流程图这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ 这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。 下面是写流程图需要思考的一些东西： 1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。 扑克牌之比大小流程图 进入游戏 展示游戏界面 开始游戏 游戏进行中 游戏输赢判定 提示是否继续游戏 继续就循环，否则退出游戏 额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。 项目的实现以及经验 主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。 在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。 项目的源代码源代码已经开放，点击项目源代码即可。 点进去直接打开源文件直接copy就行了 注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。 教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个链接。 如果有能力的同学可以扩展或者写一个更好( o=^•ェ•)o ┏━┓]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习面向对象思想的小结]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%AD%A6%E4%B9%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些小小小小的感悟吧！ 面向对象以前：在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。 在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！ ##面向对象 面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。 结语：刚踏入的小萌新，多多指教。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell快捷键大全]]></title>
    <url>%2F2019%2F05%2F09%2Fshell%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F05%2F06%2FMY_first_Blog%2F</url>
    <content type="text"><![CDATA[学了点git Git为什么要使用Git 协同修改 数据备份 版本管理 权限管理 历史纪录 分支管理 Git安装教程 Git的优势sdasdas]]></content>
  </entry>
</search>
