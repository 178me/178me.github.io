{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/background.jpg","path":"image/background.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/affix.js","path":"js/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/exturl.js","path":"js/exturl.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/post-details.js","path":"js/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/header.jpg","path":"images/header.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1559409948307},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1559409948307},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1559409948307},{"_id":"themes/hexo-theme-next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1559409948307},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1559409948307},{"_id":"themes/hexo-theme-next/.gitignore","hash":"3558a8b174618c7a643aceb13233edd729813f9a","modified":1559409948310},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1559409948310},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1559409948310},{"_id":"themes/hexo-theme-next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1559409948310},{"_id":"themes/hexo-theme-next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1559409948310},{"_id":"themes/hexo-theme-next/_config.yml","hash":"3266ad5f8213d1bb130033c4129443e58fbc8dd5","modified":1559573549223},{"_id":"themes/hexo-theme-next/bower.json","hash":"9bc3900396a375f817db47d147bb6d207c661678","modified":1559409948310},{"_id":"themes/hexo-theme-next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1559409948310},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1559409948313},{"_id":"themes/hexo-theme-next/package.json","hash":"0284636ddd0e06ae593f4887819f3a35b08c1370","modified":1559409948317},{"_id":"source/_posts/C++ note1-1.md","hash":"edc31ba9302724f9d70ea1853d851930e7dda07e","modified":1559640321416},{"_id":"source/_posts/C++ note2.md","hash":"8f34c6e8b052aba92c5c15d0a2823f9fe95bfc13","modified":1559641400946},{"_id":"source/_posts/C++ note3.md","hash":"85213ecd936ecd6ab80d75ce87b6841f5407fc4d","modified":1559652221743},{"_id":"source/_posts/C-类的案例.md","hash":"623bb43dcd6930e23da6223e05bc49c546b949ed","modified":1559650517390},{"_id":"source/_posts/MY_first_Blog.md","hash":"a0c2b48994199ae863fcf53ec1eab445ad4cb9fb","modified":1559409948307},{"_id":"source/_posts/shell-note1.md","hash":"4dd0b9312cac1ff4161da0667c77dbbe3971fccf","modified":1559640379876},{"_id":"source/_posts/shell快捷键大全.md","hash":"e121fc58f4f98f9ee3c0d8a200b571e5d8d294ca","modified":1559409948307},{"_id":"source/_posts/学习面向对象思想的小结.md","hash":"be185eecd260c5db67f88686bde5a33744664b32","modified":1559650480330},{"_id":"source/_posts/折腾manjaro的记录-一.md","hash":"4677f5a151db9626b99b0a96d5d77b7c8332692a","modified":1559479290100},{"_id":"source/categories/index-1.md","hash":"00766a2c95e5af34faa82e30ebf6285f85df2d3e","modified":1559478915090},{"_id":"source/categories/index.md","hash":"d49faee5f4f5cc45e0c98fe1e57e6b98dec95ae1","modified":1559478043513},{"_id":"source/tags/index.md","hash":"1cfe5abc3e2787e03d97c8fe7187d00112f7cc24","modified":1559478262786},{"_id":"source/image/background.jpg","hash":"5cb93fb5a8f61cd54454743005bd696f00da6e65","modified":1559568196000},{"_id":"themes/hexo-theme-next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"285a95aca36e0ac770bcde2b35e3b572d45d1518","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"492b2c159d871e5b5d4c70d259f36e603afe192d","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/mergeable.yml","hash":"8e3a6abc74b5cba57f9586fe6d98762fd4fc9b04","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/release-drafter.yml","hash":"b4476ada5c62ee7d63ba2e59ead2ec4897086e3c","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/topissuebot.yml","hash":"10665bf2b5aba351725715c71e94ad183a0e8f18","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/weekly-digest.yml","hash":"404e4ccb7fcd6587bc9b0247a7a7ff256d21f2cb","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/MATH.md","hash":"026d2cff73c22a30ea39c50783557ff4913aceac","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1559409948310},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/es.yml","hash":"1752429687861b5cedd063c6ebe5dacefbe7e5a7","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/fa.yml","hash":"cd41db832af5e399590b70a5227cfe0b0e98e101","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/fr.yml","hash":"7005c2b42c2c6e82bd7a1be5cc2f443b5fc79105","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1559409948313},{"_id":"themes/hexo-theme-next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"74701fcf2303d59400587436ab4c244e04df7ad9","modified":1559475735853},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"d8a6cbf6f611c5d68d5da430cb6dc7010ff2c7e0","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1559409948317},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1559409948327},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1559409948327},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1559409948327},{"_id":"themes/hexo-theme-next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1559409948310},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559409948323},{"_id":"source/_posts/C-类的案例/1.png","hash":"32e392b00a64d80dabac5bd439901132ccfe7b5a","modified":1559409948307},{"_id":"source/_posts/C-类的案例/3.png","hash":"9a418cc05389d3ee036d1766c4a76df4b0408824","modified":1559409948307},{"_id":"source/_posts/C-类的案例/步骤1.png","hash":"caa41a35be309bd173239043f905895ea4798b14","modified":1559409948307},{"_id":"source/_posts/C-类的案例/步骤二.png","hash":"0f66a8282a543cc0aaa7f4f500d02085a5e6b75e","modified":1559409948307},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1559409948310},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"bc43beb3af74d64fbd3920539d08861e4cadb9a0","modified":1559409948310},{"_id":"themes/hexo-theme-next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1559409948313},{"_id":"themes/hexo-theme-next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1559409948313},{"_id":"themes/hexo-theme-next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1559409948313},{"_id":"themes/hexo-theme-next/docs/zh-CN/MATH.md","hash":"83feca62190abcca0332915ffe0eefe582573085","modified":1559409948313},{"_id":"themes/hexo-theme-next/docs/zh-CN/README.md","hash":"cdd7a8bdcf4a83ff4c74ee6c95c6bcc0b8c1831c","modified":1559409948313},{"_id":"themes/hexo-theme-next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"8a8a2865b09e933c454d9a68e54dd9063dc8c559","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"480d93619479dcfcbec6906803bb38b2dfbeae53","modified":1559475856226},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"5352f96f4544c1520babf1cec7b44ddf2f8057b3","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"589f545333e21a8c7823bce89ab45cf1eb7db6e2","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"83470eb401f78f4683907c48ad6760b90730daa3","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/chatra.swig","hash":"eefb68b69b4b0ed558ee0324ccd711990059b20d","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/copy-code.swig","hash":"9be7c2c9cef63006866d1232c5289901e46be7ed","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/quicklink.swig","hash":"5db80e8d7ea3f29e998320f79508f7e14342a33c","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1559409948317},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1559409948323},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1559409948317},{"_id":"themes/hexo-theme-next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1559409948317},{"_id":"themes/hexo-theme-next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/header.jpg","hash":"5cb93fb5a8f61cd54454743005bd696f00da6e65","modified":1559568196000},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1559409948323},{"_id":"source/_posts/C-类的案例/2.png","hash":"e644f7b6a50cfb2b3bdb496593f3222c5c8953f2","modified":1559409948307},{"_id":"source/_posts/MY_first_Blog/优势.png","hash":"c67641427b13ecdb8ee1381520771b710cc58402","modified":1559409948307},{"_id":"source/_posts/C-类的案例/流程图.jpg","hash":"cd6b0c88d9cddb6989f70003e33a0932ae4b8139","modified":1559409948307},{"_id":"themes/hexo-theme-next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1559409948317},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1559409948323},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/head/head.swig","hash":"36eae78a4d7160a1c5e59ca3f7333f00b43d359b","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1559409948313},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"d422beaf35a5d2646feaa098bc3e5adf691c7565","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqusjs.swig","hash":"c77a2e7ef5f449a445fb4d36b055721fba4a81af","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"388efc86af7f19c05ad0e26720cd24ee012d20b9","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"2cbaae65a020bbb0e9265364488aff8bf84fa48d","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"4a908b613518878b9b69576c5dba4a5185f552ab","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1559409948317},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1559409948317},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"2036bbb73afd43251982ce824f06c6e88d35a2ef","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"640f25a63770af5566ccc9cec79c40a4f1c0b29e","modified":1559475343943},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1559409948327},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1559409948327},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1559409948327},{"_id":"source/_posts/MY_first_Blog/功能.png","hash":"dade0e789db406f4c65e2ae2d40800be411a85ea","modified":1559409948307},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1559409948317},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1559409948327},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"fe5ff961b86004a306778c7d33a85b32e5e00e48","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"c8b3225396cb444d8baeb94bac78e5216b992a81","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"9d71f34fa13a41b8c8cd2fbdf3fdea608385277c","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"9a190ef2f49bdbf69604b48ad1dc7197895ee9b6","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"33456264a74d1bba38264d14713544d67d003733","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"57044a6d19eb418c1c3d28787e82c69efa9e0ca6","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"cc6a9929a6bb7c90149ec340c24669c1c779b270","modified":1559569648060},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"e9dd8de7d98f1478ac7d351624fffd3d8738c905","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"1385862a5c0bd845015d165aadbd1a6add7b72d7","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"b082d07b13a3d55b4c032fd351dfa9a4fd74edec","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"a3170630d8e085889a4bdc20eb7f09c5a0479c47","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1559475309593},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cc83816614f21c7e1d8d3f867d547ff7c658cec4","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c01609176929590f8f347075a9a12b661acd661e","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"fcda60fecff1479adaf6521cf629cda2506337a8","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"f1d9ee1f86a179741f2478f8c70ca11ab578810e","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"03c4fa9573fddd930552784cf484fd2ee7825323","modified":1559409948320},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1559409948323},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1559409948327}],"Category":[{"name":"C++","_id":"cjwhso7730004u4im1q3vmtzv"},{"name":"Linux","_id":"cjwhso77g000fu4imvo6i82fd"}],"Data":[],"Page":[{"title":"C++","date":"2019-06-02T12:25:29.000Z","type":"categories","_content":"","source":"categories/index-1.md","raw":"---\ntitle: C++\ndate: 2019-06-02 20:25:29\ntype:  \"categories\"\n---\n","updated":"2019-06-02T12:35:15.090Z","path":"categories/index-1.html","comments":1,"layout":"page","_id":"cjwhso7700001u4immtpohkqt","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Linux","date":"2019-06-02T12:12:44.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Linux\ndate: 2019-06-02 20:12:44\ntype:  \"categories\"\n---\n","updated":"2019-06-02T12:20:43.513Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjwhso7720003u4imrlm7vdtz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"note","date":"2019-06-02T12:23:11.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: note\ndate: 2019-06-02 20:23:11\ntype: \"tags\"\n---\n","updated":"2019-06-02T12:24:22.786Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjwhso7760007u4im75l6aft9","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++ note1","date":"2019-06-04T08:47:09.000Z","_content":"函数的一些积累\n\n<!--more-->  \n\n常用头文件\n---\n**#include <iostream> -> 包含头文件:输入输出流**  \n详情了解cin请点击[传送门](https://blog.csdn.net/weixin_41042404/article/details/80934191)  \n\n\n**using namespace std -> std命名空间**  \n\n**#include <vector> -> 包含向量的头文件**\n\n**#include <algorithm> -> 包含排序方法**   \nsort() -> 数组升序排序  \nreverse() -> 数组逆序排序\n\n**#include <iterator> -> 迭代器**  \n\n**#include <iomanip> -> 设置输出格式**  \n```\nsetw(2)  //设置字符宽度为2个字节  \nsetiosflags(ios::left)  //设置文字左对齐\n\n```\n**#include <string> -> 字符串操作**  \n\n```\n#include <string>\nstring s;      //定义string对象s\ns.length()     //返回字符串长度，即字符个数\ns.empty()      //判读字符串是否为空串\ns.at(i)        //返回字符串的第i个字符\ns[i]           //等同于s.at(i)\ns.substr(int i,int j)     //获取从i到j的字符串\n其他方法\ngetline(cin\\cout,变量)    //输入或输出变量\n```\n常用函数  \n---\n> **[memset()](https://blog.csdn.net/qq_22122811/article/details/52738029)** -> 数组初始化函数\n\n\n\n","source":"_posts/C++ note1-1.md","raw":"---\ntitle: C++ note1\ndate: 2019-06-04 16:47:09\ntags: note\ncategories: C++\n---\n函数的一些积累\n\n<!--more-->  \n\n常用头文件\n---\n**#include <iostream> -> 包含头文件:输入输出流**  \n详情了解cin请点击[传送门](https://blog.csdn.net/weixin_41042404/article/details/80934191)  \n\n\n**using namespace std -> std命名空间**  \n\n**#include <vector> -> 包含向量的头文件**\n\n**#include <algorithm> -> 包含排序方法**   \nsort() -> 数组升序排序  \nreverse() -> 数组逆序排序\n\n**#include <iterator> -> 迭代器**  \n\n**#include <iomanip> -> 设置输出格式**  \n```\nsetw(2)  //设置字符宽度为2个字节  \nsetiosflags(ios::left)  //设置文字左对齐\n\n```\n**#include <string> -> 字符串操作**  \n\n```\n#include <string>\nstring s;      //定义string对象s\ns.length()     //返回字符串长度，即字符个数\ns.empty()      //判读字符串是否为空串\ns.at(i)        //返回字符串的第i个字符\ns[i]           //等同于s.at(i)\ns.substr(int i,int j)     //获取从i到j的字符串\n其他方法\ngetline(cin\\cout,变量)    //输入或输出变量\n```\n常用函数  \n---\n> **[memset()](https://blog.csdn.net/qq_22122811/article/details/52738029)** -> 数组初始化函数\n\n\n\n","slug":"C++ note1-1","published":1,"updated":"2019-06-04T09:25:21.416Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso76w0000u4im5y7vmjpp","content":"<p>函数的一些积累</p>\n<a id=\"more\"></a>  \n<h2 id=\"常用头文件\"><a href=\"#常用头文件\" class=\"headerlink\" title=\"常用头文件\"></a>常用头文件</h2><p><strong>#include <iostream> -&gt; 包含头文件:输入输出流</iostream></strong><br>详情了解cin请点击<a href=\"https://blog.csdn.net/weixin_41042404/article/details/80934191\" target=\"_blank\" rel=\"noopener\">传送门</a>  </p>\n<p><strong>using namespace std -&gt; std命名空间</strong>  </p>\n<p><strong>#include <vector> -&gt; 包含向量的头文件</vector></strong></p>\n<p><strong>#include <algorithm> -&gt; 包含排序方法</algorithm></strong><br>sort() -&gt; 数组升序排序<br>reverse() -&gt; 数组逆序排序</p>\n<p><strong>#include <iterator> -&gt; 迭代器</iterator></strong>  </p>\n<p><strong>#include <iomanip> -&gt; 设置输出格式</iomanip></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setw(2)  //设置字符宽度为2个字节  </span><br><span class=\"line\">setiosflags(ios::left)  //设置文字左对齐</span><br></pre></td></tr></table></figure></p>\n<p><strong>#include <string> -&gt; 字符串操作</string></strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">string s;      //定义string对象s</span><br><span class=\"line\">s.length()     //返回字符串长度，即字符个数</span><br><span class=\"line\">s.empty()      //判读字符串是否为空串</span><br><span class=\"line\">s.at(i)        //返回字符串的第i个字符</span><br><span class=\"line\">s[i]           //等同于s.at(i)</span><br><span class=\"line\">s.substr(int i,int j)     //获取从i到j的字符串</span><br><span class=\"line\">其他方法</span><br><span class=\"line\">getline(cin\\cout,变量)    //输入或输出变量</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数  \"></a>常用函数  </h2><blockquote>\n<p><strong><a href=\"https://blog.csdn.net/qq_22122811/article/details/52738029\" target=\"_blank\" rel=\"noopener\">memset()</a></strong> -&gt; 数组初始化函数</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>函数的一些积累</p>","more":"<h2 id=\"常用头文件\"><a href=\"#常用头文件\" class=\"headerlink\" title=\"常用头文件\"></a>常用头文件</h2><p><strong>#include <iostream> -&gt; 包含头文件:输入输出流</iostream></strong><br>详情了解cin请点击<a href=\"https://blog.csdn.net/weixin_41042404/article/details/80934191\" target=\"_blank\" rel=\"noopener\">传送门</a>  </p>\n<p><strong>using namespace std -&gt; std命名空间</strong>  </p>\n<p><strong>#include <vector> -&gt; 包含向量的头文件</vector></strong></p>\n<p><strong>#include <algorithm> -&gt; 包含排序方法</algorithm></strong><br>sort() -&gt; 数组升序排序<br>reverse() -&gt; 数组逆序排序</p>\n<p><strong>#include <iterator> -&gt; 迭代器</iterator></strong>  </p>\n<p><strong>#include <iomanip> -&gt; 设置输出格式</iomanip></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setw(2)  //设置字符宽度为2个字节  </span><br><span class=\"line\">setiosflags(ios::left)  //设置文字左对齐</span><br></pre></td></tr></table></figure></p>\n<p><strong>#include <string> -&gt; 字符串操作</string></strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">string s;      //定义string对象s</span><br><span class=\"line\">s.length()     //返回字符串长度，即字符个数</span><br><span class=\"line\">s.empty()      //判读字符串是否为空串</span><br><span class=\"line\">s.at(i)        //返回字符串的第i个字符</span><br><span class=\"line\">s[i]           //等同于s.at(i)</span><br><span class=\"line\">s.substr(int i,int j)     //获取从i到j的字符串</span><br><span class=\"line\">其他方法</span><br><span class=\"line\">getline(cin\\cout,变量)    //输入或输出变量</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数  \"></a>常用函数  </h2><blockquote>\n<p><strong><a href=\"https://blog.csdn.net/qq_22122811/article/details/52738029\" target=\"_blank\" rel=\"noopener\">memset()</a></strong> -&gt; 数组初始化函数</p>\n</blockquote>"},{"title":"C++类的案例","date":"2019-05-25T07:48:43.000Z","_content":"\n前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。\n\n<!--more-->\n\n# **项目截图**  \n\n下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)\n\n---\n\n![游戏界面1](C-类的案例\\1.png \"玩家出牌\")\n\n![游戏界面1](C-类的案例\\2.png \"比大小结果\")\n\n![游戏界面1](C-类的案例\\3.png \"胜负判定\")\n\n## **做项目需要的思维及流程图**\n\n这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ\n\n这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。\n\n- 下面是写流程图需要思考的一些东西：\n\n>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。  \n>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；  \n>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。\n>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。\n\n- 扑克牌之比大小流程图\n    - 进入游戏\n    - 展示游戏界面\n    - 开始游戏\n    - 游戏进行中\n    - 游戏输赢判定\n    - 提示是否继续游戏 继续就循环，否则退出游戏\n\n额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。\n\n![简易的流程图](C-类的案例\\流程图.jpg \"流程图\")\n\n### **项目的实现以及经验**\n\n> 主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    \n>> 在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。  \n>>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。   \n>>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。\n\n#### **项目的源代码**\n\n源代码已经开放，点击[项目源代码](https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast)即可。\n\n点进去直接打开源文件直接copy就行了\n\n注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。\n\n![](C-类的案例\\步骤1.png)\n\n\n![](C-类的案例\\步骤二.png)\n\n教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个[链接](https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html)。\n\n\n\n如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓\n\n","source":"_posts/C-类的案例.md","raw":"---\ntitle: C++类的案例\ndate: 2019-05-25 15:48:43\ntags:\ncategories: C++\n---\n\n前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。\n\n<!--more-->\n\n# **项目截图**  \n\n下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)\n\n---\n\n![游戏界面1](C-类的案例\\1.png \"玩家出牌\")\n\n![游戏界面1](C-类的案例\\2.png \"比大小结果\")\n\n![游戏界面1](C-类的案例\\3.png \"胜负判定\")\n\n## **做项目需要的思维及流程图**\n\n这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ\n\n这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。\n\n- 下面是写流程图需要思考的一些东西：\n\n>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。  \n>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；  \n>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。\n>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。\n\n- 扑克牌之比大小流程图\n    - 进入游戏\n    - 展示游戏界面\n    - 开始游戏\n    - 游戏进行中\n    - 游戏输赢判定\n    - 提示是否继续游戏 继续就循环，否则退出游戏\n\n额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。\n\n![简易的流程图](C-类的案例\\流程图.jpg \"流程图\")\n\n### **项目的实现以及经验**\n\n> 主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    \n>> 在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。  \n>>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。   \n>>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。\n\n#### **项目的源代码**\n\n源代码已经开放，点击[项目源代码](https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast)即可。\n\n点进去直接打开源文件直接copy就行了\n\n注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。\n\n![](C-类的案例\\步骤1.png)\n\n\n![](C-类的案例\\步骤二.png)\n\n教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个[链接](https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html)。\n\n\n\n如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓\n\n","slug":"C-类的案例","published":1,"updated":"2019-06-04T12:15:17.390Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso7700002u4iml1hmb4ie","content":"<p>前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。</p>\n<a id=\"more\"></a>\n<h1 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a><strong>项目截图</strong></h1><p>下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)</p>\n<hr>\n<p><img src=\"/2019/05/25/C-类的案例/1.png\" alt=\"游戏界面1\" title=\"玩家出牌\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/2.png\" alt=\"游戏界面1\" title=\"比大小结果\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/3.png\" alt=\"游戏界面1\" title=\"胜负判定\"></p>\n<h2 id=\"做项目需要的思维及流程图\"><a href=\"#做项目需要的思维及流程图\" class=\"headerlink\" title=\"做项目需要的思维及流程图\"></a><strong>做项目需要的思维及流程图</strong></h2><p>这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ</p>\n<p>这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。</p>\n<ul>\n<li>下面是写流程图需要思考的一些东西：</li>\n</ul>\n<blockquote>\n<p>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。<br>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；<br>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。<br>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。</p>\n</blockquote>\n<ul>\n<li>扑克牌之比大小流程图<ul>\n<li>进入游戏</li>\n<li>展示游戏界面</li>\n<li>开始游戏</li>\n<li>游戏进行中</li>\n<li>游戏输赢判定</li>\n<li>提示是否继续游戏 继续就循环，否则退出游戏</li>\n</ul>\n</li>\n</ul>\n<p>额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。</p>\n<p><img src=\"/2019/05/25/C-类的案例/流程图.jpg\" alt=\"简易的流程图\" title=\"流程图\"></p>\n<h3 id=\"项目的实现以及经验\"><a href=\"#项目的实现以及经验\" class=\"headerlink\" title=\"项目的实现以及经验\"></a><strong>项目的实现以及经验</strong></h3><blockquote>\n<p>主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    </p>\n<blockquote>\n<p>在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。<br>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。<br>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"项目的源代码\"><a href=\"#项目的源代码\" class=\"headerlink\" title=\"项目的源代码\"></a><strong>项目的源代码</strong></h4><p>源代码已经开放，点击<a href=\"https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast\" target=\"_blank\" rel=\"noopener\">项目源代码</a>即可。</p>\n<p>点进去直接打开源文件直接copy就行了</p>\n<p>注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。</p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤1.png\" alt></p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤二.png\" alt></p>\n<p>教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个<a href=\"https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓</p>\n","site":{"data":{}},"excerpt":"<p>前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。</p>","more":"<h1 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a><strong>项目截图</strong></h1><p>下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)</p>\n<hr>\n<p><img src=\"/2019/05/25/C-类的案例/1.png\" alt=\"游戏界面1\" title=\"玩家出牌\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/2.png\" alt=\"游戏界面1\" title=\"比大小结果\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/3.png\" alt=\"游戏界面1\" title=\"胜负判定\"></p>\n<h2 id=\"做项目需要的思维及流程图\"><a href=\"#做项目需要的思维及流程图\" class=\"headerlink\" title=\"做项目需要的思维及流程图\"></a><strong>做项目需要的思维及流程图</strong></h2><p>这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ</p>\n<p>这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。</p>\n<ul>\n<li>下面是写流程图需要思考的一些东西：</li>\n</ul>\n<blockquote>\n<p>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。<br>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；<br>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。<br>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。</p>\n</blockquote>\n<ul>\n<li>扑克牌之比大小流程图<ul>\n<li>进入游戏</li>\n<li>展示游戏界面</li>\n<li>开始游戏</li>\n<li>游戏进行中</li>\n<li>游戏输赢判定</li>\n<li>提示是否继续游戏 继续就循环，否则退出游戏</li>\n</ul>\n</li>\n</ul>\n<p>额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。</p>\n<p><img src=\"/2019/05/25/C-类的案例/流程图.jpg\" alt=\"简易的流程图\" title=\"流程图\"></p>\n<h3 id=\"项目的实现以及经验\"><a href=\"#项目的实现以及经验\" class=\"headerlink\" title=\"项目的实现以及经验\"></a><strong>项目的实现以及经验</strong></h3><blockquote>\n<p>主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    </p>\n<blockquote>\n<p>在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。<br>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。<br>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"项目的源代码\"><a href=\"#项目的源代码\" class=\"headerlink\" title=\"项目的源代码\"></a><strong>项目的源代码</strong></h4><p>源代码已经开放，点击<a href=\"https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast\" target=\"_blank\" rel=\"noopener\">项目源代码</a>即可。</p>\n<p>点进去直接打开源文件直接copy就行了</p>\n<p>注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。</p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤1.png\" alt></p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤二.png\" alt></p>\n<p>教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个<a href=\"https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓</p>"},{"title":"我的第一篇博客","date":"2019-05-06T06:46:51.000Z","_content":"\n学了点git\n<!--more-->\n\n# Git\n\n### **为什么要使用Git**\n\n![GIT功能](MY_first_Blog\\功能.png)\n\n- 协同修改\n\n- 数据备份\n\n- 版本管理\n\n- 权限管理\n\n- 历史纪录 \n\n- 分支管理\n\n-------\n\n[Git安装教程]()\n\n-------\n## **Git的优势**\n\nsdasdas\n\n\n","source":"_posts/MY_first_Blog.md","raw":"---\ntitle: 我的第一篇博客\ndate: 2019-05-06 14:46:51\ntags:\n---\n\n学了点git\n<!--more-->\n\n# Git\n\n### **为什么要使用Git**\n\n![GIT功能](MY_first_Blog\\功能.png)\n\n- 协同修改\n\n- 数据备份\n\n- 版本管理\n\n- 权限管理\n\n- 历史纪录 \n\n- 分支管理\n\n-------\n\n[Git安装教程]()\n\n-------\n## **Git的优势**\n\nsdasdas\n\n\n","slug":"MY_first_Blog","published":1,"updated":"2019-06-01T17:25:48.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso7750006u4imj6gutry9","content":"<p>学了点git<br><a id=\"more\"></a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h3 id=\"为什么要使用Git\"><a href=\"#为什么要使用Git\" class=\"headerlink\" title=\"为什么要使用Git\"></a><strong>为什么要使用Git</strong></h3><p><img src=\"/2019/05/06/MY_first_Blog/功能.png\" alt=\"GIT功能\"></p>\n<ul>\n<li><p>协同修改</p>\n</li>\n<li><p>数据备份</p>\n</li>\n<li><p>版本管理</p>\n</li>\n<li><p>权限管理</p>\n</li>\n<li><p>历史纪录 </p>\n</li>\n<li><p>分支管理</p>\n</li>\n</ul>\n<hr>\n<p><a href>Git安装教程</a></p>\n<hr>\n<h2 id=\"Git的优势\"><a href=\"#Git的优势\" class=\"headerlink\" title=\"Git的优势\"></a><strong>Git的优势</strong></h2><p>sdasdas</p>\n","site":{"data":{}},"excerpt":"<p>学了点git<br></p>","more":"<p></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h3 id=\"为什么要使用Git\"><a href=\"#为什么要使用Git\" class=\"headerlink\" title=\"为什么要使用Git\"></a><strong>为什么要使用Git</strong></h3><p><img src=\"/2019/05/06/MY_first_Blog/功能.png\" alt=\"GIT功能\"></p>\n<ul>\n<li><p>协同修改</p>\n</li>\n<li><p>数据备份</p>\n</li>\n<li><p>版本管理</p>\n</li>\n<li><p>权限管理</p>\n</li>\n<li><p>历史纪录 </p>\n</li>\n<li><p>分支管理</p>\n</li>\n</ul>\n<hr>\n<p><a href>Git安装教程</a></p>\n<hr>\n<h2 id=\"Git的优势\"><a href=\"#Git的优势\" class=\"headerlink\" title=\"Git的优势\"></a><strong>Git的优势</strong></h2><p>sdasdas</p>"},{"title":"shell_note1","date":"2019-06-02T13:17:37.000Z","_content":"忘记了就进来看看\n\n<!--more-->\n# 常用系统工作命令  \n- **echo命令**  \n\n输出字符串或变量提取后的值，常用格式如下:  \necho 字符串 : 输出字符串在终端屏幕上  \necho $变量 : 输出变量提取过后的值  \n- **date**  \n 显示及设置系统的时间或日期,常用格式如下:  \ndate : 默认格式查看系统时间  \ndate -d 字符串 : 给出字符串描述的时间，如date -d \"2019-9-9\" +参数   \n参数(作用) : date --help 帮助信息  \n- **reboot**  \n重启系统，使用管理权限  \nsudo reboot : 管理员权限重启系统   \n- **poweroff**  \n关闭系统，使用管理员权限  \nsudo poweroff : 管理员权限关闭系统  \n- **wget**  \n 在终端中下载网络文件，格式为  \nwget 参数 下载地址   \n-b : 后台下载模式  \n-p : 下载到制定目录  \n-t : 最大尝试次数  \n-c : 断电续传\n-p : 下载页面内所有资源，包括图片，视频等  \n-r : 递归下载  \n- **ps**  \n查看系统中的进程状态，格式为  \nps 参数  \n-a : 显示所有进程  \n-u : 用户以及其他详细信息\n-x : 显示没有控制终端的进程  \n5种常见的进程状态:  \nR 运行  \nS 中断  \nD 不可中断  \nZ 僵死  \nT 停止  \n\n- **top**  \n 动态地监控进程活动与系统负载等信息--强化版任务管理器  \n\n- **pidof**  \n 查询某个指定服务进程的PID值  \npifof 参数 服务名称  \n\n- **kill**  \n 终止某个指定PID的服务进程  \nkill 参数 进程PID  \n\n- **killall**  \n 终止某个指定名称的服务所对应的全部进程  \nkillall 参数 进程名称  \n\n## 系统状态检测命令  \n- **ifconfig**  \n 获取网卡配置与网络状态等信息  \nifconfig 网络设备 参数  \n\n- **usame**  \n查看系统内核与系统版本等信息\nuname 参数  \n\n- **uptime**   \nuptime  \n查看系统的负载信息  \n\n- **free**  \n显示当前系统中内存的使用量信息  \nfree 参数  \n\n- **who**  \n查看当前登入主机的用户终端信息  \nwho 参数  \n\n- **last**  \n查看所有系统的登录记录  \nlast 参数  \n\n- **history** \n显示历史执行过的命令  \nhistory 参数  \n\n- **sosreport**  \n收集系统配置及架构信息并输出诊断文档  \n\n### 工作目录切换命令  \n- **pwd**  \n显示用户当前所在工作目录  \npwd 选项  \n\n- **cd**  \n切换工作路径  \ncd 目录名称  \ncd ~    回到home目录\ncd /    回到根目录下\ncd ..   返回上一级目录  \n\n- **ls**  \n显示目录中的文件信息  \nls 选项 文件  \n\n文本文件编辑命令\n---\n- **cat**  \n查看内容较少的纯文本文件\ncat 选项 文件  \n\n- **more**  \n查看内容较多的纯文本文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/shell-note1.md","raw":"---\ntitle: shell_note1\ndate: 2019-06-02 21:17:37\ntags: note\ncategories: Linux\n---\n忘记了就进来看看\n\n<!--more-->\n# 常用系统工作命令  \n- **echo命令**  \n\n输出字符串或变量提取后的值，常用格式如下:  \necho 字符串 : 输出字符串在终端屏幕上  \necho $变量 : 输出变量提取过后的值  \n- **date**  \n 显示及设置系统的时间或日期,常用格式如下:  \ndate : 默认格式查看系统时间  \ndate -d 字符串 : 给出字符串描述的时间，如date -d \"2019-9-9\" +参数   \n参数(作用) : date --help 帮助信息  \n- **reboot**  \n重启系统，使用管理权限  \nsudo reboot : 管理员权限重启系统   \n- **poweroff**  \n关闭系统，使用管理员权限  \nsudo poweroff : 管理员权限关闭系统  \n- **wget**  \n 在终端中下载网络文件，格式为  \nwget 参数 下载地址   \n-b : 后台下载模式  \n-p : 下载到制定目录  \n-t : 最大尝试次数  \n-c : 断电续传\n-p : 下载页面内所有资源，包括图片，视频等  \n-r : 递归下载  \n- **ps**  \n查看系统中的进程状态，格式为  \nps 参数  \n-a : 显示所有进程  \n-u : 用户以及其他详细信息\n-x : 显示没有控制终端的进程  \n5种常见的进程状态:  \nR 运行  \nS 中断  \nD 不可中断  \nZ 僵死  \nT 停止  \n\n- **top**  \n 动态地监控进程活动与系统负载等信息--强化版任务管理器  \n\n- **pidof**  \n 查询某个指定服务进程的PID值  \npifof 参数 服务名称  \n\n- **kill**  \n 终止某个指定PID的服务进程  \nkill 参数 进程PID  \n\n- **killall**  \n 终止某个指定名称的服务所对应的全部进程  \nkillall 参数 进程名称  \n\n## 系统状态检测命令  \n- **ifconfig**  \n 获取网卡配置与网络状态等信息  \nifconfig 网络设备 参数  \n\n- **usame**  \n查看系统内核与系统版本等信息\nuname 参数  \n\n- **uptime**   \nuptime  \n查看系统的负载信息  \n\n- **free**  \n显示当前系统中内存的使用量信息  \nfree 参数  \n\n- **who**  \n查看当前登入主机的用户终端信息  \nwho 参数  \n\n- **last**  \n查看所有系统的登录记录  \nlast 参数  \n\n- **history** \n显示历史执行过的命令  \nhistory 参数  \n\n- **sosreport**  \n收集系统配置及架构信息并输出诊断文档  \n\n### 工作目录切换命令  \n- **pwd**  \n显示用户当前所在工作目录  \npwd 选项  \n\n- **cd**  \n切换工作路径  \ncd 目录名称  \ncd ~    回到home目录\ncd /    回到根目录下\ncd ..   返回上一级目录  \n\n- **ls**  \n显示目录中的文件信息  \nls 选项 文件  \n\n文本文件编辑命令\n---\n- **cat**  \n查看内容较少的纯文本文件\ncat 选项 文件  \n\n- **more**  \n查看内容较多的纯文本文件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"shell-note1","published":1,"updated":"2019-06-04T09:26:19.876Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso7770008u4im18athr1j","content":"<p>忘记了就进来看看</p>\n<a id=\"more\"></a>\n<h1 id=\"常用系统工作命令\"><a href=\"#常用系统工作命令\" class=\"headerlink\" title=\"常用系统工作命令\"></a>常用系统工作命令</h1><ul>\n<li><strong>echo命令</strong>  </li>\n</ul>\n<p>输出字符串或变量提取后的值，常用格式如下:<br>echo 字符串 : 输出字符串在终端屏幕上<br>echo $变量 : 输出变量提取过后的值  </p>\n<ul>\n<li><strong>date</strong><br>显示及设置系统的时间或日期,常用格式如下:<br>date : 默认格式查看系统时间<br>date -d 字符串 : 给出字符串描述的时间，如date -d “2019-9-9” +参数<br>参数(作用) : date –help 帮助信息  </li>\n<li><strong>reboot</strong><br>重启系统，使用管理权限<br>sudo reboot : 管理员权限重启系统   </li>\n<li><strong>poweroff</strong><br>关闭系统，使用管理员权限<br>sudo poweroff : 管理员权限关闭系统  </li>\n<li><strong>wget</strong><br>在终端中下载网络文件，格式为<br>wget 参数 下载地址<br>-b : 后台下载模式<br>-p : 下载到制定目录<br>-t : 最大尝试次数<br>-c : 断电续传<br>-p : 下载页面内所有资源，包括图片，视频等<br>-r : 递归下载  </li>\n<li><p><strong>ps</strong><br>查看系统中的进程状态，格式为<br>ps 参数<br>-a : 显示所有进程<br>-u : 用户以及其他详细信息<br>-x : 显示没有控制终端的进程<br>5种常见的进程状态:<br>R 运行<br>S 中断<br>D 不可中断<br>Z 僵死<br>T 停止  </p>\n</li>\n<li><p><strong>top</strong><br>动态地监控进程活动与系统负载等信息–强化版任务管理器  </p>\n</li>\n<li><p><strong>pidof</strong><br>查询某个指定服务进程的PID值<br>pifof 参数 服务名称  </p>\n</li>\n<li><p><strong>kill</strong><br>终止某个指定PID的服务进程<br>kill 参数 进程PID  </p>\n</li>\n<li><p><strong>killall</strong><br>终止某个指定名称的服务所对应的全部进程<br>killall 参数 进程名称  </p>\n</li>\n</ul>\n<h2 id=\"系统状态检测命令\"><a href=\"#系统状态检测命令\" class=\"headerlink\" title=\"系统状态检测命令\"></a>系统状态检测命令</h2><ul>\n<li><p><strong>ifconfig</strong><br>获取网卡配置与网络状态等信息<br>ifconfig 网络设备 参数  </p>\n</li>\n<li><p><strong>usame</strong><br>查看系统内核与系统版本等信息<br>uname 参数  </p>\n</li>\n<li><p><strong>uptime</strong><br>uptime<br>查看系统的负载信息  </p>\n</li>\n<li><p><strong>free</strong><br>显示当前系统中内存的使用量信息<br>free 参数  </p>\n</li>\n<li><p><strong>who</strong><br>查看当前登入主机的用户终端信息<br>who 参数  </p>\n</li>\n<li><p><strong>last</strong><br>查看所有系统的登录记录<br>last 参数  </p>\n</li>\n<li><p><strong>history</strong><br>显示历史执行过的命令<br>history 参数  </p>\n</li>\n<li><p><strong>sosreport</strong><br>收集系统配置及架构信息并输出诊断文档  </p>\n</li>\n</ul>\n<h3 id=\"工作目录切换命令\"><a href=\"#工作目录切换命令\" class=\"headerlink\" title=\"工作目录切换命令\"></a>工作目录切换命令</h3><ul>\n<li><p><strong>pwd</strong><br>显示用户当前所在工作目录<br>pwd 选项  </p>\n</li>\n<li><p><strong>cd</strong><br>切换工作路径<br>cd 目录名称<br>cd ~    回到home目录<br>cd /    回到根目录下<br>cd ..   返回上一级目录  </p>\n</li>\n<li><p><strong>ls</strong><br>显示目录中的文件信息<br>ls 选项 文件  </p>\n</li>\n</ul>\n<h2 id=\"文本文件编辑命令\"><a href=\"#文本文件编辑命令\" class=\"headerlink\" title=\"文本文件编辑命令\"></a>文本文件编辑命令</h2><ul>\n<li><p><strong>cat</strong><br>查看内容较少的纯文本文件<br>cat 选项 文件  </p>\n</li>\n<li><p><strong>more</strong><br>查看内容较多的纯文本文件</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>忘记了就进来看看</p>","more":"<h1 id=\"常用系统工作命令\"><a href=\"#常用系统工作命令\" class=\"headerlink\" title=\"常用系统工作命令\"></a>常用系统工作命令</h1><ul>\n<li><strong>echo命令</strong>  </li>\n</ul>\n<p>输出字符串或变量提取后的值，常用格式如下:<br>echo 字符串 : 输出字符串在终端屏幕上<br>echo $变量 : 输出变量提取过后的值  </p>\n<ul>\n<li><strong>date</strong><br>显示及设置系统的时间或日期,常用格式如下:<br>date : 默认格式查看系统时间<br>date -d 字符串 : 给出字符串描述的时间，如date -d “2019-9-9” +参数<br>参数(作用) : date –help 帮助信息  </li>\n<li><strong>reboot</strong><br>重启系统，使用管理权限<br>sudo reboot : 管理员权限重启系统   </li>\n<li><strong>poweroff</strong><br>关闭系统，使用管理员权限<br>sudo poweroff : 管理员权限关闭系统  </li>\n<li><strong>wget</strong><br>在终端中下载网络文件，格式为<br>wget 参数 下载地址<br>-b : 后台下载模式<br>-p : 下载到制定目录<br>-t : 最大尝试次数<br>-c : 断电续传<br>-p : 下载页面内所有资源，包括图片，视频等<br>-r : 递归下载  </li>\n<li><p><strong>ps</strong><br>查看系统中的进程状态，格式为<br>ps 参数<br>-a : 显示所有进程<br>-u : 用户以及其他详细信息<br>-x : 显示没有控制终端的进程<br>5种常见的进程状态:<br>R 运行<br>S 中断<br>D 不可中断<br>Z 僵死<br>T 停止  </p>\n</li>\n<li><p><strong>top</strong><br>动态地监控进程活动与系统负载等信息–强化版任务管理器  </p>\n</li>\n<li><p><strong>pidof</strong><br>查询某个指定服务进程的PID值<br>pifof 参数 服务名称  </p>\n</li>\n<li><p><strong>kill</strong><br>终止某个指定PID的服务进程<br>kill 参数 进程PID  </p>\n</li>\n<li><p><strong>killall</strong><br>终止某个指定名称的服务所对应的全部进程<br>killall 参数 进程名称  </p>\n</li>\n</ul>\n<h2 id=\"系统状态检测命令\"><a href=\"#系统状态检测命令\" class=\"headerlink\" title=\"系统状态检测命令\"></a>系统状态检测命令</h2><ul>\n<li><p><strong>ifconfig</strong><br>获取网卡配置与网络状态等信息<br>ifconfig 网络设备 参数  </p>\n</li>\n<li><p><strong>usame</strong><br>查看系统内核与系统版本等信息<br>uname 参数  </p>\n</li>\n<li><p><strong>uptime</strong><br>uptime<br>查看系统的负载信息  </p>\n</li>\n<li><p><strong>free</strong><br>显示当前系统中内存的使用量信息<br>free 参数  </p>\n</li>\n<li><p><strong>who</strong><br>查看当前登入主机的用户终端信息<br>who 参数  </p>\n</li>\n<li><p><strong>last</strong><br>查看所有系统的登录记录<br>last 参数  </p>\n</li>\n<li><p><strong>history</strong><br>显示历史执行过的命令<br>history 参数  </p>\n</li>\n<li><p><strong>sosreport</strong><br>收集系统配置及架构信息并输出诊断文档  </p>\n</li>\n</ul>\n<h3 id=\"工作目录切换命令\"><a href=\"#工作目录切换命令\" class=\"headerlink\" title=\"工作目录切换命令\"></a>工作目录切换命令</h3><ul>\n<li><p><strong>pwd</strong><br>显示用户当前所在工作目录<br>pwd 选项  </p>\n</li>\n<li><p><strong>cd</strong><br>切换工作路径<br>cd 目录名称<br>cd ~    回到home目录<br>cd /    回到根目录下<br>cd ..   返回上一级目录  </p>\n</li>\n<li><p><strong>ls</strong><br>显示目录中的文件信息<br>ls 选项 文件  </p>\n</li>\n</ul>\n<h2 id=\"文本文件编辑命令\"><a href=\"#文本文件编辑命令\" class=\"headerlink\" title=\"文本文件编辑命令\"></a>文本文件编辑命令</h2><ul>\n<li><p><strong>cat</strong><br>查看内容较少的纯文本文件<br>cat 选项 文件  </p>\n</li>\n<li><p><strong>more</strong><br>查看内容较多的纯文本文件</p>\n</li>\n</ul>"},{"layout":"n","title":"shell快捷键大全","date":"2019-05-09T14:48:26.000Z","_content":"","source":"_posts/shell快捷键大全.md","raw":"---\nlayout: 'n'\ntitle: shell快捷键大全\ndate: 2019-05-09 22:48:26\ntags:\n---\n","slug":"shell快捷键大全","published":1,"updated":"2019-06-01T17:25:48.307Z","comments":1,"photos":[],"link":"","_id":"cjwhso7790009u4imf2ewhne0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"学习面向对象思想的小结","date":"2019-05-22T08:51:47.000Z","_content":"一些小小小小的感悟吧！ \n<!--more-->\n# 面向对象以前：\n\n在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。\n\n在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！\n\n##面向对象\n\n面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。\n\n结语：刚踏入的小萌新，多多指教。\n\n","source":"_posts/学习面向对象思想的小结.md","raw":"---\ntitle: 学习面向对象思想的小结\ndate: 2019-05-22 16:51:47\ntags: note\ncategories: C++\n---\n一些小小小小的感悟吧！ \n<!--more-->\n# 面向对象以前：\n\n在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。\n\n在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！\n\n##面向对象\n\n面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。\n\n结语：刚踏入的小萌新，多多指教。\n\n","slug":"学习面向对象思想的小结","published":1,"updated":"2019-06-04T12:14:40.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso77c000cu4im7uecgg18","content":"<p>一些小小小小的感悟吧！<br><a id=\"more\"></a></p>\n<h1 id=\"面向对象以前：\"><a href=\"#面向对象以前：\" class=\"headerlink\" title=\"面向对象以前：\"></a>面向对象以前：</h1><p>在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。</p>\n<p>在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！</p>\n<p>##面向对象</p>\n<p>面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。</p>\n<p>结语：刚踏入的小萌新，多多指教。</p>\n","site":{"data":{}},"excerpt":"<p>一些小小小小的感悟吧！<br></p>","more":"<p></p>\n<h1 id=\"面向对象以前：\"><a href=\"#面向对象以前：\" class=\"headerlink\" title=\"面向对象以前：\"></a>面向对象以前：</h1><p>在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。</p>\n<p>在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！</p>\n<p>##面向对象</p>\n<p>面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。</p>\n<p>结语：刚踏入的小萌新，多多指教。</p>"},{"title":"折腾manjaro的记录(一)","date":"2019-06-02T09:11:17.000Z","_content":"唉，终于还是要用Linux。。。\n<!--more-->\n\n\n","source":"_posts/折腾manjaro的记录-一.md","raw":"---\ntitle: 折腾manjaro的记录(一)\ndate: 2019-06-02 17:11:17\ntags:\n  - note\ncategories: Linux\n---\n唉，终于还是要用Linux。。。\n<!--more-->\n\n\n","slug":"折腾manjaro的记录-一","published":1,"updated":"2019-06-02T12:41:30.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso77f000eu4im5rmoopsp","content":"<p>唉，终于还是要用Linux。。。<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<p>唉，终于还是要用Linux。。。<br></p>","more":"<p></p>"},{"title":"C++ note3","date":"2019-06-04T08:47:12.000Z","_content":"关于面向对象编程的笔记  \n\n<!--more-->  \n\n# **面向对象**  \n---  \n> **new 动态内存分配**  \n```\nint* i = new int;   //类型*变量 = new 类型\nint* ip = new int[5];//分配数组\nint* (*ip)[5] = new int[5][4]   //分配多维数组\ndelete [] ip;   //数组的销毁方式\n/**思考题\n *1、new如何动态分配多维数组？\n    int (*ipp)[4] = new int[5][4];\n *2、分配出来的多维数组如何销毁？\n    delete[] ipp;\n **/\ndelete i;   //销毁地址\n```\n>  常见错误\n- 忘记销毁new出来的地址，会造成内存泄露  \n- 多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  \n```\nif(ip){\n    delete ip;\n    ip = 0;\n}\n```\n- 销毁一段非new分配的内存  \n- 使用被delete的内存  \n- 务必要记住，new和delete必须要成对使用  \n- new的对象不要盲目使用自增运算符  \n- 取值运算需要加上取值操作符\\*  \n---\n>  **默认参数**  \n- C++函数中可以带有默认参数  \n```\ndouble Add(int num1,int num2 = 0){\n    return num1 + num2;\n}\n· 所有参数都可以具有默认参数\n· 默认参数必须从最右边开始\n· 不可以使用形参作为默认参数\n· 一般来说，默认参数一般使用在函数参数很多的情况下，\n它避免了函数调用者必须记住太多太长的参数\n```\n>  **可变参数**  \n- C\\++提供一种“可变参数”的机制，即允许参数的数目是可变的。  \n```\n/* 要定义一个支持可变参数的函数，需要用到头文件<cstd\narg>中的一些东西 */\n#include <iostream>\n#include <cstdarg>\nusing namespace std;\nint Add(int first...);\n\nint main() {\n\tint sum = Add(11, 22, 33, -1);\n}\nint Add(int first...) {\n\t//准备读取可变参数\n\tva_list nums;\n\tva_start(nums, first);   \n\t//使用<cstdarg>中的va_xxx宏函数处理可变参数\n\tint sum = 0;\n\tint num = first;\n\t//依次读取参数，-1表示结束\n\twhile (num != -1) {\n\t\tcout << \"+\" << num << endl;\n\t\tsum += num;\n\t\tnum = va_arg(nums, int);\n\t}\n\tva_end(nums);\n\treturn sum;\n}\n------------\n以上主要思想是使用va_xxx读取参数列表，并进行加和。遇\n到-1结束，可变参数处理起来比较麻烦。\n```\n>  **内联函数**  \n- 在进行函数调用前，会将调用函数的地址和参数列表等信息\n保留在堆栈中，以便在函数执行结束后，可以返回到原先调\n用的程序继续执行。因此对于某些频繁调用的小型函数来说\n，这些堆栈存取动作，会降低的程序的执行效率，此时即可\n使用内敛函数解决问题。  \n内联函数允许函数内部的内容正在调用点直接展开，这样就\n避免了传统调用函数过程带来的性能损失。\n```\ninline int add(int,int);\nvoid add(int a,int b){\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n}\nint main(){\n    add(1,2);\n    /*编译器会改写成*/\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n    ----------\n    实际上，inline只是对编译器进行优化的一个建议，\n    编译器完全可能会不理会该建议，所以，不要滥用inl\n    ine函数\n}\n```\n>  **函数重载**  \n- 函数名相同，参数列表不同，就是函数的重载特性\n```\n函数重载经常出现的错误示例：\nint add(int a){\n    return a；\n}\nfloat add(int a){\n    return a\n}\n//不能依赖于返回值的类型不同选定一个函数\n//实参与形参类型不同\n//不要认为的制造二义性冲突，例如\nint add(int a){\n    return a;\n}\nint add(int a,int b = 10){\n    return a + b; \n}\n```\n- 安全连接和名字重组自行百度了解  \n> **递归函数**  \n- 函数自己调用自己，即递归函数\n```\n#include <iostream>\nusing namespace std;\n\nvoid test(int);\n\nint main() {\n\ttest(10);\n}\nvoid test(int num1) {\n\tcout << \"函数开始\" << endl;\n\tif (num1 == 0) return;\n\ttest(num1 / 2);\n\tcout << \"函数结束\" << endl;\n}\n输出结果如下:\n函数开始\n函数开始\n函数开始\n函数开始\n函数开始\n函数结束\n函数结束--gg\n函数结束\n函数结束\n--------------\n个人是这样理解的,递归就是一个函数嵌套的过程，像上面\n的程序有五个函数开始，这是在执行递归之前的语句，也\n就是说算上第一次进入函数，这个函数执行了五次，但对\n应的函数结束却只出现了四次，那是因为最后一次执行了 \nreturn语句，直接跳出了函数，也就没有后面的语句的执\n行。结合理解使用调试功能进行观察效果会更好。\n```\n\n> **函数指针**  \n- 在C++中提供函数指针，它用以指向一个函数  \n\n```\nvoid (*fp)();   //声明一个类型为void，没有参数的函数指针\nfp = &add;  //指向add函数的地址\nfp = add    //等同与指向\n//调用的方法\nfp();       //相当于add()\n(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用\n\n```\n\n- 理解函数指针\n\n```\n#include <iostream>\nusing namespace std;\n\nint add(int a ,int b) {\n\treturn a + b;\n}\nint min(int a, int b);\nint main() {\n\tvoid (*fp1)(int);\n\tint (*fp2)(int, int);\n\tcout << typeid(fp1).name() << endl;\n\tcout << typeid(fp2).name() << endl;\n\tcout << typeid(add).name() << endl;\n\tcout << typeid(min).name() << endl;\n}\nint min(int a, int b) {\n\treturn a - b;\n}\n------------\n利用typeid输出函数指针类型来理解它\n根据这样的特性，我们可以定义函数指针数字组\nint (*fp[])(int ,int ) = {&add,&min}\n函数指针的定义有点繁琐，建议用typedef来改善可读性。\ntypedef int (*fp)(int,int);\nfp fp1 = add;\nfp fp2 = &min;\nfp fp3[] = {&add,&min};\n```\n\n- 函数与值传递  \n\n```\n·值传递有三种方式：传值方式，引用方式，传址方式\n\n·向函数传递参数的时候，除了引用方式外，其他方式都是\n在函数内部将参数内容复制一份使用。\n```\n> **类的设计**\n- 类是对象的类型，对象是类的实例  \n- 类的设计  \n\n```\n· 类的语法定义：\nclass 类名{\n访问控制符:\n    成员列表\n};\n· 类也可以先声明后定义，声明方式如下\nclass 类名;\n· 对象的定义\n类名 对象名;\n类名 * 对象名 = new 类名();\n//类的两种实例化方法\n还可以定义类对象的指针和引用\n类名 * 指针名 = &对象名;\n类名 & 引用名 = 对象名;\n· 数据成员的访问\n可以使用\".\"来访问数据成员\n对象指针用\"->\"来访问\n还支持用\"::\"域名操作符访问成员，但常用以上两种\n· 成员访问控制\n访问控制符一般包括两种\npublic:共有的，可以在任意地方访问成员\nprivate:私有的，只能在类的内部访问成员\n有一种不成文的规矩，就是把私有的数据成员加上下划线\n· 成员函数\n成员函数其实与普通的函数没有太大的差别，它可以被内\n联，也可以被重载，也可以使用默认参数，唯一的区别就\n是定义是要加上类域的帽子，但声明不需要，如\nclass A{\n    void a();\n};\nvoid A :: a(){  //数据类型 所属类名 :: 函数名\n    cout << \"我属于A类\" << endl;\n}\n· this指针\n在成员函数体内，有一种特殊的指针，this指针。this指\n针指向当前类对象本身，可以用this调用对象的成员：\nthis -> a();\n注意:this不能被改变，也不能在类作用域以外的地方使用\n· 内存中的类\n类包括数据成员和成员函数，但内存中的类只包括其数据\n成员，成员函数其实并不属于对象，它只是一个特殊的全\n局函数。\n· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\n\tint a;\n\tint b;\n\tchar c;\n\tchar d;\n};\nclass B {\npublic:\n\tint a;\n\tchar c;\n\tint b;\n\tchar d;\n};\nint main() {\n\tcout << sizeof(A) << endl;\n\tcout << sizeof(B) << endl;\n}\n输出如下：\n12\n16\n为了程序运行的效率，编译器在一定的设置下可能对成员\n排放位置做一些调整，使得整个结构体为一个字节长的整\n数倍，这就是所谓的“字节对齐”，上面演示了这种布局的\n差异，可以看出来，，不同的排列方式会引起类字节长度\n的差别，大家写代码一定要考虑这一点。\n```\n\n- UML类图可以表示一个类，便于理解，如  \n- 私有是\"-\"前缀，共有则是\"+\"前缀  \n\n|类名|  \n|:-:|\n|数据成员|\n|函数成员|\n\n\n\n\n\n>  **类的讨论**  \n\n```\n· 类与结构\nC++中提供结构和类。在数据成员上，它们唯一的差别在于\n：结构成员的默认访问控制为public，类的默认访问控制\n为private。\nclass是一个全新的概念，所以人们更愿意接受class是真\n正的面向对象概念。而对于struct，人们更愿意用来描述\n那些没有行为或者行为能力很弱的数据结构体。\n· 抽象性\n在软件开发的分析、设计时对具体问题进行归纳、概括，\n并将这一类对象的公共特性加以条理化和严格描述，它主\n张集中思想和精力，考虑关键、主要、实质性的问题，去\n掉非主要的部分，便于开发人员对整个问题准确地认识。\n为具体的对象定义一个类的过程就是抽象。\n· 封装性\n保证程序员用正确的方式操作对象，并将一些操作细节隐\n藏起来。主要体现如下方面:\n--- 保护私有数据:不允许外部程序直接访问私有的数据\n--- 隐藏了操作细节:提供公用成员函数提供外部调用\n根据这两个方面,我们可以举一个例子来说明:\n#include <iostream>\nusing namespace std;\nclass A {\n\t/**\n\t *声明一个A类，包含两个数据成员并封装成4个成员函数\n\t *这里使用this指针加深印象\n\t **/\n\tstring _name;\n\tstring _sex;\npublic:\n\tvoid setname(string name) { \n\t\tthis ->_name = name; \n\t}\n\tvoid setsex(string sex) { \n\t\tthis->_sex = sex;\n\t}\n\tstring getname() { return this ->_name; }\n\tstring getsex() { return this ->_sex; }\n};\nint main() {\n\t/**\n\t *使用指针的方法实例化A的一个对象\n\t *定义两个string临时变量\n\t *调用公共的数据成员封装函数进行赋值和输出\n\t **/\n\tA * a1 = new A();\n\tstring temp1,temp2;\n\tcout << \"请输入你的姓名\";\n\tcin >> temp1;\n\ta1->setname(temp1);\n\tcout << \"请输入你的性别\";\n\tcin >> temp2;\n\ta1->setsex(temp2);\n\tcout << \"姓名:\" << a1->getname() << endl;\n\tcout << \"性别:\" << a1->getsex() << endl;\n}\n程序员的责任就是封装复杂的数据和操作，以简单明了的\n共有函数的方式为外部程序提供对象操作接口\n```\n    ","source":"_posts/C++ note3.md","raw":"---\ntitle: C++ note3\ndate: 2019-06-04 16:47:12\ntags: note\ncategories: C++\n---\n关于面向对象编程的笔记  \n\n<!--more-->  \n\n# **面向对象**  \n---  \n> **new 动态内存分配**  \n```\nint* i = new int;   //类型*变量 = new 类型\nint* ip = new int[5];//分配数组\nint* (*ip)[5] = new int[5][4]   //分配多维数组\ndelete [] ip;   //数组的销毁方式\n/**思考题\n *1、new如何动态分配多维数组？\n    int (*ipp)[4] = new int[5][4];\n *2、分配出来的多维数组如何销毁？\n    delete[] ipp;\n **/\ndelete i;   //销毁地址\n```\n>  常见错误\n- 忘记销毁new出来的地址，会造成内存泄露  \n- 多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  \n```\nif(ip){\n    delete ip;\n    ip = 0;\n}\n```\n- 销毁一段非new分配的内存  \n- 使用被delete的内存  \n- 务必要记住，new和delete必须要成对使用  \n- new的对象不要盲目使用自增运算符  \n- 取值运算需要加上取值操作符\\*  \n---\n>  **默认参数**  \n- C++函数中可以带有默认参数  \n```\ndouble Add(int num1,int num2 = 0){\n    return num1 + num2;\n}\n· 所有参数都可以具有默认参数\n· 默认参数必须从最右边开始\n· 不可以使用形参作为默认参数\n· 一般来说，默认参数一般使用在函数参数很多的情况下，\n它避免了函数调用者必须记住太多太长的参数\n```\n>  **可变参数**  \n- C\\++提供一种“可变参数”的机制，即允许参数的数目是可变的。  \n```\n/* 要定义一个支持可变参数的函数，需要用到头文件<cstd\narg>中的一些东西 */\n#include <iostream>\n#include <cstdarg>\nusing namespace std;\nint Add(int first...);\n\nint main() {\n\tint sum = Add(11, 22, 33, -1);\n}\nint Add(int first...) {\n\t//准备读取可变参数\n\tva_list nums;\n\tva_start(nums, first);   \n\t//使用<cstdarg>中的va_xxx宏函数处理可变参数\n\tint sum = 0;\n\tint num = first;\n\t//依次读取参数，-1表示结束\n\twhile (num != -1) {\n\t\tcout << \"+\" << num << endl;\n\t\tsum += num;\n\t\tnum = va_arg(nums, int);\n\t}\n\tva_end(nums);\n\treturn sum;\n}\n------------\n以上主要思想是使用va_xxx读取参数列表，并进行加和。遇\n到-1结束，可变参数处理起来比较麻烦。\n```\n>  **内联函数**  \n- 在进行函数调用前，会将调用函数的地址和参数列表等信息\n保留在堆栈中，以便在函数执行结束后，可以返回到原先调\n用的程序继续执行。因此对于某些频繁调用的小型函数来说\n，这些堆栈存取动作，会降低的程序的执行效率，此时即可\n使用内敛函数解决问题。  \n内联函数允许函数内部的内容正在调用点直接展开，这样就\n避免了传统调用函数过程带来的性能损失。\n```\ninline int add(int,int);\nvoid add(int a,int b){\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n}\nint main(){\n    add(1,2);\n    /*编译器会改写成*/\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n    ----------\n    实际上，inline只是对编译器进行优化的一个建议，\n    编译器完全可能会不理会该建议，所以，不要滥用inl\n    ine函数\n}\n```\n>  **函数重载**  \n- 函数名相同，参数列表不同，就是函数的重载特性\n```\n函数重载经常出现的错误示例：\nint add(int a){\n    return a；\n}\nfloat add(int a){\n    return a\n}\n//不能依赖于返回值的类型不同选定一个函数\n//实参与形参类型不同\n//不要认为的制造二义性冲突，例如\nint add(int a){\n    return a;\n}\nint add(int a,int b = 10){\n    return a + b; \n}\n```\n- 安全连接和名字重组自行百度了解  \n> **递归函数**  \n- 函数自己调用自己，即递归函数\n```\n#include <iostream>\nusing namespace std;\n\nvoid test(int);\n\nint main() {\n\ttest(10);\n}\nvoid test(int num1) {\n\tcout << \"函数开始\" << endl;\n\tif (num1 == 0) return;\n\ttest(num1 / 2);\n\tcout << \"函数结束\" << endl;\n}\n输出结果如下:\n函数开始\n函数开始\n函数开始\n函数开始\n函数开始\n函数结束\n函数结束--gg\n函数结束\n函数结束\n--------------\n个人是这样理解的,递归就是一个函数嵌套的过程，像上面\n的程序有五个函数开始，这是在执行递归之前的语句，也\n就是说算上第一次进入函数，这个函数执行了五次，但对\n应的函数结束却只出现了四次，那是因为最后一次执行了 \nreturn语句，直接跳出了函数，也就没有后面的语句的执\n行。结合理解使用调试功能进行观察效果会更好。\n```\n\n> **函数指针**  \n- 在C++中提供函数指针，它用以指向一个函数  \n\n```\nvoid (*fp)();   //声明一个类型为void，没有参数的函数指针\nfp = &add;  //指向add函数的地址\nfp = add    //等同与指向\n//调用的方法\nfp();       //相当于add()\n(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用\n\n```\n\n- 理解函数指针\n\n```\n#include <iostream>\nusing namespace std;\n\nint add(int a ,int b) {\n\treturn a + b;\n}\nint min(int a, int b);\nint main() {\n\tvoid (*fp1)(int);\n\tint (*fp2)(int, int);\n\tcout << typeid(fp1).name() << endl;\n\tcout << typeid(fp2).name() << endl;\n\tcout << typeid(add).name() << endl;\n\tcout << typeid(min).name() << endl;\n}\nint min(int a, int b) {\n\treturn a - b;\n}\n------------\n利用typeid输出函数指针类型来理解它\n根据这样的特性，我们可以定义函数指针数字组\nint (*fp[])(int ,int ) = {&add,&min}\n函数指针的定义有点繁琐，建议用typedef来改善可读性。\ntypedef int (*fp)(int,int);\nfp fp1 = add;\nfp fp2 = &min;\nfp fp3[] = {&add,&min};\n```\n\n- 函数与值传递  \n\n```\n·值传递有三种方式：传值方式，引用方式，传址方式\n\n·向函数传递参数的时候，除了引用方式外，其他方式都是\n在函数内部将参数内容复制一份使用。\n```\n> **类的设计**\n- 类是对象的类型，对象是类的实例  \n- 类的设计  \n\n```\n· 类的语法定义：\nclass 类名{\n访问控制符:\n    成员列表\n};\n· 类也可以先声明后定义，声明方式如下\nclass 类名;\n· 对象的定义\n类名 对象名;\n类名 * 对象名 = new 类名();\n//类的两种实例化方法\n还可以定义类对象的指针和引用\n类名 * 指针名 = &对象名;\n类名 & 引用名 = 对象名;\n· 数据成员的访问\n可以使用\".\"来访问数据成员\n对象指针用\"->\"来访问\n还支持用\"::\"域名操作符访问成员，但常用以上两种\n· 成员访问控制\n访问控制符一般包括两种\npublic:共有的，可以在任意地方访问成员\nprivate:私有的，只能在类的内部访问成员\n有一种不成文的规矩，就是把私有的数据成员加上下划线\n· 成员函数\n成员函数其实与普通的函数没有太大的差别，它可以被内\n联，也可以被重载，也可以使用默认参数，唯一的区别就\n是定义是要加上类域的帽子，但声明不需要，如\nclass A{\n    void a();\n};\nvoid A :: a(){  //数据类型 所属类名 :: 函数名\n    cout << \"我属于A类\" << endl;\n}\n· this指针\n在成员函数体内，有一种特殊的指针，this指针。this指\n针指向当前类对象本身，可以用this调用对象的成员：\nthis -> a();\n注意:this不能被改变，也不能在类作用域以外的地方使用\n· 内存中的类\n类包括数据成员和成员函数，但内存中的类只包括其数据\n成员，成员函数其实并不属于对象，它只是一个特殊的全\n局函数。\n· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\n\tint a;\n\tint b;\n\tchar c;\n\tchar d;\n};\nclass B {\npublic:\n\tint a;\n\tchar c;\n\tint b;\n\tchar d;\n};\nint main() {\n\tcout << sizeof(A) << endl;\n\tcout << sizeof(B) << endl;\n}\n输出如下：\n12\n16\n为了程序运行的效率，编译器在一定的设置下可能对成员\n排放位置做一些调整，使得整个结构体为一个字节长的整\n数倍，这就是所谓的“字节对齐”，上面演示了这种布局的\n差异，可以看出来，，不同的排列方式会引起类字节长度\n的差别，大家写代码一定要考虑这一点。\n```\n\n- UML类图可以表示一个类，便于理解，如  \n- 私有是\"-\"前缀，共有则是\"+\"前缀  \n\n|类名|  \n|:-:|\n|数据成员|\n|函数成员|\n\n\n\n\n\n>  **类的讨论**  \n\n```\n· 类与结构\nC++中提供结构和类。在数据成员上，它们唯一的差别在于\n：结构成员的默认访问控制为public，类的默认访问控制\n为private。\nclass是一个全新的概念，所以人们更愿意接受class是真\n正的面向对象概念。而对于struct，人们更愿意用来描述\n那些没有行为或者行为能力很弱的数据结构体。\n· 抽象性\n在软件开发的分析、设计时对具体问题进行归纳、概括，\n并将这一类对象的公共特性加以条理化和严格描述，它主\n张集中思想和精力，考虑关键、主要、实质性的问题，去\n掉非主要的部分，便于开发人员对整个问题准确地认识。\n为具体的对象定义一个类的过程就是抽象。\n· 封装性\n保证程序员用正确的方式操作对象，并将一些操作细节隐\n藏起来。主要体现如下方面:\n--- 保护私有数据:不允许外部程序直接访问私有的数据\n--- 隐藏了操作细节:提供公用成员函数提供外部调用\n根据这两个方面,我们可以举一个例子来说明:\n#include <iostream>\nusing namespace std;\nclass A {\n\t/**\n\t *声明一个A类，包含两个数据成员并封装成4个成员函数\n\t *这里使用this指针加深印象\n\t **/\n\tstring _name;\n\tstring _sex;\npublic:\n\tvoid setname(string name) { \n\t\tthis ->_name = name; \n\t}\n\tvoid setsex(string sex) { \n\t\tthis->_sex = sex;\n\t}\n\tstring getname() { return this ->_name; }\n\tstring getsex() { return this ->_sex; }\n};\nint main() {\n\t/**\n\t *使用指针的方法实例化A的一个对象\n\t *定义两个string临时变量\n\t *调用公共的数据成员封装函数进行赋值和输出\n\t **/\n\tA * a1 = new A();\n\tstring temp1,temp2;\n\tcout << \"请输入你的姓名\";\n\tcin >> temp1;\n\ta1->setname(temp1);\n\tcout << \"请输入你的性别\";\n\tcin >> temp2;\n\ta1->setsex(temp2);\n\tcout << \"姓名:\" << a1->getname() << endl;\n\tcout << \"性别:\" << a1->getsex() << endl;\n}\n程序员的责任就是封装复杂的数据和操作，以简单明了的\n共有函数的方式为外部程序提供对象操作接口\n```\n    ","slug":"C++ note3","published":1,"updated":"2019-06-04T12:43:41.743Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso7d8000ou4imcu4ukkzb","content":"<p>关于面向对象编程的笔记  </p>\n<a id=\"more\"></a>  \n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a><strong>面向对象</strong></h1><hr>\n<blockquote>\n<p><strong>new 动态内存分配</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* i = new int;   //类型*变量 = new 类型</span><br><span class=\"line\">int* ip = new int[5];//分配数组</span><br><span class=\"line\">int* (*ip)[5] = new int[5][4]   //分配多维数组</span><br><span class=\"line\">delete [] ip;   //数组的销毁方式</span><br><span class=\"line\">/**思考题</span><br><span class=\"line\"> *1、new如何动态分配多维数组？</span><br><span class=\"line\">    int (*ipp)[4] = new int[5][4];</span><br><span class=\"line\"> *2、分配出来的多维数组如何销毁？</span><br><span class=\"line\">    delete[] ipp;</span><br><span class=\"line\"> **/</span><br><span class=\"line\">delete i;   //销毁地址</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p> 常见错误</p>\n<ul>\n<li>忘记销毁new出来的地址，会造成内存泄露  </li>\n<li>多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(ip)&#123;</span><br><span class=\"line\">    delete ip;</span><br><span class=\"line\">    ip = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>销毁一段非new分配的内存  </li>\n<li>使用被delete的内存  </li>\n<li>务必要记住，new和delete必须要成对使用  </li>\n<li>new的对象不要盲目使用自增运算符  </li>\n<li>取值运算需要加上取值操作符*  </li>\n</ul>\n<hr>\n<blockquote>\n<p> <strong>默认参数</strong>  </p>\n<ul>\n<li>C++函数中可以带有默认参数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double Add(int num1,int num2 = 0)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 所有参数都可以具有默认参数</span><br><span class=\"line\">· 默认参数必须从最右边开始</span><br><span class=\"line\">· 不可以使用形参作为默认参数</span><br><span class=\"line\">· 一般来说，默认参数一般使用在函数参数很多的情况下，</span><br><span class=\"line\">它避免了函数调用者必须记住太多太长的参数</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>可变参数</strong>  </p>\n<ul>\n<li>C++提供一种“可变参数”的机制，即允许参数的数目是可变的。  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 要定义一个支持可变参数的函数，需要用到头文件&lt;cstd</span><br><span class=\"line\">arg&gt;中的一些东西 */</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstdarg&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int Add(int first...);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tint sum = Add(11, 22, 33, -1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int Add(int first...) &#123;</span><br><span class=\"line\">\t//准备读取可变参数</span><br><span class=\"line\">\tva_list nums;</span><br><span class=\"line\">\tva_start(nums, first);   </span><br><span class=\"line\">\t//使用&lt;cstdarg&gt;中的va_xxx宏函数处理可变参数</span><br><span class=\"line\">\tint sum = 0;</span><br><span class=\"line\">\tint num = first;</span><br><span class=\"line\">\t//依次读取参数，-1表示结束</span><br><span class=\"line\">\twhile (num != -1) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;+&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\tnum = va_arg(nums, int);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tva_end(nums);</span><br><span class=\"line\">\treturn sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">以上主要思想是使用va_xxx读取参数列表，并进行加和。遇</span><br><span class=\"line\">到-1结束，可变参数处理起来比较麻烦。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>内联函数</strong>  </p>\n<ul>\n<li>在进行函数调用前，会将调用函数的地址和参数列表等信息<br>保留在堆栈中，以便在函数执行结束后，可以返回到原先调<br>用的程序继续执行。因此对于某些频繁调用的小型函数来说<br>，这些堆栈存取动作，会降低的程序的执行效率，此时即可<br>使用内敛函数解决问题。<br>内联函数允许函数内部的内容正在调用点直接展开，这样就<br>避免了传统调用函数过程带来的性能损失。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline int add(int,int);</span><br><span class=\"line\">void add(int a,int b)&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    add(1,2);</span><br><span class=\"line\">    /*编译器会改写成*/</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">    ----------</span><br><span class=\"line\">    实际上，inline只是对编译器进行优化的一个建议，</span><br><span class=\"line\">    编译器完全可能会不理会该建议，所以，不要滥用inl</span><br><span class=\"line\">    ine函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>函数重载</strong>  </p>\n<ul>\n<li>函数名相同，参数列表不同，就是函数的重载特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数重载经常出现的错误示例：</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float add(int a)&#123;</span><br><span class=\"line\">    return a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不能依赖于返回值的类型不同选定一个函数</span><br><span class=\"line\">//实参与形参类型不同</span><br><span class=\"line\">//不要认为的制造二义性冲突，例如</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int add(int a,int b = 10)&#123;</span><br><span class=\"line\">    return a + b; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>安全连接和名字重组自行百度了解  <blockquote>\n<p><strong>递归函数</strong>  </p>\n</blockquote>\n</li>\n<li>函数自己调用自己，即递归函数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">void test(int);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\ttest(10);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test(int num1) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数开始&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tif (num1 == 0) return;</span><br><span class=\"line\">\ttest(num1 / 2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数结束&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果如下:</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束--gg</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">--------------</span><br><span class=\"line\">个人是这样理解的,递归就是一个函数嵌套的过程，像上面</span><br><span class=\"line\">的程序有五个函数开始，这是在执行递归之前的语句，也</span><br><span class=\"line\">就是说算上第一次进入函数，这个函数执行了五次，但对</span><br><span class=\"line\">应的函数结束却只出现了四次，那是因为最后一次执行了 </span><br><span class=\"line\">return语句，直接跳出了函数，也就没有后面的语句的执</span><br><span class=\"line\">行。结合理解使用调试功能进行观察效果会更好。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>函数指针</strong>  </p>\n<ul>\n<li>在C++中提供函数指针，它用以指向一个函数  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void (*fp)();   //声明一个类型为void，没有参数的函数指针</span><br><span class=\"line\">fp = &amp;add;  //指向add函数的地址</span><br><span class=\"line\">fp = add    //等同与指向</span><br><span class=\"line\">//调用的方法</span><br><span class=\"line\">fp();       //相当于add()</span><br><span class=\"line\">(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>理解函数指针</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int add(int a ,int b) &#123;</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b);</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tvoid (*fp1)(int);</span><br><span class=\"line\">\tint (*fp2)(int, int);</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp1).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp2).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(add).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(min).name() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b) &#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">利用typeid输出函数指针类型来理解它</span><br><span class=\"line\">根据这样的特性，我们可以定义函数指针数字组</span><br><span class=\"line\">int (*fp[])(int ,int ) = &#123;&amp;add,&amp;min&#125;</span><br><span class=\"line\">函数指针的定义有点繁琐，建议用typedef来改善可读性。</span><br><span class=\"line\">typedef int (*fp)(int,int);</span><br><span class=\"line\">fp fp1 = add;</span><br><span class=\"line\">fp fp2 = &amp;min;</span><br><span class=\"line\">fp fp3[] = &#123;&amp;add,&amp;min&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数与值传递  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">·值传递有三种方式：传值方式，引用方式，传址方式</span><br><span class=\"line\"></span><br><span class=\"line\">·向函数传递参数的时候，除了引用方式外，其他方式都是</span><br><span class=\"line\">在函数内部将参数内容复制一份使用。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>类的设计</strong></p>\n<ul>\n<li>类是对象的类型，对象是类的实例  </li>\n<li>类的设计  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类的语法定义：</span><br><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">访问控制符:</span><br><span class=\"line\">    成员列表</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">· 类也可以先声明后定义，声明方式如下</span><br><span class=\"line\">class 类名;</span><br><span class=\"line\">· 对象的定义</span><br><span class=\"line\">类名 对象名;</span><br><span class=\"line\">类名 * 对象名 = new 类名();</span><br><span class=\"line\">//类的两种实例化方法</span><br><span class=\"line\">还可以定义类对象的指针和引用</span><br><span class=\"line\">类名 * 指针名 = &amp;对象名;</span><br><span class=\"line\">类名 &amp; 引用名 = 对象名;</span><br><span class=\"line\">· 数据成员的访问</span><br><span class=\"line\">可以使用&quot;.&quot;来访问数据成员</span><br><span class=\"line\">对象指针用&quot;-&gt;&quot;来访问</span><br><span class=\"line\">还支持用&quot;::&quot;域名操作符访问成员，但常用以上两种</span><br><span class=\"line\">· 成员访问控制</span><br><span class=\"line\">访问控制符一般包括两种</span><br><span class=\"line\">public:共有的，可以在任意地方访问成员</span><br><span class=\"line\">private:私有的，只能在类的内部访问成员</span><br><span class=\"line\">有一种不成文的规矩，就是把私有的数据成员加上下划线</span><br><span class=\"line\">· 成员函数</span><br><span class=\"line\">成员函数其实与普通的函数没有太大的差别，它可以被内</span><br><span class=\"line\">联，也可以被重载，也可以使用默认参数，唯一的区别就</span><br><span class=\"line\">是定义是要加上类域的帽子，但声明不需要，如</span><br><span class=\"line\">class A&#123;</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void A :: a()&#123;  //数据类型 所属类名 :: 函数名</span><br><span class=\"line\">    cout &lt;&lt; &quot;我属于A类&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· this指针</span><br><span class=\"line\">在成员函数体内，有一种特殊的指针，this指针。this指</span><br><span class=\"line\">针指向当前类对象本身，可以用this调用对象的成员：</span><br><span class=\"line\">this -&gt; a();</span><br><span class=\"line\">注意:this不能被改变，也不能在类作用域以外的地方使用</span><br><span class=\"line\">· 内存中的类</span><br><span class=\"line\">类包括数据成员和成员函数，但内存中的类只包括其数据</span><br><span class=\"line\">成员，成员函数其实并不属于对象，它只是一个特殊的全</span><br><span class=\"line\">局函数。</span><br><span class=\"line\">· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class B &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出如下：</span><br><span class=\"line\">12</span><br><span class=\"line\">16</span><br><span class=\"line\">为了程序运行的效率，编译器在一定的设置下可能对成员</span><br><span class=\"line\">排放位置做一些调整，使得整个结构体为一个字节长的整</span><br><span class=\"line\">数倍，这就是所谓的“字节对齐”，上面演示了这种布局的</span><br><span class=\"line\">差异，可以看出来，，不同的排列方式会引起类字节长度</span><br><span class=\"line\">的差别，大家写代码一定要考虑这一点。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>UML类图可以表示一个类，便于理解，如  </li>\n<li>私有是”-“前缀，共有则是”+”前缀  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数据成员</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">函数成员</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p> <strong>类的讨论</strong>  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类与结构</span><br><span class=\"line\">C++中提供结构和类。在数据成员上，它们唯一的差别在于</span><br><span class=\"line\">：结构成员的默认访问控制为public，类的默认访问控制</span><br><span class=\"line\">为private。</span><br><span class=\"line\">class是一个全新的概念，所以人们更愿意接受class是真</span><br><span class=\"line\">正的面向对象概念。而对于struct，人们更愿意用来描述</span><br><span class=\"line\">那些没有行为或者行为能力很弱的数据结构体。</span><br><span class=\"line\">· 抽象性</span><br><span class=\"line\">在软件开发的分析、设计时对具体问题进行归纳、概括，</span><br><span class=\"line\">并将这一类对象的公共特性加以条理化和严格描述，它主</span><br><span class=\"line\">张集中思想和精力，考虑关键、主要、实质性的问题，去</span><br><span class=\"line\">掉非主要的部分，便于开发人员对整个问题准确地认识。</span><br><span class=\"line\">为具体的对象定义一个类的过程就是抽象。</span><br><span class=\"line\">· 封装性</span><br><span class=\"line\">保证程序员用正确的方式操作对象，并将一些操作细节隐</span><br><span class=\"line\">藏起来。主要体现如下方面:</span><br><span class=\"line\">--- 保护私有数据:不允许外部程序直接访问私有的数据</span><br><span class=\"line\">--- 隐藏了操作细节:提供公用成员函数提供外部调用</span><br><span class=\"line\">根据这两个方面,我们可以举一个例子来说明:</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *声明一个A类，包含两个数据成员并封装成4个成员函数</span><br><span class=\"line\">\t *这里使用this指针加深印象</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _sex;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid setname(string name) &#123; </span><br><span class=\"line\">\t\tthis -&gt;_name = name; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setsex(string sex) &#123; </span><br><span class=\"line\">\t\tthis-&gt;_sex = sex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring getname() &#123; return this -&gt;_name; &#125;</span><br><span class=\"line\">\tstring getsex() &#123; return this -&gt;_sex; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *使用指针的方法实例化A的一个对象</span><br><span class=\"line\">\t *定义两个string临时变量</span><br><span class=\"line\">\t *调用公共的数据成员封装函数进行赋值和输出</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tA * a1 = new A();</span><br><span class=\"line\">\tstring temp1,temp2;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的姓名&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp1;</span><br><span class=\"line\">\ta1-&gt;setname(temp1);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的性别&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp2;</span><br><span class=\"line\">\ta1-&gt;setsex(temp2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;姓名:&quot; &lt;&lt; a1-&gt;getname() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;性别:&quot; &lt;&lt; a1-&gt;getsex() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">程序员的责任就是封装复杂的数据和操作，以简单明了的</span><br><span class=\"line\">共有函数的方式为外部程序提供对象操作接口</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>关于面向对象编程的笔记  </p>","more":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a><strong>面向对象</strong></h1><hr>\n<blockquote>\n<p><strong>new 动态内存分配</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* i = new int;   //类型*变量 = new 类型</span><br><span class=\"line\">int* ip = new int[5];//分配数组</span><br><span class=\"line\">int* (*ip)[5] = new int[5][4]   //分配多维数组</span><br><span class=\"line\">delete [] ip;   //数组的销毁方式</span><br><span class=\"line\">/**思考题</span><br><span class=\"line\"> *1、new如何动态分配多维数组？</span><br><span class=\"line\">    int (*ipp)[4] = new int[5][4];</span><br><span class=\"line\"> *2、分配出来的多维数组如何销毁？</span><br><span class=\"line\">    delete[] ipp;</span><br><span class=\"line\"> **/</span><br><span class=\"line\">delete i;   //销毁地址</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p> 常见错误</p>\n<ul>\n<li>忘记销毁new出来的地址，会造成内存泄露  </li>\n<li>多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(ip)&#123;</span><br><span class=\"line\">    delete ip;</span><br><span class=\"line\">    ip = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>销毁一段非new分配的内存  </li>\n<li>使用被delete的内存  </li>\n<li>务必要记住，new和delete必须要成对使用  </li>\n<li>new的对象不要盲目使用自增运算符  </li>\n<li>取值运算需要加上取值操作符*  </li>\n</ul>\n<hr>\n<blockquote>\n<p> <strong>默认参数</strong>  </p>\n<ul>\n<li>C++函数中可以带有默认参数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double Add(int num1,int num2 = 0)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 所有参数都可以具有默认参数</span><br><span class=\"line\">· 默认参数必须从最右边开始</span><br><span class=\"line\">· 不可以使用形参作为默认参数</span><br><span class=\"line\">· 一般来说，默认参数一般使用在函数参数很多的情况下，</span><br><span class=\"line\">它避免了函数调用者必须记住太多太长的参数</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>可变参数</strong>  </p>\n<ul>\n<li>C++提供一种“可变参数”的机制，即允许参数的数目是可变的。  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 要定义一个支持可变参数的函数，需要用到头文件&lt;cstd</span><br><span class=\"line\">arg&gt;中的一些东西 */</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstdarg&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int Add(int first...);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tint sum = Add(11, 22, 33, -1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int Add(int first...) &#123;</span><br><span class=\"line\">\t//准备读取可变参数</span><br><span class=\"line\">\tva_list nums;</span><br><span class=\"line\">\tva_start(nums, first);   </span><br><span class=\"line\">\t//使用&lt;cstdarg&gt;中的va_xxx宏函数处理可变参数</span><br><span class=\"line\">\tint sum = 0;</span><br><span class=\"line\">\tint num = first;</span><br><span class=\"line\">\t//依次读取参数，-1表示结束</span><br><span class=\"line\">\twhile (num != -1) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;+&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\tnum = va_arg(nums, int);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tva_end(nums);</span><br><span class=\"line\">\treturn sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">以上主要思想是使用va_xxx读取参数列表，并进行加和。遇</span><br><span class=\"line\">到-1结束，可变参数处理起来比较麻烦。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>内联函数</strong>  </p>\n<ul>\n<li>在进行函数调用前，会将调用函数的地址和参数列表等信息<br>保留在堆栈中，以便在函数执行结束后，可以返回到原先调<br>用的程序继续执行。因此对于某些频繁调用的小型函数来说<br>，这些堆栈存取动作，会降低的程序的执行效率，此时即可<br>使用内敛函数解决问题。<br>内联函数允许函数内部的内容正在调用点直接展开，这样就<br>避免了传统调用函数过程带来的性能损失。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline int add(int,int);</span><br><span class=\"line\">void add(int a,int b)&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    add(1,2);</span><br><span class=\"line\">    /*编译器会改写成*/</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">    ----------</span><br><span class=\"line\">    实际上，inline只是对编译器进行优化的一个建议，</span><br><span class=\"line\">    编译器完全可能会不理会该建议，所以，不要滥用inl</span><br><span class=\"line\">    ine函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>函数重载</strong>  </p>\n<ul>\n<li>函数名相同，参数列表不同，就是函数的重载特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数重载经常出现的错误示例：</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float add(int a)&#123;</span><br><span class=\"line\">    return a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不能依赖于返回值的类型不同选定一个函数</span><br><span class=\"line\">//实参与形参类型不同</span><br><span class=\"line\">//不要认为的制造二义性冲突，例如</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int add(int a,int b = 10)&#123;</span><br><span class=\"line\">    return a + b; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>安全连接和名字重组自行百度了解  <blockquote>\n<p><strong>递归函数</strong>  </p>\n</blockquote>\n</li>\n<li>函数自己调用自己，即递归函数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">void test(int);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\ttest(10);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test(int num1) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数开始&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tif (num1 == 0) return;</span><br><span class=\"line\">\ttest(num1 / 2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数结束&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果如下:</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束--gg</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">--------------</span><br><span class=\"line\">个人是这样理解的,递归就是一个函数嵌套的过程，像上面</span><br><span class=\"line\">的程序有五个函数开始，这是在执行递归之前的语句，也</span><br><span class=\"line\">就是说算上第一次进入函数，这个函数执行了五次，但对</span><br><span class=\"line\">应的函数结束却只出现了四次，那是因为最后一次执行了 </span><br><span class=\"line\">return语句，直接跳出了函数，也就没有后面的语句的执</span><br><span class=\"line\">行。结合理解使用调试功能进行观察效果会更好。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n<p><strong>函数指针</strong>  </p>\n<ul>\n<li>在C++中提供函数指针，它用以指向一个函数  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void (*fp)();   //声明一个类型为void，没有参数的函数指针</span><br><span class=\"line\">fp = &amp;add;  //指向add函数的地址</span><br><span class=\"line\">fp = add    //等同与指向</span><br><span class=\"line\">//调用的方法</span><br><span class=\"line\">fp();       //相当于add()</span><br><span class=\"line\">(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>理解函数指针</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int add(int a ,int b) &#123;</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b);</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tvoid (*fp1)(int);</span><br><span class=\"line\">\tint (*fp2)(int, int);</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp1).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp2).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(add).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(min).name() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b) &#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">利用typeid输出函数指针类型来理解它</span><br><span class=\"line\">根据这样的特性，我们可以定义函数指针数字组</span><br><span class=\"line\">int (*fp[])(int ,int ) = &#123;&amp;add,&amp;min&#125;</span><br><span class=\"line\">函数指针的定义有点繁琐，建议用typedef来改善可读性。</span><br><span class=\"line\">typedef int (*fp)(int,int);</span><br><span class=\"line\">fp fp1 = add;</span><br><span class=\"line\">fp fp2 = &amp;min;</span><br><span class=\"line\">fp fp3[] = &#123;&amp;add,&amp;min&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数与值传递  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">·值传递有三种方式：传值方式，引用方式，传址方式</span><br><span class=\"line\"></span><br><span class=\"line\">·向函数传递参数的时候，除了引用方式外，其他方式都是</span><br><span class=\"line\">在函数内部将参数内容复制一份使用。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>类的设计</strong></p>\n<ul>\n<li>类是对象的类型，对象是类的实例  </li>\n<li>类的设计  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类的语法定义：</span><br><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">访问控制符:</span><br><span class=\"line\">    成员列表</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">· 类也可以先声明后定义，声明方式如下</span><br><span class=\"line\">class 类名;</span><br><span class=\"line\">· 对象的定义</span><br><span class=\"line\">类名 对象名;</span><br><span class=\"line\">类名 * 对象名 = new 类名();</span><br><span class=\"line\">//类的两种实例化方法</span><br><span class=\"line\">还可以定义类对象的指针和引用</span><br><span class=\"line\">类名 * 指针名 = &amp;对象名;</span><br><span class=\"line\">类名 &amp; 引用名 = 对象名;</span><br><span class=\"line\">· 数据成员的访问</span><br><span class=\"line\">可以使用&quot;.&quot;来访问数据成员</span><br><span class=\"line\">对象指针用&quot;-&gt;&quot;来访问</span><br><span class=\"line\">还支持用&quot;::&quot;域名操作符访问成员，但常用以上两种</span><br><span class=\"line\">· 成员访问控制</span><br><span class=\"line\">访问控制符一般包括两种</span><br><span class=\"line\">public:共有的，可以在任意地方访问成员</span><br><span class=\"line\">private:私有的，只能在类的内部访问成员</span><br><span class=\"line\">有一种不成文的规矩，就是把私有的数据成员加上下划线</span><br><span class=\"line\">· 成员函数</span><br><span class=\"line\">成员函数其实与普通的函数没有太大的差别，它可以被内</span><br><span class=\"line\">联，也可以被重载，也可以使用默认参数，唯一的区别就</span><br><span class=\"line\">是定义是要加上类域的帽子，但声明不需要，如</span><br><span class=\"line\">class A&#123;</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void A :: a()&#123;  //数据类型 所属类名 :: 函数名</span><br><span class=\"line\">    cout &lt;&lt; &quot;我属于A类&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· this指针</span><br><span class=\"line\">在成员函数体内，有一种特殊的指针，this指针。this指</span><br><span class=\"line\">针指向当前类对象本身，可以用this调用对象的成员：</span><br><span class=\"line\">this -&gt; a();</span><br><span class=\"line\">注意:this不能被改变，也不能在类作用域以外的地方使用</span><br><span class=\"line\">· 内存中的类</span><br><span class=\"line\">类包括数据成员和成员函数，但内存中的类只包括其数据</span><br><span class=\"line\">成员，成员函数其实并不属于对象，它只是一个特殊的全</span><br><span class=\"line\">局函数。</span><br><span class=\"line\">· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class B &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出如下：</span><br><span class=\"line\">12</span><br><span class=\"line\">16</span><br><span class=\"line\">为了程序运行的效率，编译器在一定的设置下可能对成员</span><br><span class=\"line\">排放位置做一些调整，使得整个结构体为一个字节长的整</span><br><span class=\"line\">数倍，这就是所谓的“字节对齐”，上面演示了这种布局的</span><br><span class=\"line\">差异，可以看出来，，不同的排列方式会引起类字节长度</span><br><span class=\"line\">的差别，大家写代码一定要考虑这一点。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>UML类图可以表示一个类，便于理解，如  </li>\n<li>私有是”-“前缀，共有则是”+”前缀  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数据成员</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">函数成员</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p> <strong>类的讨论</strong>  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类与结构</span><br><span class=\"line\">C++中提供结构和类。在数据成员上，它们唯一的差别在于</span><br><span class=\"line\">：结构成员的默认访问控制为public，类的默认访问控制</span><br><span class=\"line\">为private。</span><br><span class=\"line\">class是一个全新的概念，所以人们更愿意接受class是真</span><br><span class=\"line\">正的面向对象概念。而对于struct，人们更愿意用来描述</span><br><span class=\"line\">那些没有行为或者行为能力很弱的数据结构体。</span><br><span class=\"line\">· 抽象性</span><br><span class=\"line\">在软件开发的分析、设计时对具体问题进行归纳、概括，</span><br><span class=\"line\">并将这一类对象的公共特性加以条理化和严格描述，它主</span><br><span class=\"line\">张集中思想和精力，考虑关键、主要、实质性的问题，去</span><br><span class=\"line\">掉非主要的部分，便于开发人员对整个问题准确地认识。</span><br><span class=\"line\">为具体的对象定义一个类的过程就是抽象。</span><br><span class=\"line\">· 封装性</span><br><span class=\"line\">保证程序员用正确的方式操作对象，并将一些操作细节隐</span><br><span class=\"line\">藏起来。主要体现如下方面:</span><br><span class=\"line\">--- 保护私有数据:不允许外部程序直接访问私有的数据</span><br><span class=\"line\">--- 隐藏了操作细节:提供公用成员函数提供外部调用</span><br><span class=\"line\">根据这两个方面,我们可以举一个例子来说明:</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *声明一个A类，包含两个数据成员并封装成4个成员函数</span><br><span class=\"line\">\t *这里使用this指针加深印象</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _sex;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid setname(string name) &#123; </span><br><span class=\"line\">\t\tthis -&gt;_name = name; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setsex(string sex) &#123; </span><br><span class=\"line\">\t\tthis-&gt;_sex = sex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring getname() &#123; return this -&gt;_name; &#125;</span><br><span class=\"line\">\tstring getsex() &#123; return this -&gt;_sex; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *使用指针的方法实例化A的一个对象</span><br><span class=\"line\">\t *定义两个string临时变量</span><br><span class=\"line\">\t *调用公共的数据成员封装函数进行赋值和输出</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tA * a1 = new A();</span><br><span class=\"line\">\tstring temp1,temp2;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的姓名&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp1;</span><br><span class=\"line\">\ta1-&gt;setname(temp1);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的性别&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp2;</span><br><span class=\"line\">\ta1-&gt;setsex(temp2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;姓名:&quot; &lt;&lt; a1-&gt;getname() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;性别:&quot; &lt;&lt; a1-&gt;getsex() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">程序员的责任就是封装复杂的数据和操作，以简单明了的</span><br><span class=\"line\">共有函数的方式为外部程序提供对象操作接口</span><br></pre></td></tr></table></figure>"},{"title":"C++ note2","date":"2019-06-04T08:46:54.000Z","_content":"C++的一些知识补充  \n<!--more-->  \n# C++笔记 \n---\n> **学习方法**  \n- 学习C\\++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C\\++源程序。一旦发现\n了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、\n高效的C++程序。\n---\n# **知识补充**  \n\n> **条件操作符**  \n-  用法 :: <表达式1>?<表达式2>:<表达式3>  \n 如果表达式为true，返回表达式2的值；否则返回表达式3的值  \n> **typeid操作符**  \n-  用法 :: typeid(类型 || 变量).name()  \n 通过name()函数获取该类型或变量的名字。  \n> **安全使用数组下标**  \n- 当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。  \n> **安全使用字符串**  \n- 字符数组不是C\\++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:\n```\nchar str1[] = \"hello\";\ncout << str1 << endl;\nstr1[5] = '!';\ncout << str1 << endl;\n改代码输出了str1的末字符，输出如下:\nhello \nhello!烫烫烫？\n很显然，这不是我们想要的结果。使用'\\0'作为字符串时C\n++的非强制性约定，编译器不负责字符串的安全。另一方\n面，由于字符串本身就是字符数组，也会带来越界访问的\n隐患。\n```\n> **void\\*指针**\n- 一种特殊的指针类型，可以存放任意对象的地址   \n- 注意:  \n void\\*指针地址存放一个内存地址，地址指向内容不确定  \n void\\*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void\\*指针  \n> **引用**\n```\nint i;\nint & ri = i;   //类型 & 变量 = 引用对象\n```\n> **结构常见错误**  \n- 使用了未初始化的结构成员  \n- 指定了太多的初始值  \n> **位域**    \n- 定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省内存。\n```\nstruct Time{\n  unsigned hour : 5;    //5 bits,0~31\n  unsigned minute : 6;    //6 bits,0~63\n  unsigned second : 6;    //6 bits,0~63\n};\ncout << sizeof(Time) <<endl;\n输出结果：\n4\n\n``` \n\n> **联合**  \n- 联合也称作共用体，多个数据类型共用一块地址，起作用的只有一个数据类型。相当于多选一。  \n\n```\nunion ASCII{\n    char c;\n    short i;\n};\nASCII m;\nm.i = 70;\ncout << ASCII码为 << m.c << endl;\nm.c = 'a';\ncout << 字符a的ASCII码为: << m.i << endl;\n输出结果如下:\nASCII码为F\n字符a的ASCII码为：97\n\n```  \n\n> **枚举**  \n- 枚举采用关键字enum，用来定义一组常量\n\n```  \n\nenum Arrow{\n    UP,DOWN,LEFT,RIGHT\n};\nArrow a1 = UP;  //ok\nArrow a2 = 100; //error\ncout << a1 << endl;\n输出结果为:\n0\n```  \n\n- 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个枚举值。  \n> **typedef**  \n- typedef提供了为某种既有类型取别名的功能。 \n```\ntypedef int zhengxing;\nint t1;\nzhengxing t2;   //int == zhengxing\n常见用法\n· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。\n· 另外一种就是函数的指针的类型定义，如：在Windows线\n程编程中，就有类似的线程函数接口定义：\n    typedef void * LPVOID;\n    typedef DWORD WINARI ThreadProc(LPVOID 1pParamter);\n```\n> **数据类型修饰符**  \n- const  \n    中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，\n    它具有自己的内存地址，不过它不可以被修改。\n```\nint i = 100;\nint m = 200;\nint* ip0 = &i;  //非const\nint* const ip1 = &i;    //const 修饰int*\nint const * ip2 = &i;   //const 修饰int\nconst int* ip3 = &i;    //const 修饰int\nconst int* const ip4 = &i;  //const 同时修饰ip4和*ip4\n\nip0 = &m;\n*ip0 = 101;\n\n//ip1 = &m;\n*ip1 = 101;\n\nip2 = &m;\n//*ip2 = 101;\n\nip3 = &m;\n//*ip3 = 101;\n\n//ip4 = &m;\n//*ip4 = 101;\n\n注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2\n和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip\n3恰恰相反。它们本身可以被指来指去，但是它们指向的内\n容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。\n\n·常见用法\n取代宏，定义一些不可更改的值\n```  \n- volatile  \n- 不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  \n> **定义带参数的main()函数**  \n- main()函数支持另外一种原型  \n```\nint main(int argc,char * argv[]) {\n\tcout << \"参数数目:\\t\" << argc << endl;\n\tfor (int i = 0; i < argc; i++) {\n\t\tcout << \"参数\" << i << \":\\t\\t\" << argv[i] << endl;\n\t}\n\treturn 0;\n}\n输出结果为exe文件所在目录\n可以打开命令窗口进入到程序所在目录输入命令\n程序名+空格+bluejoe+vcer.net\n会输出程序的参数列表\n```\n> **预处理指令**  \n```\n预处理器一般完成如下操作：\n· 格式化代码，去多余的空格和注释；\n· 进行一些宏替换\n· 包含另外一段代码\n· 通过一些条件的判断，动态决定是否编译某段代码\n预处理指令\n#define     //定义宏\n#undef      //取消宏的定义\n#if         //判断\n#else       \n#elif\n#endif\n#error      //输出错误信息\n#include    //包含文件\n```\n- 宏指令   \n```\n· 一般的，定义宏的时候可以为其指定替换的文本\n· 也可以把宏定义成某个表达式\n· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R\nAND_MAX是由标准库函数定义的宏。如果需要取指定范围的\n随机数可以用到RAND_MAX,如\nint i = rand * 10 / RAND_MAX;   //0~10之间的数\n· 宏可以包含参数，这样的宏也可以叫做宏函数，如：\n#define S(x) x * x\nint main(){\n    cout << \"9的平方是:\"     << S(9) << endl;\n}\n· 宏函数具有一个很明显的优点，那就是避免了C++的强类\n型检测，如\n#define S(a,b) a+b\nint main() {\n\tstring s1 = \"Hello\";\n\tstring s2 = \"World\";\n\tcout << S(s1, s2) << endl;\n}\n· 宏与常量很相似，所以不能引用和指向宏定义的常量\n· 宏函数也是会有副作用的，如\n#define S(x) ((x) * (x))\nint i = 100;\ncout << \"S(101);\" << S(i++) << endl;\n输出如下: \nS(101): 10000\n结果并不是我们期待的101*101，避免副作用的方法，那就\n是正确运用宏，把宏看成一种预编译时期的文本替换，而\n这，也正是宏原本的含义。\n\n· #操作符\n如果宏定义中出现了‘#’，预处理器会将#后面的参数括成\n一个字符串进行替换，如\n#define S(i) cout << \"S(\"#i\")\" << ((i) * (i)) << endl;\nS(90);//等同于cout << \"S(\"90\")\" << ((90) * (90)) << endl;\n· >操作符\n“>”用于将两侧的参数合并成一个。如\n#define RGB(rr,gg,bb) 0x>rr>gg>bb\nint red = RGB(FF,00,00);\n//会被替换成\nint red = 0xFF0000;\n· 取消宏\n“#undef”用于取消指定名字的宏，然后修改宏的值\n吐槽一下：个人不知道为什么不能直接删除然后修改\n· C++预定义宏\n_LINE_      //整数，代表代号所在行号  \n_FILE_      //字符串，代表当前代码所在的文件路径\n_DATe_      //字符串代表当前文件的编译日期\n_TIME_      //字符串代表当前文件的编译时间\n_STDC_      //代表是否为标准C\n_cplusplus_ //当前当前的C++版本\n· 可以使用这些宏实现特定的功能\nbool ok = false;\nif(!ok){\n    cout << \"发生错误:\" << _FILE_ << \"(\" << _LINK_ << \")\" << endl;\n    cout << \"该软件最后发布时间：\" << _DATE_ << \" \" << _TIME_ << endl;\n}\n```\n> **条件编译指令**  \n- 预处理通过某些条件的判断有选择的进行处理  \n```\n· #if···#endif(条件编译的结尾) \n· #else 和 #elif  \n与if语句相似\n分别与if语句中的else和else if相似\n#define IS 9\nint main(){\n#if IS < 10\n    cout << \"TEST\" << endl;\n#elif Is < 5\n    cout << \"TEST2\" << endl;\n#else \n    cout << \"error\" << endl;\n#endif\n    return 0;\n}\n· #if define 和 #if !define\n前者用于检测指定的宏是否定义\n#if define IS\n    cout << \"已定义\" << endl;\n#else \n    cout << \"未定义\" << endl;\n#endif\n这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）\n还可以使用\"!\"操作符，指定某个宏没有被定义的情形，\n也就是#if !define.(个人感觉等同于#undef)\n#if !define IS\n    cout << \"未定义\" << endl;\n#endif\n· #ifdef 和 #ifndef\n前者等价于#if define,后者等价于#if !define：相当于缩写\n```\n> 文件包含指令  \n```\n· #include\n用于包含一个源文件\n文件名用<>时，它指示预处理器从预设的标准路径中搜索\n指定的头文件。预设路径一般是编译器自带的include目\n录，当前也可以自己添加其他的目录\n文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。\n在一些编译器中，还可以使用相对路径查找头文件\n· C标准库头文件\n<cassert>   //assert宏的定义   \n<cctype>    //字符操作函数的操作\n<cerrno>    //错误码的定义\n<cmath>     //数学函数库\n<setjmp>    //错误处理库\n<cstdarg>   //可变参数处理宏的定义\n<stdio>     //标准输入输出的声明\n<stdlib>    //数字函数、内存管理函数、系统函数、随\n              机函数等的声明\n<cstring>   //C类型的字符串的操作函数的声明\n<ctime>     //日期、时间操作函数的声明\n· C++标准库的头文件\n<string>        //字符串\n<iostream>      //流操作\n<fstream>       //文件流\n<complex>       //复数\n<stdexcept>     //标准异常\nSTL             //标准模板库\n· 合理的使用头文件\n考虑如下情况：\na.h 包含 point.h    b.h 包含 point.h\nc.h 包含 a.h 和 b.h\n这种情况下，当编译器处理c.h时，重复定义就出现了\n解决办法是，类似如下的办法，重新设计point.h的内容\n#ifndef _HEADER_POINt_H_\n#define _HEADER_POINt_H_\n头文件内容\n#endif\n以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通\n过它来 判断当前文件是否已经被包含。这样一来，即使po\nin.h被包含多次，由#ifndef...#endif定义的point.h文件\n的内容也不会被包含多次\n· #error\n当编译器遇到#error指令时，会停止下来，并在编译窗口\n输出#error后面的信息\n· #line\n用于改变当前行的行号和文件名\n· #pragma\n属于自定义指令，每个编译器可以自己定义自己的功能\n```\n\n---\n\n\n\n\n\n\n\n","source":"_posts/C++ note2.md","raw":"---\ntitle: C++ note2\ndate: 2019-06-04 16:46:54\ntags: note\ncategories: C++ \n---\nC++的一些知识补充  \n<!--more-->  \n# C++笔记 \n---\n> **学习方法**  \n- 学习C\\++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C\\++源程序。一旦发现\n了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、\n高效的C++程序。\n---\n# **知识补充**  \n\n> **条件操作符**  \n-  用法 :: <表达式1>?<表达式2>:<表达式3>  \n 如果表达式为true，返回表达式2的值；否则返回表达式3的值  \n> **typeid操作符**  \n-  用法 :: typeid(类型 || 变量).name()  \n 通过name()函数获取该类型或变量的名字。  \n> **安全使用数组下标**  \n- 当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。  \n> **安全使用字符串**  \n- 字符数组不是C\\++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:\n```\nchar str1[] = \"hello\";\ncout << str1 << endl;\nstr1[5] = '!';\ncout << str1 << endl;\n改代码输出了str1的末字符，输出如下:\nhello \nhello!烫烫烫？\n很显然，这不是我们想要的结果。使用'\\0'作为字符串时C\n++的非强制性约定，编译器不负责字符串的安全。另一方\n面，由于字符串本身就是字符数组，也会带来越界访问的\n隐患。\n```\n> **void\\*指针**\n- 一种特殊的指针类型，可以存放任意对象的地址   \n- 注意:  \n void\\*指针地址存放一个内存地址，地址指向内容不确定  \n void\\*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void\\*指针  \n> **引用**\n```\nint i;\nint & ri = i;   //类型 & 变量 = 引用对象\n```\n> **结构常见错误**  \n- 使用了未初始化的结构成员  \n- 指定了太多的初始值  \n> **位域**    \n- 定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省内存。\n```\nstruct Time{\n  unsigned hour : 5;    //5 bits,0~31\n  unsigned minute : 6;    //6 bits,0~63\n  unsigned second : 6;    //6 bits,0~63\n};\ncout << sizeof(Time) <<endl;\n输出结果：\n4\n\n``` \n\n> **联合**  \n- 联合也称作共用体，多个数据类型共用一块地址，起作用的只有一个数据类型。相当于多选一。  \n\n```\nunion ASCII{\n    char c;\n    short i;\n};\nASCII m;\nm.i = 70;\ncout << ASCII码为 << m.c << endl;\nm.c = 'a';\ncout << 字符a的ASCII码为: << m.i << endl;\n输出结果如下:\nASCII码为F\n字符a的ASCII码为：97\n\n```  \n\n> **枚举**  \n- 枚举采用关键字enum，用来定义一组常量\n\n```  \n\nenum Arrow{\n    UP,DOWN,LEFT,RIGHT\n};\nArrow a1 = UP;  //ok\nArrow a2 = 100; //error\ncout << a1 << endl;\n输出结果为:\n0\n```  \n\n- 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个枚举值。  \n> **typedef**  \n- typedef提供了为某种既有类型取别名的功能。 \n```\ntypedef int zhengxing;\nint t1;\nzhengxing t2;   //int == zhengxing\n常见用法\n· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。\n· 另外一种就是函数的指针的类型定义，如：在Windows线\n程编程中，就有类似的线程函数接口定义：\n    typedef void * LPVOID;\n    typedef DWORD WINARI ThreadProc(LPVOID 1pParamter);\n```\n> **数据类型修饰符**  \n- const  \n    中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，\n    它具有自己的内存地址，不过它不可以被修改。\n```\nint i = 100;\nint m = 200;\nint* ip0 = &i;  //非const\nint* const ip1 = &i;    //const 修饰int*\nint const * ip2 = &i;   //const 修饰int\nconst int* ip3 = &i;    //const 修饰int\nconst int* const ip4 = &i;  //const 同时修饰ip4和*ip4\n\nip0 = &m;\n*ip0 = 101;\n\n//ip1 = &m;\n*ip1 = 101;\n\nip2 = &m;\n//*ip2 = 101;\n\nip3 = &m;\n//*ip3 = 101;\n\n//ip4 = &m;\n//*ip4 = 101;\n\n注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2\n和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip\n3恰恰相反。它们本身可以被指来指去，但是它们指向的内\n容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。\n\n·常见用法\n取代宏，定义一些不可更改的值\n```  \n- volatile  \n- 不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  \n> **定义带参数的main()函数**  \n- main()函数支持另外一种原型  \n```\nint main(int argc,char * argv[]) {\n\tcout << \"参数数目:\\t\" << argc << endl;\n\tfor (int i = 0; i < argc; i++) {\n\t\tcout << \"参数\" << i << \":\\t\\t\" << argv[i] << endl;\n\t}\n\treturn 0;\n}\n输出结果为exe文件所在目录\n可以打开命令窗口进入到程序所在目录输入命令\n程序名+空格+bluejoe+vcer.net\n会输出程序的参数列表\n```\n> **预处理指令**  \n```\n预处理器一般完成如下操作：\n· 格式化代码，去多余的空格和注释；\n· 进行一些宏替换\n· 包含另外一段代码\n· 通过一些条件的判断，动态决定是否编译某段代码\n预处理指令\n#define     //定义宏\n#undef      //取消宏的定义\n#if         //判断\n#else       \n#elif\n#endif\n#error      //输出错误信息\n#include    //包含文件\n```\n- 宏指令   \n```\n· 一般的，定义宏的时候可以为其指定替换的文本\n· 也可以把宏定义成某个表达式\n· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R\nAND_MAX是由标准库函数定义的宏。如果需要取指定范围的\n随机数可以用到RAND_MAX,如\nint i = rand * 10 / RAND_MAX;   //0~10之间的数\n· 宏可以包含参数，这样的宏也可以叫做宏函数，如：\n#define S(x) x * x\nint main(){\n    cout << \"9的平方是:\"     << S(9) << endl;\n}\n· 宏函数具有一个很明显的优点，那就是避免了C++的强类\n型检测，如\n#define S(a,b) a+b\nint main() {\n\tstring s1 = \"Hello\";\n\tstring s2 = \"World\";\n\tcout << S(s1, s2) << endl;\n}\n· 宏与常量很相似，所以不能引用和指向宏定义的常量\n· 宏函数也是会有副作用的，如\n#define S(x) ((x) * (x))\nint i = 100;\ncout << \"S(101);\" << S(i++) << endl;\n输出如下: \nS(101): 10000\n结果并不是我们期待的101*101，避免副作用的方法，那就\n是正确运用宏，把宏看成一种预编译时期的文本替换，而\n这，也正是宏原本的含义。\n\n· #操作符\n如果宏定义中出现了‘#’，预处理器会将#后面的参数括成\n一个字符串进行替换，如\n#define S(i) cout << \"S(\"#i\")\" << ((i) * (i)) << endl;\nS(90);//等同于cout << \"S(\"90\")\" << ((90) * (90)) << endl;\n· >操作符\n“>”用于将两侧的参数合并成一个。如\n#define RGB(rr,gg,bb) 0x>rr>gg>bb\nint red = RGB(FF,00,00);\n//会被替换成\nint red = 0xFF0000;\n· 取消宏\n“#undef”用于取消指定名字的宏，然后修改宏的值\n吐槽一下：个人不知道为什么不能直接删除然后修改\n· C++预定义宏\n_LINE_      //整数，代表代号所在行号  \n_FILE_      //字符串，代表当前代码所在的文件路径\n_DATe_      //字符串代表当前文件的编译日期\n_TIME_      //字符串代表当前文件的编译时间\n_STDC_      //代表是否为标准C\n_cplusplus_ //当前当前的C++版本\n· 可以使用这些宏实现特定的功能\nbool ok = false;\nif(!ok){\n    cout << \"发生错误:\" << _FILE_ << \"(\" << _LINK_ << \")\" << endl;\n    cout << \"该软件最后发布时间：\" << _DATE_ << \" \" << _TIME_ << endl;\n}\n```\n> **条件编译指令**  \n- 预处理通过某些条件的判断有选择的进行处理  \n```\n· #if···#endif(条件编译的结尾) \n· #else 和 #elif  \n与if语句相似\n分别与if语句中的else和else if相似\n#define IS 9\nint main(){\n#if IS < 10\n    cout << \"TEST\" << endl;\n#elif Is < 5\n    cout << \"TEST2\" << endl;\n#else \n    cout << \"error\" << endl;\n#endif\n    return 0;\n}\n· #if define 和 #if !define\n前者用于检测指定的宏是否定义\n#if define IS\n    cout << \"已定义\" << endl;\n#else \n    cout << \"未定义\" << endl;\n#endif\n这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）\n还可以使用\"!\"操作符，指定某个宏没有被定义的情形，\n也就是#if !define.(个人感觉等同于#undef)\n#if !define IS\n    cout << \"未定义\" << endl;\n#endif\n· #ifdef 和 #ifndef\n前者等价于#if define,后者等价于#if !define：相当于缩写\n```\n> 文件包含指令  \n```\n· #include\n用于包含一个源文件\n文件名用<>时，它指示预处理器从预设的标准路径中搜索\n指定的头文件。预设路径一般是编译器自带的include目\n录，当前也可以自己添加其他的目录\n文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。\n在一些编译器中，还可以使用相对路径查找头文件\n· C标准库头文件\n<cassert>   //assert宏的定义   \n<cctype>    //字符操作函数的操作\n<cerrno>    //错误码的定义\n<cmath>     //数学函数库\n<setjmp>    //错误处理库\n<cstdarg>   //可变参数处理宏的定义\n<stdio>     //标准输入输出的声明\n<stdlib>    //数字函数、内存管理函数、系统函数、随\n              机函数等的声明\n<cstring>   //C类型的字符串的操作函数的声明\n<ctime>     //日期、时间操作函数的声明\n· C++标准库的头文件\n<string>        //字符串\n<iostream>      //流操作\n<fstream>       //文件流\n<complex>       //复数\n<stdexcept>     //标准异常\nSTL             //标准模板库\n· 合理的使用头文件\n考虑如下情况：\na.h 包含 point.h    b.h 包含 point.h\nc.h 包含 a.h 和 b.h\n这种情况下，当编译器处理c.h时，重复定义就出现了\n解决办法是，类似如下的办法，重新设计point.h的内容\n#ifndef _HEADER_POINt_H_\n#define _HEADER_POINt_H_\n头文件内容\n#endif\n以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通\n过它来 判断当前文件是否已经被包含。这样一来，即使po\nin.h被包含多次，由#ifndef...#endif定义的point.h文件\n的内容也不会被包含多次\n· #error\n当编译器遇到#error指令时，会停止下来，并在编译窗口\n输出#error后面的信息\n· #line\n用于改变当前行的行号和文件名\n· #pragma\n属于自定义指令，每个编译器可以自己定义自己的功能\n```\n\n---\n\n\n\n\n\n\n\n","slug":"C++ note2","published":1,"updated":"2019-06-04T09:43:20.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjwhso7db000pu4im45mp3xcu","content":"<p>C++的一些知识补充<br><a id=\"more\"></a>  </p>\n<h1 id=\"C-笔记\"><a href=\"#C-笔记\" class=\"headerlink\" title=\"C++笔记\"></a>C++笔记</h1><hr>\n<blockquote>\n<p><strong>学习方法</strong>  </p>\n<ul>\n<li>学习C++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C++源程序。一旦发现<br>了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、</li>\n</ul>\n</blockquote>\n<h2 id=\"高效的C-程序。\"><a href=\"#高效的C-程序。\" class=\"headerlink\" title=\"高效的C++程序。\"></a>高效的C++程序。</h2><h1 id=\"知识补充\"><a href=\"#知识补充\" class=\"headerlink\" title=\"知识补充\"></a><strong>知识补充</strong></h1><blockquote>\n<p><strong>条件操作符</strong>  </p>\n<ul>\n<li>用法 :: &lt;表达式1&gt;?&lt;表达式2&gt;:&lt;表达式3&gt;<br>如果表达式为true，返回表达式2的值；否则返回表达式3的值<br><strong>typeid操作符</strong>  </li>\n<li>用法 :: typeid(类型 || 变量).name()<br>通过name()函数获取该类型或变量的名字。<br><strong>安全使用数组下标</strong>  </li>\n<li>当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。<br><strong>安全使用字符串</strong>  </li>\n<li>字符数组不是C++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str1[] = &quot;hello&quot;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">str1[5] = &apos;!&apos;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">改代码输出了str1的末字符，输出如下:</span><br><span class=\"line\">hello </span><br><span class=\"line\">hello!烫烫烫？</span><br><span class=\"line\">很显然，这不是我们想要的结果。使用&apos;\\0&apos;作为字符串时C</span><br><span class=\"line\">++的非强制性约定，编译器不负责字符串的安全。另一方</span><br><span class=\"line\">面，由于字符串本身就是字符数组，也会带来越界访问的</span><br><span class=\"line\">隐患。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>void*指针</strong></p>\n<ul>\n<li>一种特殊的指针类型，可以存放任意对象的地址   </li>\n<li>注意:<br>void*指针地址存放一个内存地址，地址指向内容不确定<br>void*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void*指针<br><strong>引用</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i;</span><br><span class=\"line\">int &amp; ri = i;   //类型 &amp; 变量 = 引用对象</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>结构常见错误</strong>  </p>\n<ul>\n<li>使用了未初始化的结构成员  </li>\n<li>指定了太多的初始值<br><strong>位域</strong>    </li>\n<li>定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省内存。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Time&#123;</span><br><span class=\"line\">  unsigned hour : 5;    //5 bits,0~31</span><br><span class=\"line\">  unsigned minute : 6;    //6 bits,0~63</span><br><span class=\"line\">  unsigned second : 6;    //6 bits,0~63</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; sizeof(Time) &lt;&lt;endl;</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">&gt; **联合**  </span><br><span class=\"line\">- 联合也称作共用体，多个数据类型共用一块地址，起作用的只有一个数据类型。相当于多选一。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>union ASCII{<br>    char c;<br>    short i;<br>};<br>ASCII m;<br>m.i = 70;<br>cout &lt;&lt; ASCII码为 &lt;&lt; m.c &lt;&lt; endl;<br>m.c = ‘a’;<br>cout &lt;&lt; 字符a的ASCII码为: &lt;&lt; m.i &lt;&lt; endl;<br>输出结果如下:<br>ASCII码为F<br>字符a的ASCII码为：97</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; **枚举**  </span><br><span class=\"line\">- 枚举采用关键字enum，用来定义一组常量</span><br><span class=\"line\"></span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">enum Arrow&#123;</span><br><span class=\"line\">    UP,DOWN,LEFT,RIGHT</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrow a1 = UP;  //ok</span><br><span class=\"line\">Arrow a2 = 100; //error</span><br><span class=\"line\">cout &lt;&lt; a1 &lt;&lt; endl;</span><br><span class=\"line\">输出结果为:</span><br><span class=\"line\">0</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">- 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个枚举值。  </span><br><span class=\"line\">&gt; **typedef**  </span><br><span class=\"line\">- typedef提供了为某种既有类型取别名的功能。</span><br></pre></td></tr></table></figure>\n<p>typedef int zhengxing;<br>int t1;<br>zhengxing t2;   //int == zhengxing<br>常见用法<br>· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。<br>· 另外一种就是函数的指针的类型定义，如：在Windows线<br>程编程中，就有类似的线程函数接口定义：<br>    typedef void * LPVOID;<br>    typedef DWORD WINARI ThreadProc(LPVOID 1pParamter);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; **数据类型修饰符**  </span><br><span class=\"line\">- const  </span><br><span class=\"line\">    中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，</span><br><span class=\"line\">    它具有自己的内存地址，不过它不可以被修改。</span><br></pre></td></tr></table></figure></p>\n<p>int i = 100;<br>int m = 200;<br>int<em> ip0 = &i;  //非const<br>int</em> const ip1 = &i;    //const 修饰int<em><br>int const </em> ip2 = &i;   //const 修饰int<br>const int<em> ip3 = &i;    //const 修饰int<br>const int</em> const ip4 = &i;  //const 同时修饰ip4和*ip4</p>\n<p>ip0 = &m;<br>*ip0 = 101;</p>\n<p>//ip1 = &m;<br>*ip1 = 101;</p>\n<p>ip2 = &m;<br>//*ip2 = 101;</p>\n<p>ip3 = &m;<br>//*ip3 = 101;</p>\n<p>//ip4 = &m;<br>//*ip4 = 101;</p>\n<p>注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2<br>和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip<br>3恰恰相反。它们本身可以被指来指去，但是它们指向的内<br>容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。</p>\n<p>·常见用法<br>取代宏，定义一些不可更改的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- volatile  </span><br><span class=\"line\">- 不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  </span><br><span class=\"line\">&gt; **定义带参数的main()函数**  </span><br><span class=\"line\">- main()函数支持另外一种原型</span><br></pre></td></tr></table></figure></p>\n<p>int main(int argc,char * argv[]) {<br>    cout &lt;&lt; “参数数目:\\t” &lt;&lt; argc &lt;&lt; endl;<br>    for (int i = 0; i &lt; argc; i++) {<br>        cout &lt;&lt; “参数” &lt;&lt; i &lt;&lt; “:\\t\\t” &lt;&lt; argv[i] &lt;&lt; endl;<br>    }<br>    return 0;<br>}<br>输出结果为exe文件所在目录<br>可以打开命令窗口进入到程序所在目录输入命令<br>程序名+空格+bluejoe+vcer.net<br>会输出程序的参数列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; **预处理指令**</span><br></pre></td></tr></table></figure></p>\n<p>预处理器一般完成如下操作：<br>· 格式化代码，去多余的空格和注释；<br>· 进行一些宏替换<br>· 包含另外一段代码<br>· 通过一些条件的判断，动态决定是否编译某段代码<br>预处理指令</p>\n<p>#define     //定义宏</p>\n<p>#undef      //取消宏的定义</p>\n<p>#if         //判断</p>\n<p>#else       </p>\n<p>#elif</p>\n<p>#endif</p>\n<p>#error      //输出错误信息</p>\n<p>#include    //包含文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 宏指令</span><br></pre></td></tr></table></figure></p>\n<p>· 一般的，定义宏的时候可以为其指定替换的文本<br>· 也可以把宏定义成某个表达式<br>· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R<br>AND_MAX是由标准库函数定义的宏。如果需要取指定范围的<br>随机数可以用到RAND_MAX,如<br>int i = rand * 10 / RAND_MAX;   //0~10之间的数<br>· 宏可以包含参数，这样的宏也可以叫做宏函数，如：</p>\n<p>#define S(x) x * x<br>int main(){<br>    cout &lt;&lt; “9的平方是:”     &lt;&lt; S(9) &lt;&lt; endl;<br>}<br>· 宏函数具有一个很明显的优点，那就是避免了C++的强类<br>型检测，如</p>\n<p>#define S(a,b) a+b<br>int main() {<br>    string s1 = “Hello”;<br>    string s2 = “World”;<br>    cout &lt;&lt; S(s1, s2) &lt;&lt; endl;<br>}<br>· 宏与常量很相似，所以不能引用和指向宏定义的常量<br>· 宏函数也是会有副作用的，如</p>\n<p>#define S(x) ((x) <em> (x))<br>int i = 100;<br>cout &lt;&lt; “S(101);” &lt;&lt; S(i++) &lt;&lt; endl;<br>输出如下:<br>S(101): 10000<br>结果并不是我们期待的101</em>101，避免副作用的方法，那就<br>是正确运用宏，把宏看成一种预编译时期的文本替换，而<br>这，也正是宏原本的含义。</p>\n<p>· #操作符<br>如果宏定义中出现了‘#’，预处理器会将#后面的参数括成<br>一个字符串进行替换，如</p>\n<p>#define S(i) cout &lt;&lt; “S(“#i”)” &lt;&lt; ((i) <em> (i)) &lt;&lt; endl;<br>S(90);//等同于cout &lt;&lt; “S(“90”)” &lt;&lt; ((90) </em> (90)) &lt;&lt; endl;<br>· &gt;操作符<br>“&gt;”用于将两侧的参数合并成一个。如</p>\n<p>#define RGB(rr,gg,bb) 0x&gt;rr&gt;gg&gt;bb<br>int red = RGB(FF,00,00);<br>//会被替换成<br>int red = 0xFF0000;<br>· 取消宏<br>“#undef”用于取消指定名字的宏，然后修改宏的值<br>吐槽一下：个人不知道为什么不能直接删除然后修改<br>· C++预定义宏<br><em>LINE</em>      //整数，代表代号所在行号<br><em>FILE</em>      //字符串，代表当前代码所在的文件路径<br><em>DATe</em>      //字符串代表当前文件的编译日期<br><em>TIME</em>      //字符串代表当前文件的编译时间<br><em>STDC</em>      //代表是否为标准C<br><em>cplusplus</em> //当前当前的C++版本<br>· 可以使用这些宏实现特定的功能<br>bool ok = false;<br>if(!ok){<br>    cout &lt;&lt; “发生错误:” &lt;&lt; <em>FILE</em> &lt;&lt; “(“ &lt;&lt; <em>LINK</em> &lt;&lt; “)” &lt;&lt; endl;<br>    cout &lt;&lt; “该软件最后发布时间：” &lt;&lt; <em>DATE</em> &lt;&lt; “ “ &lt;&lt; <em>TIME</em> &lt;&lt; endl;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; **条件编译指令**  </span><br><span class=\"line\">- 预处理通过某些条件的判断有选择的进行处理</span><br></pre></td></tr></table></figure></p>\n<p>· #if···#endif(条件编译的结尾)<br>· #else 和 #elif<br>与if语句相似<br>分别与if语句中的else和else if相似</p>\n<p>#define IS 9<br>int main(){</p>\n<p>#if IS &lt; 10<br>    cout &lt;&lt; “TEST” &lt;&lt; endl;</p>\n<p>#elif Is &lt; 5<br>    cout &lt;&lt; “TEST2” &lt;&lt; endl;</p>\n<p>#else<br>    cout &lt;&lt; “error” &lt;&lt; endl;</p>\n<p>#endif<br>    return 0;<br>}<br>· #if define 和 #if !define<br>前者用于检测指定的宏是否定义</p>\n<p>#if define IS<br>    cout &lt;&lt; “已定义” &lt;&lt; endl;</p>\n<p>#else<br>    cout &lt;&lt; “未定义” &lt;&lt; endl;</p>\n<p>#endif<br>这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）<br>还可以使用”!”操作符，指定某个宏没有被定义的情形，<br>也就是#if !define.(个人感觉等同于#undef)</p>\n<p>#if !define IS<br>    cout &lt;&lt; “未定义” &lt;&lt; endl;</p>\n<p>#endif<br>· #ifdef 和 #ifndef<br>前者等价于#if define,后者等价于#if !define：相当于缩写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 文件包含指令</span><br></pre></td></tr></table></figure></p>\n<p>· #include<br>用于包含一个源文件<br>文件名用&lt;&gt;时，它指示预处理器从预设的标准路径中搜索<br>指定的头文件。预设路径一般是编译器自带的include目<br>录，当前也可以自己添加其他的目录<br>文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。<br>在一些编译器中，还可以使用相对路径查找头文件<br>· C标准库头文件</p>\n<p><cassert>   //assert宏的定义   </cassert></p>\n<p><cctype>    //字符操作函数的操作</cctype></p>\n<p><cerrno>    //错误码的定义</cerrno></p>\n<p><cmath>     //数学函数库</cmath></p>\n<p><setjmp>    //错误处理库</setjmp></p>\n<p><cstdarg>   //可变参数处理宏的定义</cstdarg></p>\n<p><stdio>     //标准输入输出的声明</stdio></p>\n<p><stdlib>    //数字函数、内存管理函数、系统函数、随<br>              机函数等的声明</stdlib></p>\n<p><cstring>   //C类型的字符串的操作函数的声明</cstring></p>\n<p><ctime>     //日期、时间操作函数的声明<br>· C++标准库的头文件</ctime></p>\n<p><string>        //字符串</string></p>\n<p><iostream>      //流操作</iostream></p>\n<p><fstream>       //文件流</fstream></p>\n<p><complex>       //复数</complex></p>\n<p><stdexcept>     //标准异常<br>STL             //标准模板库<br>· 合理的使用头文件<br>考虑如下情况：<br>a.h 包含 point.h    b.h 包含 point.h<br>c.h 包含 a.h 和 b.h<br>这种情况下，当编译器处理c.h时，重复定义就出现了<br>解决办法是，类似如下的办法，重新设计point.h的内容</stdexcept></p>\n<p>#ifndef _HEADER_POINt_H_</p>\n<p>#define _HEADER_POINt_H_<br>头文件内容</p>\n<p>#endif<br>以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通<br>过它来 判断当前文件是否已经被包含。这样一来，即使po<br>in.h被包含多次，由#ifndef…#endif定义的point.h文件<br>的内容也不会被包含多次<br>· #error<br>当编译器遇到#error指令时，会停止下来，并在编译窗口<br>输出#error后面的信息<br>· #line<br>用于改变当前行的行号和文件名<br>· #pragma<br>属于自定义指令，每个编译器可以自己定义自己的功能<br><code>`</code></p>\n<hr>\n","site":{"data":{}},"excerpt":"<p>C++的一些知识补充<br></p>","more":"<p></p>\n<h1 id=\"C-笔记\"><a href=\"#C-笔记\" class=\"headerlink\" title=\"C++笔记\"></a>C++笔记</h1><hr>\n<blockquote>\n<p><strong>学习方法</strong>  </p>\n<ul>\n<li>学习C++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C++源程序。一旦发现<br>了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、</li>\n</ul>\n</blockquote>\n<h2 id=\"高效的C-程序。\"><a href=\"#高效的C-程序。\" class=\"headerlink\" title=\"高效的C++程序。\"></a>高效的C++程序。</h2><h1 id=\"知识补充\"><a href=\"#知识补充\" class=\"headerlink\" title=\"知识补充\"></a><strong>知识补充</strong></h1><blockquote>\n<p><strong>条件操作符</strong>  </p>\n<ul>\n<li>用法 :: &lt;表达式1&gt;?&lt;表达式2&gt;:&lt;表达式3&gt;<br>如果表达式为true，返回表达式2的值；否则返回表达式3的值<br><strong>typeid操作符</strong>  </li>\n<li>用法 :: typeid(类型 || 变量).name()<br>通过name()函数获取该类型或变量的名字。<br><strong>安全使用数组下标</strong>  </li>\n<li>当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。<br><strong>安全使用字符串</strong>  </li>\n<li>字符数组不是C++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str1[] = &quot;hello&quot;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">str1[5] = &apos;!&apos;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">改代码输出了str1的末字符，输出如下:</span><br><span class=\"line\">hello </span><br><span class=\"line\">hello!烫烫烫？</span><br><span class=\"line\">很显然，这不是我们想要的结果。使用&apos;\\0&apos;作为字符串时C</span><br><span class=\"line\">++的非强制性约定，编译器不负责字符串的安全。另一方</span><br><span class=\"line\">面，由于字符串本身就是字符数组，也会带来越界访问的</span><br><span class=\"line\">隐患。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>void*指针</strong></p>\n<ul>\n<li>一种特殊的指针类型，可以存放任意对象的地址   </li>\n<li>注意:<br>void*指针地址存放一个内存地址，地址指向内容不确定<br>void*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void*指针<br><strong>引用</strong><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i;</span><br><span class=\"line\">int &amp; ri = i;   //类型 &amp; 变量 = 引用对象</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>结构常见错误</strong>  </p>\n<ul>\n<li>使用了未初始化的结构成员  </li>\n<li>指定了太多的初始值<br><strong>位域</strong>    </li>\n<li>定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省内存。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Time&#123;</span><br><span class=\"line\">  unsigned hour : 5;    //5 bits,0~31</span><br><span class=\"line\">  unsigned minute : 6;    //6 bits,0~63</span><br><span class=\"line\">  unsigned second : 6;    //6 bits,0~63</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; sizeof(Time) &lt;&lt;endl;</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">4</span><br><span class=\"line\"></span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">&gt; **联合**  </span><br><span class=\"line\">- 联合也称作共用体，多个数据类型共用一块地址，起作用的只有一个数据类型。相当于多选一。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<p>union ASCII{<br>    char c;<br>    short i;<br>};<br>ASCII m;<br>m.i = 70;<br>cout &lt;&lt; ASCII码为 &lt;&lt; m.c &lt;&lt; endl;<br>m.c = ‘a’;<br>cout &lt;&lt; 字符a的ASCII码为: &lt;&lt; m.i &lt;&lt; endl;<br>输出结果如下:<br>ASCII码为F<br>字符a的ASCII码为：97</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&gt; **枚举**  </span><br><span class=\"line\">- 枚举采用关键字enum，用来定义一组常量</span><br><span class=\"line\"></span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">enum Arrow&#123;</span><br><span class=\"line\">    UP,DOWN,LEFT,RIGHT</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrow a1 = UP;  //ok</span><br><span class=\"line\">Arrow a2 = 100; //error</span><br><span class=\"line\">cout &lt;&lt; a1 &lt;&lt; endl;</span><br><span class=\"line\">输出结果为:</span><br><span class=\"line\">0</span><br><span class=\"line\">```  </span><br><span class=\"line\"></span><br><span class=\"line\">- 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个枚举值。  </span><br><span class=\"line\">&gt; **typedef**  </span><br><span class=\"line\">- typedef提供了为某种既有类型取别名的功能。</span><br></pre></td></tr></table></figure>\n<p>typedef int zhengxing;<br>int t1;<br>zhengxing t2;   //int == zhengxing<br>常见用法<br>· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。<br>· 另外一种就是函数的指针的类型定义，如：在Windows线<br>程编程中，就有类似的线程函数接口定义：<br>    typedef void * LPVOID;<br>    typedef DWORD WINARI ThreadProc(LPVOID 1pParamter);<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; **数据类型修饰符**  </span><br><span class=\"line\">- const  </span><br><span class=\"line\">    中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，</span><br><span class=\"line\">    它具有自己的内存地址，不过它不可以被修改。</span><br></pre></td></tr></table></figure></p>\n<p>int i = 100;<br>int m = 200;<br>int<em> ip0 = &i;  //非const<br>int</em> const ip1 = &i;    //const 修饰int<em><br>int const </em> ip2 = &i;   //const 修饰int<br>const int<em> ip3 = &i;    //const 修饰int<br>const int</em> const ip4 = &i;  //const 同时修饰ip4和*ip4</p>\n<p>ip0 = &m;<br>*ip0 = 101;</p>\n<p>//ip1 = &m;<br>*ip1 = 101;</p>\n<p>ip2 = &m;<br>//*ip2 = 101;</p>\n<p>ip3 = &m;<br>//*ip3 = 101;</p>\n<p>//ip4 = &m;<br>//*ip4 = 101;</p>\n<p>注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2<br>和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip<br>3恰恰相反。它们本身可以被指来指去，但是它们指向的内<br>容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。</p>\n<p>·常见用法<br>取代宏，定义一些不可更改的值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- volatile  </span><br><span class=\"line\">- 不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  </span><br><span class=\"line\">&gt; **定义带参数的main()函数**  </span><br><span class=\"line\">- main()函数支持另外一种原型</span><br></pre></td></tr></table></figure></p>\n<p>int main(int argc,char * argv[]) {<br>    cout &lt;&lt; “参数数目:\\t” &lt;&lt; argc &lt;&lt; endl;<br>    for (int i = 0; i &lt; argc; i++) {<br>        cout &lt;&lt; “参数” &lt;&lt; i &lt;&lt; “:\\t\\t” &lt;&lt; argv[i] &lt;&lt; endl;<br>    }<br>    return 0;<br>}<br>输出结果为exe文件所在目录<br>可以打开命令窗口进入到程序所在目录输入命令<br>程序名+空格+bluejoe+vcer.net<br>会输出程序的参数列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; **预处理指令**</span><br></pre></td></tr></table></figure></p>\n<p>预处理器一般完成如下操作：<br>· 格式化代码，去多余的空格和注释；<br>· 进行一些宏替换<br>· 包含另外一段代码<br>· 通过一些条件的判断，动态决定是否编译某段代码<br>预处理指令</p>\n<p>#define     //定义宏</p>\n<p>#undef      //取消宏的定义</p>\n<p>#if         //判断</p>\n<p>#else       </p>\n<p>#elif</p>\n<p>#endif</p>\n<p>#error      //输出错误信息</p>\n<p>#include    //包含文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- 宏指令</span><br></pre></td></tr></table></figure></p>\n<p>· 一般的，定义宏的时候可以为其指定替换的文本<br>· 也可以把宏定义成某个表达式<br>· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R<br>AND_MAX是由标准库函数定义的宏。如果需要取指定范围的<br>随机数可以用到RAND_MAX,如<br>int i = rand * 10 / RAND_MAX;   //0~10之间的数<br>· 宏可以包含参数，这样的宏也可以叫做宏函数，如：</p>\n<p>#define S(x) x * x<br>int main(){<br>    cout &lt;&lt; “9的平方是:”     &lt;&lt; S(9) &lt;&lt; endl;<br>}<br>· 宏函数具有一个很明显的优点，那就是避免了C++的强类<br>型检测，如</p>\n<p>#define S(a,b) a+b<br>int main() {<br>    string s1 = “Hello”;<br>    string s2 = “World”;<br>    cout &lt;&lt; S(s1, s2) &lt;&lt; endl;<br>}<br>· 宏与常量很相似，所以不能引用和指向宏定义的常量<br>· 宏函数也是会有副作用的，如</p>\n<p>#define S(x) ((x) <em> (x))<br>int i = 100;<br>cout &lt;&lt; “S(101);” &lt;&lt; S(i++) &lt;&lt; endl;<br>输出如下:<br>S(101): 10000<br>结果并不是我们期待的101</em>101，避免副作用的方法，那就<br>是正确运用宏，把宏看成一种预编译时期的文本替换，而<br>这，也正是宏原本的含义。</p>\n<p>· #操作符<br>如果宏定义中出现了‘#’，预处理器会将#后面的参数括成<br>一个字符串进行替换，如</p>\n<p>#define S(i) cout &lt;&lt; “S(“#i”)” &lt;&lt; ((i) <em> (i)) &lt;&lt; endl;<br>S(90);//等同于cout &lt;&lt; “S(“90”)” &lt;&lt; ((90) </em> (90)) &lt;&lt; endl;<br>· &gt;操作符<br>“&gt;”用于将两侧的参数合并成一个。如</p>\n<p>#define RGB(rr,gg,bb) 0x&gt;rr&gt;gg&gt;bb<br>int red = RGB(FF,00,00);<br>//会被替换成<br>int red = 0xFF0000;<br>· 取消宏<br>“#undef”用于取消指定名字的宏，然后修改宏的值<br>吐槽一下：个人不知道为什么不能直接删除然后修改<br>· C++预定义宏<br><em>LINE</em>      //整数，代表代号所在行号<br><em>FILE</em>      //字符串，代表当前代码所在的文件路径<br><em>DATe</em>      //字符串代表当前文件的编译日期<br><em>TIME</em>      //字符串代表当前文件的编译时间<br><em>STDC</em>      //代表是否为标准C<br><em>cplusplus</em> //当前当前的C++版本<br>· 可以使用这些宏实现特定的功能<br>bool ok = false;<br>if(!ok){<br>    cout &lt;&lt; “发生错误:” &lt;&lt; <em>FILE</em> &lt;&lt; “(“ &lt;&lt; <em>LINK</em> &lt;&lt; “)” &lt;&lt; endl;<br>    cout &lt;&lt; “该软件最后发布时间：” &lt;&lt; <em>DATE</em> &lt;&lt; “ “ &lt;&lt; <em>TIME</em> &lt;&lt; endl;<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; **条件编译指令**  </span><br><span class=\"line\">- 预处理通过某些条件的判断有选择的进行处理</span><br></pre></td></tr></table></figure></p>\n<p>· #if···#endif(条件编译的结尾)<br>· #else 和 #elif<br>与if语句相似<br>分别与if语句中的else和else if相似</p>\n<p>#define IS 9<br>int main(){</p>\n<p>#if IS &lt; 10<br>    cout &lt;&lt; “TEST” &lt;&lt; endl;</p>\n<p>#elif Is &lt; 5<br>    cout &lt;&lt; “TEST2” &lt;&lt; endl;</p>\n<p>#else<br>    cout &lt;&lt; “error” &lt;&lt; endl;</p>\n<p>#endif<br>    return 0;<br>}<br>· #if define 和 #if !define<br>前者用于检测指定的宏是否定义</p>\n<p>#if define IS<br>    cout &lt;&lt; “已定义” &lt;&lt; endl;</p>\n<p>#else<br>    cout &lt;&lt; “未定义” &lt;&lt; endl;</p>\n<p>#endif<br>这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）<br>还可以使用”!”操作符，指定某个宏没有被定义的情形，<br>也就是#if !define.(个人感觉等同于#undef)</p>\n<p>#if !define IS<br>    cout &lt;&lt; “未定义” &lt;&lt; endl;</p>\n<p>#endif<br>· #ifdef 和 #ifndef<br>前者等价于#if define,后者等价于#if !define：相当于缩写<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 文件包含指令</span><br></pre></td></tr></table></figure></p>\n<p>· #include<br>用于包含一个源文件<br>文件名用&lt;&gt;时，它指示预处理器从预设的标准路径中搜索<br>指定的头文件。预设路径一般是编译器自带的include目<br>录，当前也可以自己添加其他的目录<br>文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。<br>在一些编译器中，还可以使用相对路径查找头文件<br>· C标准库头文件</p>\n<p><cassert>   //assert宏的定义   </cassert></p>\n<p><cctype>    //字符操作函数的操作</cctype></p>\n<p><cerrno>    //错误码的定义</cerrno></p>\n<p><cmath>     //数学函数库</cmath></p>\n<p><setjmp>    //错误处理库</setjmp></p>\n<p><cstdarg>   //可变参数处理宏的定义</cstdarg></p>\n<p><stdio>     //标准输入输出的声明</stdio></p>\n<p><stdlib>    //数字函数、内存管理函数、系统函数、随<br>              机函数等的声明</stdlib></p>\n<p><cstring>   //C类型的字符串的操作函数的声明</cstring></p>\n<p><ctime>     //日期、时间操作函数的声明<br>· C++标准库的头文件</ctime></p>\n<p><string>        //字符串</string></p>\n<p><iostream>      //流操作</iostream></p>\n<p><fstream>       //文件流</fstream></p>\n<p><complex>       //复数</complex></p>\n<p><stdexcept>     //标准异常<br>STL             //标准模板库<br>· 合理的使用头文件<br>考虑如下情况：<br>a.h 包含 point.h    b.h 包含 point.h<br>c.h 包含 a.h 和 b.h<br>这种情况下，当编译器处理c.h时，重复定义就出现了<br>解决办法是，类似如下的办法，重新设计point.h的内容</stdexcept></p>\n<p>#ifndef _HEADER_POINt_H_</p>\n<p>#define _HEADER_POINt_H_<br>头文件内容</p>\n<p>#endif<br>以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通<br>过它来 判断当前文件是否已经被包含。这样一来，即使po<br>in.h被包含多次，由#ifndef…#endif定义的point.h文件<br>的内容也不会被包含多次<br>· #error<br>当编译器遇到#error指令时，会停止下来，并在编译窗口<br>输出#error后面的信息<br>· #line<br>用于改变当前行的行号和文件名<br>· #pragma<br>属于自定义指令，每个编译器可以自己定义自己的功能<br><code>`</code></p>\n<hr>"}],"PostAsset":[{"_id":"source/_posts/MY_first_Blog/功能.png","slug":"功能.png","post":"cjwhso7750006u4imj6gutry9","modified":1,"renderable":0},{"_id":"source/_posts/MY_first_Blog/优势.png","post":"cjwhso7750006u4imj6gutry9","slug":"优势.png","modified":1,"renderable":1},{"_id":"source/_posts/C-类的案例/1.png","post":"cjwhso7700002u4iml1hmb4ie","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/C-类的案例/2.png","post":"cjwhso7700002u4iml1hmb4ie","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/C-类的案例/3.png","post":"cjwhso7700002u4iml1hmb4ie","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/C-类的案例/步骤1.png","post":"cjwhso7700002u4iml1hmb4ie","slug":"步骤1.png","modified":1,"renderable":1},{"_id":"source/_posts/C-类的案例/步骤二.png","post":"cjwhso7700002u4iml1hmb4ie","slug":"步骤二.png","modified":1,"renderable":1},{"_id":"source/_posts/C-类的案例/流程图.jpg","post":"cjwhso7700002u4iml1hmb4ie","slug":"流程图.jpg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjwhso76w0000u4im5y7vmjpp","category_id":"cjwhso7730004u4im1q3vmtzv","_id":"cjwhso77h000gu4im74sy8l4t"},{"post_id":"cjwhso77c000cu4im7uecgg18","category_id":"cjwhso7730004u4im1q3vmtzv","_id":"cjwhso77i000ju4imjansbkt9"},{"post_id":"cjwhso7700002u4iml1hmb4ie","category_id":"cjwhso7730004u4im1q3vmtzv","_id":"cjwhso77i000lu4im9f5fo5pi"},{"post_id":"cjwhso7770008u4im18athr1j","category_id":"cjwhso77g000fu4imvo6i82fd","_id":"cjwhso77j000mu4ime3lxx4jf"},{"post_id":"cjwhso77f000eu4im5rmoopsp","category_id":"cjwhso77g000fu4imvo6i82fd","_id":"cjwhso77j000nu4im9wzis2mp"},{"post_id":"cjwhso7d8000ou4imcu4ukkzb","category_id":"cjwhso7730004u4im1q3vmtzv","_id":"cjwhso7dh000su4imh9yve96f"},{"post_id":"cjwhso7db000pu4im45mp3xcu","category_id":"cjwhso7730004u4im1q3vmtzv","_id":"cjwhso7dh000tu4im6djo0ymj"}],"PostTag":[{"post_id":"cjwhso7770008u4im18athr1j","tag_id":"cjwhso7740005u4imr9qloguu","_id":"cjwhso77c000bu4im7qlm62p8"},{"post_id":"cjwhso76w0000u4im5y7vmjpp","tag_id":"cjwhso7740005u4imr9qloguu","_id":"cjwhso77e000du4imj65h0axv"},{"post_id":"cjwhso77c000cu4im7uecgg18","tag_id":"cjwhso7740005u4imr9qloguu","_id":"cjwhso77h000hu4imiax4lyvt"},{"post_id":"cjwhso77f000eu4im5rmoopsp","tag_id":"cjwhso7740005u4imr9qloguu","_id":"cjwhso77i000iu4imld4elqk3"},{"post_id":"cjwhso7d8000ou4imcu4ukkzb","tag_id":"cjwhso7740005u4imr9qloguu","_id":"cjwhso7df000qu4imby77kcnz"},{"post_id":"cjwhso7db000pu4im45mp3xcu","tag_id":"cjwhso7740005u4imr9qloguu","_id":"cjwhso7dh000ru4im13eswnmf"}],"Tag":[{"name":"note","_id":"cjwhso7740005u4imr9qloguu"}]}}