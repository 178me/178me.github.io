{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/background.jpg","path":"image/background.jpg","modified":0,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/header.jpg","path":"images/header.jpg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/affix.js","path":"js/affix.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/exturl.js","path":"js/exturl.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","path":"js/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/motion.js","path":"js/motion.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","path":"js/next-boot.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/post-details.js","path":"js/post-details.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","path":"js/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","path":"js/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1572101194470},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1572101194470},{"_id":"themes/hexo-theme-next/.all-contributorsrc","hash":"d139a3b623b2e40bbff5c96ad44adf7dbdbc5be1","modified":1572101194470},{"_id":"themes/hexo-theme-next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1572101194470},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1572101194470},{"_id":"themes/hexo-theme-next/.gitignore","hash":"3558a8b174618c7a643aceb13233edd729813f9a","modified":1572101194473},{"_id":"themes/hexo-theme-next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1572101194473},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1572101194473},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1572101194473},{"_id":"themes/hexo-theme-next/bower.json","hash":"9bc3900396a375f817db47d147bb6d207c661678","modified":1572101194473},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"23bd9587807edc4dbecb5c5a29ab96ade24458b5","modified":1572101194473},{"_id":"themes/hexo-theme-next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1572101194473},{"_id":"themes/hexo-theme-next/README.md","hash":"7958c3f70b2133b479ddaf525cc4b6d87a37e04a","modified":1572101194473},{"_id":"themes/hexo-theme-next/_config.yml","hash":"b8e59b0579797dd799117149dbb741ee852ceedb","modified":1572101194473},{"_id":"themes/hexo-theme-next/package.json","hash":"0284636ddd0e06ae593f4887819f3a35b08c1370","modified":1572101194480},{"_id":"source/_posts/C++ note1-1.md","hash":"edc31ba9302724f9d70ea1853d851930e7dda07e","modified":1572101194460},{"_id":"source/_posts/C-类的案例.md","hash":"623bb43dcd6930e23da6223e05bc49c546b949ed","modified":1572101194460},{"_id":"source/_posts/C++ note2.md","hash":"6b947ffd4c890c6fa00454fde32d9dc85b5253cc","modified":1572101194460},{"_id":"source/_posts/C++ note3.md","hash":"119fc9b9ede6232574f4308ae2ed4f0f903af72a","modified":1572101194460},{"_id":"source/_posts/C-高级特性.md","hash":"5dcdb4e37365c2dc41a3fac77526d47fc6c4d569","modified":1572101194460},{"_id":"source/_posts/Linux基本知识.md","hash":"1feab4dd4aca82faec7d1c28cb2a4c5724dbadb2","modified":1572101194460},{"_id":"source/_posts/Linxu-命令行.md","hash":"cbbaaf6e4cef3abe45c143a922309ea0355dd8ca","modified":1572101194460},{"_id":"source/_posts/My-Computer.md","hash":"611ff9594bbdca779a9a9618a8f770ee08fe8210","modified":1572254741533},{"_id":"source/_posts/Linux基本知识2.md","hash":"ced5b4fc79f54131dba66b91f19b2745b2f76280","modified":1572101194460},{"_id":"source/_posts/MY_first_Blog.md","hash":"3adbfdd8314557dd5e806300125fdf3d39c0ca34","modified":1572101194460},{"_id":"source/_posts/Qt-信号槽-对象树-Lambda.md","hash":"71d9edb32eff7f6314bb6d973191c125ec5e1628","modified":1572101194463},{"_id":"source/_posts/Qt-快速入门-一.md","hash":"a946a4552a08ec92c5f8766802044a47506fc702","modified":1572101194463},{"_id":"source/_posts/ctime-的常用函数.md","hash":"2dc99eec70bf1db920da280a5bf9ae050c291785","modified":1572101194463},{"_id":"source/_posts/Qt-快速入门-二.md","hash":"f6f529446306979e96baf1cd4262035836feedd7","modified":1572101194463},{"_id":"source/_posts/shell快捷键大全.md","hash":"df308eff14f7f25593a57c093c83780ef2ed9dec","modified":1572101194463},{"_id":"source/_posts/shell-note1.md","hash":"4189403047d7a087308ba1b16c3a02fa70946815","modified":1572101194463},{"_id":"source/_posts/学习面向对象思想的小结.md","hash":"a88bb70e314fb53245ca2a98bf6ce21e6f5c4256","modified":1572101194463},{"_id":"source/_posts/汇编语言基础.md","hash":"1c3132fcfce4a806723a263724c696ccf6f3d445","modified":1572101194463},{"_id":"source/_posts/暑假计划.md","hash":"3f25d32ce002ce4703c2775d69418fa87193e46f","modified":1572101194463},{"_id":"source/_posts/自学网络原理的第一天.md","hash":"9a976b69a6b0487be746cb61224f57075207acf6","modified":1572101194467},{"_id":"source/_posts/计算机网络安全原理-笔记.md","hash":"ce37ebeec42ac097eb9e723aad5e54b73086f79b","modified":1572101194467},{"_id":"source/categories/index-1.md","hash":"00766a2c95e5af34faa82e30ebf6285f85df2d3e","modified":1572101194467},{"_id":"source/categories/index.md","hash":"d49faee5f4f5cc45e0c98fe1e57e6b98dec95ae1","modified":1572101194467},{"_id":"source/image/background.jpg","hash":"5cb93fb5a8f61cd54454743005bd696f00da6e65","modified":1572101194467},{"_id":"source/tags/index.md","hash":"1cfe5abc3e2787e03d97c8fe7187d00112f7cc24","modified":1572101194467},{"_id":"themes/hexo-theme-next/.github/CODE_OF_CONDUCT.md","hash":"c149f003d03501565e7688915cd8f2e99fbf8f42","modified":1572101194470},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"285a95aca36e0ac770bcde2b35e3b572d45d1518","modified":1572101194470},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/auto_assign.yml","hash":"cb68a1dca1c4623448c2ca899614a9f21df1b036","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/eslint-disable-bot.yml","hash":"16541fb7b80f5ab90135db96285badb63c4d7d3e","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/config.yml","hash":"8a5cbf5aa9529390fe0a782758aca9c3a02f9dcf","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/mergeable.yml","hash":"8e3a6abc74b5cba57f9586fe6d98762fd4fc9b04","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/stale.yml","hash":"41bf97ee86b8940a0b2e754499ec77fd2b44b717","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/release-drafter.yml","hash":"b4476ada5c62ee7d63ba2e59ead2ec4897086e3c","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/weekly-digest.yml","hash":"404e4ccb7fcd6587bc9b0247a7a7ff256d21f2cb","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/topissuebot.yml","hash":"10665bf2b5aba351725715c71e94ad183a0e8f18","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"492b2c159d871e5b5d4c70d259f36e603afe192d","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/ALGOLIA-SEARCH.md","hash":"0d2f22ea09dd1ef63c66164e048d8239d2ccb2b8","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/lock.yml","hash":"585d2c471047be320aa62f2b74dad797bf09c530","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/MATH.md","hash":"026d2cff73c22a30ea39c50783557ff4913aceac","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1572101194473},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"9e524b2bdfb848504b93a51c5650e76bba5fa9e0","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/es.yml","hash":"1752429687861b5cedd063c6ebe5dacefbe7e5a7","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/fa.yml","hash":"cd41db832af5e399590b70a5227cfe0b0e98e101","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"1c4868837f5109f1df863b04fe627352c31d404b","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/fr.yml","hash":"7005c2b42c2c6e82bd7a1be5cc2f443b5fc79105","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"b30ff77ad8044e3b021a3b09187cd377dc789fd2","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"1dc35e436da6214cdb3c2ff44bc4a06d0be5b9a0","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"20bfaa7600d35235996c18e5c13dcef89c119626","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/nl.yml","hash":"1c44b3cb2f817808607f3bf6ef47f58ce7599995","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"08b913a5cf4cc160083069cb4dfb2d66eecd1218","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"8ddac820e2c17b484b56c0da8881e142b10e221b","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"ba7aff8f88e03f69a0acf7f1b90ee03e077ee88e","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"74701fcf2303d59400587436ab4c244e04df7ad9","modified":1572101194477},{"_id":"themes/hexo-theme-next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"7e8f3a41a68e912f2b2aaba905d314306ccaf794","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"dda0e6b2139decaf5e865d22ec9d45fdb615a703","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"d8a6cbf6f611c5d68d5da430cb6dc7010ff2c7e0","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"a6be69a90924c9d2f4d90fb4867234859bd2c2e9","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1572101194480},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1572101194490},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1572101194490},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1572101194490},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572101194487},{"_id":"source/_posts/C-类的案例/1.png","hash":"32e392b00a64d80dabac5bd439901132ccfe7b5a","modified":1572101194460},{"_id":"source/_posts/C-类的案例/2.png","hash":"e644f7b6a50cfb2b3bdb496593f3222c5c8953f2","modified":1572101194460},{"_id":"source/_posts/C-类的案例/步骤1.png","hash":"caa41a35be309bd173239043f905895ea4798b14","modified":1572101194460},{"_id":"source/_posts/C-类的案例/步骤二.png","hash":"0f66a8282a543cc0aaa7f4f500d02085a5e6b75e","modified":1572101194460},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c37a60580c901c79ccb22564b228a46e06207445","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/custom-issue-template.md","hash":"57e1e06e845193e80c7df4a4454af28352526f7a","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"07c423cce4157b8e2dbf60907ccbf3f18c4cf98a","modified":1572101194473},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE/non-english.md","hash":"0b0727ff4d5180ae67f930fb4f8e9488e33eda9f","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/ru/README.md","hash":"4d7ef717d0b57288e606996ee56c20ffd59d5a99","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"b218e30df4126b6adc87684775ac4c86ea7f7958","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"caa624092175d44e3d3a8c6ca23922718da2354c","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/CONTRIBUTING.md","hash":"bc43beb3af74d64fbd3920539d08861e4cadb9a0","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1572101194473},{"_id":"themes/hexo-theme-next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1572101194477},{"_id":"themes/hexo-theme-next/docs/zh-CN/README.md","hash":"cdd7a8bdcf4a83ff4c74ee6c95c6bcc0b8c1831c","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/MATH.md","hash":"83feca62190abcca0332915ffe0eefe582573085","modified":1572101194473},{"_id":"themes/hexo-theme-next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1572101194473},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"8a8a2865b09e933c454d9a68e54dd9063dc8c559","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"5352f96f4544c1520babf1cec7b44ddf2f8057b3","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"480d93619479dcfcbec6906803bb38b2dfbeae53","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/github-banner.swig","hash":"6357537ac0bb114aed4d61bafb39e6690a413697","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"589f545333e21a8c7823bce89ab45cf1eb7db6e2","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"50be1762f60222379a8bef5e42ab1a0f3872b7ff","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/exturl.swig","hash":"61ae10d41f67ece004a025077fdb28724af05090","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/next-boot.swig","hash":"012e3ece672cc3b13d5e032139f328d3426d7d65","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"83470eb401f78f4683907c48ad6760b90730daa3","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/scroll-cookie.swig","hash":"ccd13d73429ef91ef5e8b7d9fa43c8188facdf41","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/chatra.swig","hash":"eefb68b69b4b0ed558ee0324ccd711990059b20d","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/copy-code.swig","hash":"9be7c2c9cef63006866d1232c5289901e46be7ed","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/mermaid.swig","hash":"d6e6ddda836bd9e2e8d9767a910c7d3280080e81","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/pdf.swig","hash":"810a9b2a6059f46c4a2ddb178f1eaa4c5e23750b","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/quicklink.swig","hash":"5db80e8d7ea3f29e998320f79508f7e14342a33c","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/tidio.swig","hash":"912368c41de675f458b267a49a99ae3e7e420ebb","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/header.jpg","hash":"5cb93fb5a8f61cd54454743005bd696f00da6e65","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1572101194487},{"_id":"themes/hexo-theme-next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"f3b4f7ae7e58072bbf410d950a99a0b53cbc866d","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"d605918cf819887e9555212dbe12da97fd887a0b","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"fcb41c1c81560ed49dc4024654388a28ee7d32b0","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"598220fa92ff3540dcab74f633ba41523daa8364","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"00ca6340d4fe0ccdae7525373e4729117775bbfa","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/pdf.js","hash":"f780cc72bff91d2720626e7af69eed25e9c12a29","modified":1572101194480},{"_id":"themes/hexo-theme-next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1572101194480},{"_id":"source/_posts/MY_first_Blog/优势.png","hash":"c67641427b13ecdb8ee1381520771b710cc58402","modified":1572101194460},{"_id":"source/_posts/C-类的案例/3.png","hash":"9a418cc05389d3ee036d1766c4a76df4b0408824","modified":1572101194460},{"_id":"source/_posts/C-类的案例/流程图.jpg","hash":"cd6b0c88d9cddb6989f70003e33a0932ae4b8139","modified":1572101194460},{"_id":"source/_posts/ctime-的常用函数/Ctime.png","hash":"6ffe023ffa8c445d79813ab997bef99e997367ba","modified":1572101194463},{"_id":"source/_posts/ctime-的常用函数/time格式符.png","hash":"965003243e268bf7490f6646162071f56087b93f","modified":1572101194463},{"_id":"source/_posts/计算机网络安全原理-笔记/3.jpg","hash":"dee571e358523e8d80e2d0de75c7e766f5357c68","modified":1572101194467},{"_id":"source/_posts/计算机网络安全原理-笔记/1.jpg","hash":"928bb89d0a7c8566f16dc92b11fa18caa53be2a2","modified":1572101194467},{"_id":"source/_posts/计算机网络安全原理-笔记/2.jpg","hash":"20b625cb3c0f8d026770d0007cda938fd9a378bb","modified":1572101194467},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1572101194487},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/head/head-unique.swig","hash":"02bb5748e8540b024e7f4008a9e640890b45280f","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/head/head.swig","hash":"36eae78a4d7160a1c5e59ca3f7333f00b43d359b","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/post/reward.swig","hash":"d44f025eb93c99ddf90202d8293ccf80689a00c7","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/page/breadcrumb.swig","hash":"0fa4fadb39467b01cede49f21b22e86b1a2da805","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/header/brand.swig","hash":"648bf7eda66629592cb915c4004534b3913cbc22","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"5b05f165547391bf231e52f56f3d925efc09bc44","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_partials/share/likely.swig","hash":"b45e934d24d76ec6b6a790e92bdb3d56186b0e2a","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"e42604fbb17648484e5f12afe230d826de089388","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"0097e45e7b671f8006b8b2d3c4f95cacc76a983c","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1572101194477},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"d422beaf35a5d2646feaa098bc3e5adf691c7565","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"0dd5b315d1da55dbfc10f51a1f8952f72eba2720","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqusjs.swig","hash":"c77a2e7ef5f449a445fb4d36b055721fba4a81af","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitalk.swig","hash":"e8f91c571ceb4b80aafebc4d36b89fb41b1ae040","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"388efc86af7f19c05ad0e26720cd24ee012d20b9","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"2cbaae65a020bbb0e9265364488aff8bf84fa48d","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"4a908b613518878b9b69576c5dba4a5185f552ab","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/math/mathjax.swig","hash":"601774d8672577aefbcefac82c94b01f0338da31","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search.swig","hash":"0a13dfd2de52a96901039098c6fc7b515edfc50b","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1572101194480},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"2e8fb29aa92325df39054b5450757858c6cebc41","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"2036bbb73afd43251982ce824f06c6e88d35a2ef","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"640f25a63770af5566ccc9cec79c40a4f1c0b29e","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1572101194490},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1572101194490},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1572101194490},{"_id":"themes/hexo-theme-next/source/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1572101194487},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1572101194487},{"_id":"source/_posts/MY_first_Blog/功能.png","hash":"dade0e789db406f4c65e2ae2d40800be411a85ea","modified":1572101194463},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"fe5ff961b86004a306778c7d33a85b32e5e00e48","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"c8b3225396cb444d8baeb94bac78e5216b992a81","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"b98c65006e2546fbf3870c16fbbcbc009dbaab15","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"9d71f34fa13a41b8c8cd2fbdf3fdea608385277c","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"ce826aedf42b9eca424a044452f5d193866726a6","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/rainbow.styl","hash":"ce2aae8f3ed8ceac3a2417e0481044cf69c788aa","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/scrollbar.styl","hash":"d7b8bcf2a6031296c84bb4f4ecfb037af01d2d82","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"6d900b4159eeb869196a619602578bf4d83a117b","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"8e0740a9ad349ce5555122325da872923135a698","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"9a190ef2f49bdbf69604b48ad1dc7197895ee9b6","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"7ffde343bdf10add1f052f3c4308a15180eb4404","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"33456264a74d1bba38264d14713544d67d003733","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"9a2d298dbdcbfd758518fd74b63897bc80ce15a5","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"24230e46fc9fb7b8551f97bb36e9bc1f7423098e","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"75d2d92af070eb10273558b2436972d3f12b361c","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"a96e46a6ae86c423f932bc2bc78b9f7453e4e4e5","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"6565b4a309325596768d0d32e022c80ef23066cb","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"1edf4e69d0ec0dc9cefed6c35d3e803e0da4093d","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"7359880e8d85312861fe0871f58b662e627dae0c","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"57044a6d19eb418c1c3d28787e82c69efa9e0ca6","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"75737591682a2bafa71db4c03fb79e970ac0e7aa","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"b6dac5bbf20f090cf4b67d156f030d7170dfb39c","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"6400c98a9fd2b9a8502269f33355bd7ab3ff793b","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"232aedbd44243b3b80c4503c947060d3269c1afc","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1572101194490},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/github-banner.styl","hash":"ca97f0b6990eef947039faede80c56d9c4381ee1","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"cc6a9929a6bb7c90149ec340c24669c1c779b270","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"a410ed529afd46ddf4a96ecf0de6599488716887","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"71d8d1cc22a2a7627a6db7240f0c4902a14f9bea","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"e9dd8de7d98f1478ac7d351624fffd3d8738c905","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"cc6ee18f47f2e1e06df6fa0eadb37079e580fd11","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1572101194480},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"f1d52954b9a5d1ca8e224382349f525e598dd923","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"80addb9b725e329915c05c27b9fadaf56457a9b3","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"c961d37190d9bec58a36306c7e716c4e72c4582f","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"6a75bb1f2435f4e895cbbb5abbddf6e8f7257804","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"b082d07b13a3d55b4c032fd351dfa9a4fd74edec","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"1385862a5c0bd845015d165aadbd1a6add7b72d7","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"496f931e3a7e313ba8088fb91bb20789cace72c9","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reading_progress.styl","hash":"3f33bb862c2aa993f54987fbb345da067b79b112","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"5440013a081201ca791582db98159dce93ea9e75","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"d5c8ffed7f2c701052b7a53abaf5ef437374ea72","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"a3170630d8e085889a4bdc20eb7f09c5a0479c47","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"9224b566cd2632f64c1a964e2c786cee93b93286","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"cc83816614f21c7e1d8d3f867d547ff7c658cec4","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"707527c9950a7459355c8abcf4751c0964de0bc1","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-button.styl","hash":"517d541a80d59ad99a3f648be74891e0c7bc72a8","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"c2d9c3b6fbfa65544e6b5a55d3cb2149df04a8a9","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"8a24b56524a388fbabd408ffc8ba9b56eb9e01ce","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"8e5c884fb950937afa350c608545455c87aa6129","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"c01609176929590f8f347075a9a12b661acd661e","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"967fb3a3c6c851b34ec5df2d945dc266ed63d146","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"58ec00eebe68d0eebd2eea435c710063877447df","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"d7501ae01fc45fa15b00d1bc5233b9fffa20a3c9","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"fcda60fecff1479adaf6521cf629cda2506337a8","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"21b32840d8b3a14b10770153114778304ba6d1b0","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/pdf.styl","hash":"da8d34729fb6eb0fcb8ee81e67d2be3c02bc1bc4","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"cbc0be5a3285b469858ec9ead48e2ea90bd47ae1","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fc58498d4f5081fcf6218e9e18c5bf2328275bef","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/copy-code.styl","hash":"688ca3eccc26727d050ad098b32b40934719588a","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"f1d9ee1f86a179741f2478f8c70ca11ab578810e","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"9fac89c8146eb2675721a26f528d7d0f8be7debe","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/math.styl","hash":"ef66c0a08e4243a25e41408d70ca66682b8dcea1","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"61466e3e5459960b5802a267751a0c8018918b0b","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/related-posts.styl","hash":"3ae3f3c276d444862033fd3434c632ad0d2f84e6","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"03c4fa9573fddd930552784cf484fd2ee7825323","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1572101194483},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1572101194483},{"_id":"public/search.xml","hash":"6257085e943854a8273d47795a2df24d96b4f0e6","modified":1572256550446},{"_id":"public/categories/index-1.html","hash":"4651aa8c3424ce65856f3b3ef5eedfbb682a813d","modified":1572198807608},{"_id":"public/categories/index.html","hash":"4ffb714f7d1311480eb16ddfb32b3e0e1891fa83","modified":1572198807608},{"_id":"public/tags/index.html","hash":"ff507f6461e49b42d9dcbd9a4df17e9fe2db52ad","modified":1572198807608},{"_id":"public/2019/09/11/汇编语言基础/index.html","hash":"3b3ee5cb5655e2ef11591cf51b403aa6ee32cd02","modified":1572198807608},{"_id":"public/2019/07/05/Linxu-命令行/index.html","hash":"0f420cca59c5fba275e043582392fa0713d16847","modified":1572198807609},{"_id":"public/archives/page/3/index.html","hash":"cb321b5dbe4a2fc573aa20fa70a43e517065e69d","modified":1572198807609},{"_id":"public/archives/2019/page/3/index.html","hash":"7abe3cb9d2e55181d2fec841254cf5342961f5f4","modified":1572198807609},{"_id":"public/archives/2019/05/index.html","hash":"2205a1a2f39f0b449fa7d8b6aa63303a203be878","modified":1572198807609},{"_id":"public/archives/2019/06/index.html","hash":"ef486b3a838fe4c29f4cd352ece18c4956e197f3","modified":1572198807609},{"_id":"public/archives/2019/07/index.html","hash":"8e0ff1c149ff5c96cb3958e3a43f461c9f552f71","modified":1572198807609},{"_id":"public/archives/2019/08/index.html","hash":"edabfde4a58ff9ea8085772c7e99457b0747c897","modified":1572198807610},{"_id":"public/archives/2019/09/index.html","hash":"3b583bbc4f47bd74f9462664b006cfc78a44f1bf","modified":1572198807610},{"_id":"public/archives/2019/10/index.html","hash":"1202b1fbc4d238fa46480f3ba89acd33261aebd8","modified":1572198807611},{"_id":"public/categories/C/index.html","hash":"3294006b2b88d49b3eb9179eef9eb8133e5cf147","modified":1572198807611},{"_id":"public/categories/Linux/index.html","hash":"66c8a55b937c97031b8b61e5a95b321f0e0c5510","modified":1572198807611},{"_id":"public/page/3/index.html","hash":"4608755ee73126f0b1d24353d90f4d3317dc6344","modified":1572198807611},{"_id":"public/tags/note/index.html","hash":"2c8a7519054422cd525bf0d142a1242be1ee38fb","modified":1572198807611},{"_id":"public/2019/10/26/My-Computer/index.html","hash":"3f9fc824c62c5d70b7f48b27a94b75cc65de3a24","modified":1572256550468},{"_id":"public/2019/10/06/自学网络原理的第一天/index.html","hash":"4d328545930ee24f2de46ba5a37154659116b6d5","modified":1572198807611},{"_id":"public/2019/09/07/C-高级特性/index.html","hash":"3a209c7ebefafc758eb8143c772e3e3bb7dbaf75","modified":1572198807611},{"_id":"public/2019/08/20/计算机网络安全原理-笔记/index.html","hash":"b9864a4382a0c8109a07fa4242260875239bbc50","modified":1572198807611},{"_id":"public/2019/08/03/Qt-信号槽-对象树-Lambda/index.html","hash":"5a1218f5c0e29938667880435e98be234c0ecbce","modified":1572198807611},{"_id":"public/2019/08/03/Qt-快速入门-二/index.html","hash":"435488d2e7b26dfe75667d58b125f6b10f1ffbbd","modified":1572198807611},{"_id":"public/2019/08/03/Qt-快速入门-一/index.html","hash":"d8a33a423e14a8db3eecec47a38e1a658a876e3b","modified":1572198807611},{"_id":"public/2019/07/23/ctime-的常用函数/index.html","hash":"6452bd68c12e0cfe5573f19760a0e4802bded16f","modified":1572198807611},{"_id":"public/2019/07/09/暑假计划/index.html","hash":"4e1c47b3b1d55017da6b0534f12d9d60027826f0","modified":1572198807612},{"_id":"public/2019/06/08/Linux基本知识2/index.html","hash":"2c2745d0c391dccf6807a4083d88a8d70b12368f","modified":1572198807612},{"_id":"public/2019/06/05/Linux基本知识/index.html","hash":"6df63c82739236c5807016f4d6d4a02748104e37","modified":1572198807612},{"_id":"public/2019/06/04/C++ note3/index.html","hash":"4771bcd6f4a0f7ce639323a703e2a8179268511f","modified":1572198807612},{"_id":"public/2019/06/04/C++ note1-1/index.html","hash":"649d4f97bb24765682d8602e39210f75c73aee39","modified":1572198807612},{"_id":"public/2019/06/04/C++ note2/index.html","hash":"8662b0db05b57ee1182049e052d2834b99e33608","modified":1572198807612},{"_id":"public/2019/06/02/shell-note1/index.html","hash":"8b4ab40d705e454ef088242bc3fc3b696b77f68c","modified":1572198807612},{"_id":"public/2019/05/25/C-类的案例/index.html","hash":"28e10be94a530c0f38493a159d609d2f8d4a3e98","modified":1572198807612},{"_id":"public/2019/05/22/学习面向对象思想的小结/index.html","hash":"9290c7e70ff3eeda9cdc5431681d392827439ca4","modified":1572198807612},{"_id":"public/2019/05/09/shell快捷键大全/index.html","hash":"9272f9f15a365cf670a6118470eb603e22896bd8","modified":1572198807612},{"_id":"public/2019/05/06/MY_first_Blog/index.html","hash":"592e76896ee25b0350877afc847cc8517f58a0fe","modified":1572198807612},{"_id":"public/archives/index.html","hash":"ac361ac5b5f66a33ca0c28219f958ec5378772b7","modified":1572198807612},{"_id":"public/archives/page/2/index.html","hash":"5cb43953d751c6c5413d80ec166cb6920f209d80","modified":1572198807612},{"_id":"public/archives/2019/index.html","hash":"7a0eda2a33a5ac76885870c424858a2cbb8c884c","modified":1572198807613},{"_id":"public/archives/2019/page/2/index.html","hash":"89e1033a41443c9c9e3e533d4d32bdd7bc403b6e","modified":1572198807613},{"_id":"public/index.html","hash":"3847c1e059975717fad25a38fd52d91bd61273f0","modified":1572256550468},{"_id":"public/page/2/index.html","hash":"0c94f3066e2f5a20f44bb17520f585c058885857","modified":1572198807613},{"_id":"public/image/background.jpg","hash":"5cb93fb5a8f61cd54454743005bd696f00da6e65","modified":1572198807627},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1572198807627},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1572198807628},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1572198807628},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1572198807628},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1572198807628},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1572198807628},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1572198807628},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1572198807628},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1572198807628},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1572198807628},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1572198807628},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1572198807628},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1572198807628},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1572198807628},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1572198807628},{"_id":"public/images/header.jpg","hash":"5cb93fb5a8f61cd54454743005bd696f00da6e65","modified":1572198807628},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1572198807629},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1572198807629},{"_id":"public/images/searchicon.png","hash":"025d64ba0160a3a2257dd2b3032b5f7c9dd9b82b","modified":1572198807629},{"_id":"public/2019/05/25/C-类的案例/1.png","hash":"32e392b00a64d80dabac5bd439901132ccfe7b5a","modified":1572198807629},{"_id":"public/2019/05/25/C-类的案例/3.png","hash":"9a418cc05389d3ee036d1766c4a76df4b0408824","modified":1572198807629},{"_id":"public/2019/05/25/C-类的案例/步骤1.png","hash":"caa41a35be309bd173239043f905895ea4798b14","modified":1572198807629},{"_id":"public/2019/05/25/C-类的案例/步骤二.png","hash":"0f66a8282a543cc0aaa7f4f500d02085a5e6b75e","modified":1572198807629},{"_id":"public/2019/05/06/MY_first_Blog/优势.png","hash":"c67641427b13ecdb8ee1381520771b710cc58402","modified":1572198808068},{"_id":"public/2019/07/23/ctime-的常用函数/time格式符.png","hash":"965003243e268bf7490f6646162071f56087b93f","modified":1572198808071},{"_id":"public/2019/08/20/计算机网络安全原理-笔记/2.jpg","hash":"20b625cb3c0f8d026770d0007cda938fd9a378bb","modified":1572198808071},{"_id":"public/2019/08/20/计算机网络安全原理-笔记/3.jpg","hash":"dee571e358523e8d80e2d0de75c7e766f5357c68","modified":1572198808071},{"_id":"public/2019/05/25/C-类的案例/2.png","hash":"e644f7b6a50cfb2b3bdb496593f3222c5c8953f2","modified":1572198808071},{"_id":"public/2019/05/25/C-类的案例/流程图.jpg","hash":"cd6b0c88d9cddb6989f70003e33a0932ae4b8139","modified":1572198808071},{"_id":"public/js/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1572198808077},{"_id":"public/js/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1572198808077},{"_id":"public/js/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1572198808078},{"_id":"public/js/js.cookie.js","hash":"e0afce539f1fb81d59e3c6f0a68d736e2fb45d93","modified":1572198808078},{"_id":"public/js/motion.js","hash":"a16bc0b701646bf6653484675f4d5dc0f892d184","modified":1572198808078},{"_id":"public/js/next-boot.js","hash":"e0615efab5f81ba0fd39c0527eac31144deac7ce","modified":1572198808078},{"_id":"public/js/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1572198808079},{"_id":"public/js/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1572198808079},{"_id":"public/js/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1572198808079},{"_id":"public/js/utils.js","hash":"81913c5f75d0949443833cf4269ad63bd7f9be6f","modified":1572198808079},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1572198808079},{"_id":"public/js/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1572198808079},{"_id":"public/js/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1572198808079},{"_id":"public/css/main.css","hash":"832df5ba52ccca188adae5768df293ce362f4201","modified":1572198808079},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1572198808080},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1572198808080},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1572198808080},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1572198808080},{"_id":"public/2019/07/23/ctime-的常用函数/Ctime.png","hash":"6ffe023ffa8c445d79813ab997bef99e997367ba","modified":1572198808081},{"_id":"public/2019/08/20/计算机网络安全原理-笔记/1.jpg","hash":"928bb89d0a7c8566f16dc92b11fa18caa53be2a2","modified":1572198808085},{"_id":"public/2019/05/06/MY_first_Blog/功能.png","hash":"dade0e789db406f4c65e2ae2d40800be411a85ea","modified":1572198808092}],"Category":[{"name":"C++","_id":"ck29akptf00047qsgevnp151x"},{"name":"Linux","_id":"ck29akpu0000m7qsg9h1wkq9g"}],"Data":[],"Page":[{"title":"C++","date":"2019-06-02T12:25:29.000Z","type":"categories","_content":"","source":"categories/index-1.md","raw":"---\ntitle: C++\ndate: 2019-06-02 20:25:29\ntype:  \"categories\"\n---\n","updated":"2019-10-26T14:46:34.467Z","path":"categories/index-1.html","comments":1,"layout":"page","_id":"ck29akptb00017qsgew3k4pn5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Linux","date":"2019-06-02T12:12:44.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: Linux\ndate: 2019-06-02 20:12:44\ntype:  \"categories\"\n---\n","updated":"2019-10-26T14:46:34.467Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ck29akpte00037qsg4x4fbv8d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"note","date":"2019-06-02T12:23:11.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: note\ndate: 2019-06-02 20:23:11\ntype: \"tags\"\n---\n","updated":"2019-10-26T14:46:34.467Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ck29akptj00067qsg4e1n6t6d","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"C++类的案例","date":"2019-05-25T07:48:43.000Z","_content":"\n前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。\n\n<!--more-->\n\n# **项目截图**  \n\n下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)\n\n---\n\n![游戏界面1](C-类的案例\\1.png \"玩家出牌\")\n\n![游戏界面1](C-类的案例\\2.png \"比大小结果\")\n\n![游戏界面1](C-类的案例\\3.png \"胜负判定\")\n\n## **做项目需要的思维及流程图**\n\n这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ\n\n这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。\n\n- 下面是写流程图需要思考的一些东西：\n\n>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。  \n>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；  \n>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。\n>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。\n\n- 扑克牌之比大小流程图\n    - 进入游戏\n    - 展示游戏界面\n    - 开始游戏\n    - 游戏进行中\n    - 游戏输赢判定\n    - 提示是否继续游戏 继续就循环，否则退出游戏\n\n额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。\n\n![简易的流程图](C-类的案例\\流程图.jpg \"流程图\")\n\n### **项目的实现以及经验**\n\n> 主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    \n>> 在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。  \n>>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。   \n>>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。\n\n#### **项目的源代码**\n\n源代码已经开放，点击[项目源代码](https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast)即可。\n\n点进去直接打开源文件直接copy就行了\n\n注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。\n\n![](C-类的案例\\步骤1.png)\n\n\n![](C-类的案例\\步骤二.png)\n\n教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个[链接](https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html)。\n\n\n\n如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓\n\n","source":"_posts/C-类的案例.md","raw":"---\ntitle: C++类的案例\ndate: 2019-05-25 15:48:43\ntags:\ncategories: C++\n---\n\n前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。\n\n<!--more-->\n\n# **项目截图**  \n\n下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)\n\n---\n\n![游戏界面1](C-类的案例\\1.png \"玩家出牌\")\n\n![游戏界面1](C-类的案例\\2.png \"比大小结果\")\n\n![游戏界面1](C-类的案例\\3.png \"胜负判定\")\n\n## **做项目需要的思维及流程图**\n\n这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ\n\n这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。\n\n- 下面是写流程图需要思考的一些东西：\n\n>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。  \n>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；  \n>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。\n>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。\n\n- 扑克牌之比大小流程图\n    - 进入游戏\n    - 展示游戏界面\n    - 开始游戏\n    - 游戏进行中\n    - 游戏输赢判定\n    - 提示是否继续游戏 继续就循环，否则退出游戏\n\n额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。\n\n![简易的流程图](C-类的案例\\流程图.jpg \"流程图\")\n\n### **项目的实现以及经验**\n\n> 主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    \n>> 在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。  \n>>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。   \n>>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。\n\n#### **项目的源代码**\n\n源代码已经开放，点击[项目源代码](https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast)即可。\n\n点进去直接打开源文件直接copy就行了\n\n注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。\n\n![](C-类的案例\\步骤1.png)\n\n\n![](C-类的案例\\步骤二.png)\n\n教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个[链接](https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html)。\n\n\n\n如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓\n\n","slug":"C-类的案例","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpt600007qsg46tbkz9n","content":"<p>前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。</p>\n<a id=\"more\"></a>\n<h1 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a><strong>项目截图</strong></h1><p>下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)</p>\n<hr>\n<p><img src=\"/2019/05/25/C-类的案例/1.png\" alt=\"游戏界面1\" title=\"玩家出牌\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/2.png\" alt=\"游戏界面1\" title=\"比大小结果\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/3.png\" alt=\"游戏界面1\" title=\"胜负判定\"></p>\n<h2 id=\"做项目需要的思维及流程图\"><a href=\"#做项目需要的思维及流程图\" class=\"headerlink\" title=\"做项目需要的思维及流程图\"></a><strong>做项目需要的思维及流程图</strong></h2><p>这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ</p>\n<p>这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。</p>\n<ul>\n<li>下面是写流程图需要思考的一些东西：</li>\n</ul>\n<blockquote>\n<p>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。<br>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；<br>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。<br>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。</p>\n</blockquote>\n<ul>\n<li>扑克牌之比大小流程图<ul>\n<li>进入游戏</li>\n<li>展示游戏界面</li>\n<li>开始游戏</li>\n<li>游戏进行中</li>\n<li>游戏输赢判定</li>\n<li>提示是否继续游戏 继续就循环，否则退出游戏</li>\n</ul>\n</li>\n</ul>\n<p>额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。</p>\n<p><img src=\"/2019/05/25/C-类的案例/流程图.jpg\" alt=\"简易的流程图\" title=\"流程图\"></p>\n<h3 id=\"项目的实现以及经验\"><a href=\"#项目的实现以及经验\" class=\"headerlink\" title=\"项目的实现以及经验\"></a><strong>项目的实现以及经验</strong></h3><blockquote>\n<p>主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    </p>\n<blockquote>\n<p>在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。<br>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。<br>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"项目的源代码\"><a href=\"#项目的源代码\" class=\"headerlink\" title=\"项目的源代码\"></a><strong>项目的源代码</strong></h4><p>源代码已经开放，点击<a href=\"https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast\" target=\"_blank\" rel=\"noopener\">项目源代码</a>即可。</p>\n<p>点进去直接打开源文件直接copy就行了</p>\n<p>注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。</p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤1.png\" alt></p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤二.png\" alt></p>\n<p>教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个<a href=\"https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓</p>\n","site":{"data":{}},"excerpt":"<p>前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。</p>","more":"<h1 id=\"项目截图\"><a href=\"#项目截图\" class=\"headerlink\" title=\"项目截图\"></a><strong>项目截图</strong></h1><p>下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ)</p>\n<hr>\n<p><img src=\"/2019/05/25/C-类的案例/1.png\" alt=\"游戏界面1\" title=\"玩家出牌\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/2.png\" alt=\"游戏界面1\" title=\"比大小结果\"></p>\n<p><img src=\"/2019/05/25/C-类的案例/3.png\" alt=\"游戏界面1\" title=\"胜负判定\"></p>\n<h2 id=\"做项目需要的思维及流程图\"><a href=\"#做项目需要的思维及流程图\" class=\"headerlink\" title=\"做项目需要的思维及流程图\"></a><strong>做项目需要的思维及流程图</strong></h2><p>这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ</p>\n<p>这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。</p>\n<ul>\n<li>下面是写流程图需要思考的一些东西：</li>\n</ul>\n<blockquote>\n<p>1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。<br>2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；<br>3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。<br>4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。</p>\n</blockquote>\n<ul>\n<li>扑克牌之比大小流程图<ul>\n<li>进入游戏</li>\n<li>展示游戏界面</li>\n<li>开始游戏</li>\n<li>游戏进行中</li>\n<li>游戏输赢判定</li>\n<li>提示是否继续游戏 继续就循环，否则退出游戏</li>\n</ul>\n</li>\n</ul>\n<p>额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。</p>\n<p><img src=\"/2019/05/25/C-类的案例/流程图.jpg\" alt=\"简易的流程图\" title=\"流程图\"></p>\n<h3 id=\"项目的实现以及经验\"><a href=\"#项目的实现以及经验\" class=\"headerlink\" title=\"项目的实现以及经验\"></a><strong>项目的实现以及经验</strong></h3><blockquote>\n<p>主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。    </p>\n<blockquote>\n<p>在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。<br>培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。<br>在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"项目的源代码\"><a href=\"#项目的源代码\" class=\"headerlink\" title=\"项目的源代码\"></a><strong>项目的源代码</strong></h4><p>源代码已经开放，点击<a href=\"https://github.com/178me/Case_cj/tree/master/Poker_Size_contrast\" target=\"_blank\" rel=\"noopener\">项目源代码</a>即可。</p>\n<p>点进去直接打开源文件直接copy就行了</p>\n<p>注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。</p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤1.png\" alt></p>\n<p><img src=\"/2019/05/25/C-类的案例/步骤二.png\" alt></p>\n<p>教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个<a href=\"https://jingyan.baidu.com/article/e73e26c0da3c0224adb6a731.html\" target=\"_blank\" rel=\"noopener\">链接</a>。</p>\n<p>如果有能力的同学可以扩展或者写一个更好(　o=^•ェ•)o　┏━┓</p>"},{"title":"C++ note1","date":"2019-06-04T08:47:09.000Z","_content":"函数的一些积累\n\n<!--more-->  \n\n常用头文件\n---\n**#include <iostream> -> 包含头文件:输入输出流**  \n详情了解cin请点击[传送门](https://blog.csdn.net/weixin_41042404/article/details/80934191)  \n\n\n**using namespace std -> std命名空间**  \n\n**#include <vector> -> 包含向量的头文件**\n\n**#include <algorithm> -> 包含排序方法**   \nsort() -> 数组升序排序  \nreverse() -> 数组逆序排序\n\n**#include <iterator> -> 迭代器**  \n\n**#include <iomanip> -> 设置输出格式**  \n```\nsetw(2)  //设置字符宽度为2个字节  \nsetiosflags(ios::left)  //设置文字左对齐\n\n```\n**#include <string> -> 字符串操作**  \n\n```\n#include <string>\nstring s;      //定义string对象s\ns.length()     //返回字符串长度，即字符个数\ns.empty()      //判读字符串是否为空串\ns.at(i)        //返回字符串的第i个字符\ns[i]           //等同于s.at(i)\ns.substr(int i,int j)     //获取从i到j的字符串\n其他方法\ngetline(cin\\cout,变量)    //输入或输出变量\n```\n常用函数  \n---\n> **[memset()](https://blog.csdn.net/qq_22122811/article/details/52738029)** -> 数组初始化函数\n\n\n\n","source":"_posts/C++ note1-1.md","raw":"---\ntitle: C++ note1\ndate: 2019-06-04 16:47:09\ntags: note\ncategories: C++\n---\n函数的一些积累\n\n<!--more-->  \n\n常用头文件\n---\n**#include <iostream> -> 包含头文件:输入输出流**  \n详情了解cin请点击[传送门](https://blog.csdn.net/weixin_41042404/article/details/80934191)  \n\n\n**using namespace std -> std命名空间**  \n\n**#include <vector> -> 包含向量的头文件**\n\n**#include <algorithm> -> 包含排序方法**   \nsort() -> 数组升序排序  \nreverse() -> 数组逆序排序\n\n**#include <iterator> -> 迭代器**  \n\n**#include <iomanip> -> 设置输出格式**  \n```\nsetw(2)  //设置字符宽度为2个字节  \nsetiosflags(ios::left)  //设置文字左对齐\n\n```\n**#include <string> -> 字符串操作**  \n\n```\n#include <string>\nstring s;      //定义string对象s\ns.length()     //返回字符串长度，即字符个数\ns.empty()      //判读字符串是否为空串\ns.at(i)        //返回字符串的第i个字符\ns[i]           //等同于s.at(i)\ns.substr(int i,int j)     //获取从i到j的字符串\n其他方法\ngetline(cin\\cout,变量)    //输入或输出变量\n```\n常用函数  \n---\n> **[memset()](https://blog.csdn.net/qq_22122811/article/details/52738029)** -> 数组初始化函数\n\n\n\n","slug":"C++ note1-1","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akptc00027qsglttid4br","content":"<p>函数的一些积累</p>\n<a id=\"more\"></a>  \n<h2 id=\"常用头文件\"><a href=\"#常用头文件\" class=\"headerlink\" title=\"常用头文件\"></a>常用头文件</h2><p><strong>#include <iostream> -&gt; 包含头文件:输入输出流</iostream></strong><br>详情了解cin请点击<a href=\"https://blog.csdn.net/weixin_41042404/article/details/80934191\" target=\"_blank\" rel=\"noopener\">传送门</a>  </p>\n<p><strong>using namespace std -&gt; std命名空间</strong>  </p>\n<p><strong>#include <vector> -&gt; 包含向量的头文件</vector></strong></p>\n<p><strong>#include <algorithm> -&gt; 包含排序方法</algorithm></strong><br>sort() -&gt; 数组升序排序<br>reverse() -&gt; 数组逆序排序</p>\n<p><strong>#include <iterator> -&gt; 迭代器</iterator></strong>  </p>\n<p><strong>#include <iomanip> -&gt; 设置输出格式</iomanip></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setw(2)  //设置字符宽度为2个字节  </span><br><span class=\"line\">setiosflags(ios::left)  //设置文字左对齐</span><br></pre></td></tr></table></figure></p>\n<p><strong>#include <string> -&gt; 字符串操作</string></strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">string s;      //定义string对象s</span><br><span class=\"line\">s.length()     //返回字符串长度，即字符个数</span><br><span class=\"line\">s.empty()      //判读字符串是否为空串</span><br><span class=\"line\">s.at(i)        //返回字符串的第i个字符</span><br><span class=\"line\">s[i]           //等同于s.at(i)</span><br><span class=\"line\">s.substr(int i,int j)     //获取从i到j的字符串</span><br><span class=\"line\">其他方法</span><br><span class=\"line\">getline(cin\\cout,变量)    //输入或输出变量</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数  \"></a>常用函数  </h2><blockquote>\n<p><strong><a href=\"https://blog.csdn.net/qq_22122811/article/details/52738029\" target=\"_blank\" rel=\"noopener\">memset()</a></strong> -&gt; 数组初始化函数</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>函数的一些积累</p>","more":"<h2 id=\"常用头文件\"><a href=\"#常用头文件\" class=\"headerlink\" title=\"常用头文件\"></a>常用头文件</h2><p><strong>#include <iostream> -&gt; 包含头文件:输入输出流</iostream></strong><br>详情了解cin请点击<a href=\"https://blog.csdn.net/weixin_41042404/article/details/80934191\" target=\"_blank\" rel=\"noopener\">传送门</a>  </p>\n<p><strong>using namespace std -&gt; std命名空间</strong>  </p>\n<p><strong>#include <vector> -&gt; 包含向量的头文件</vector></strong></p>\n<p><strong>#include <algorithm> -&gt; 包含排序方法</algorithm></strong><br>sort() -&gt; 数组升序排序<br>reverse() -&gt; 数组逆序排序</p>\n<p><strong>#include <iterator> -&gt; 迭代器</iterator></strong>  </p>\n<p><strong>#include <iomanip> -&gt; 设置输出格式</iomanip></strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setw(2)  //设置字符宽度为2个字节  </span><br><span class=\"line\">setiosflags(ios::left)  //设置文字左对齐</span><br></pre></td></tr></table></figure></p>\n<p><strong>#include <string> -&gt; 字符串操作</string></strong>  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;string&gt;</span><br><span class=\"line\">string s;      //定义string对象s</span><br><span class=\"line\">s.length()     //返回字符串长度，即字符个数</span><br><span class=\"line\">s.empty()      //判读字符串是否为空串</span><br><span class=\"line\">s.at(i)        //返回字符串的第i个字符</span><br><span class=\"line\">s[i]           //等同于s.at(i)</span><br><span class=\"line\">s.substr(int i,int j)     //获取从i到j的字符串</span><br><span class=\"line\">其他方法</span><br><span class=\"line\">getline(cin\\cout,变量)    //输入或输出变量</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用函数\"><a href=\"#常用函数\" class=\"headerlink\" title=\"常用函数  \"></a>常用函数  </h2><blockquote>\n<p><strong><a href=\"https://blog.csdn.net/qq_22122811/article/details/52738029\" target=\"_blank\" rel=\"noopener\">memset()</a></strong> -&gt; 数组初始化函数</p>\n</blockquote>"},{"title":"C++ note3","date":"2019-06-04T08:47:12.000Z","_content":"关于面向对象编程的笔记  \n\n<!--more-->  \n\n# **面向对象**  \n---  \n> **new 动态内存分配**  \n```\nint* i = new int;   //类型*变量 = new 类型\nint* ip = new int[5];//分配数组\nint* (*ip)[5] = new int[5][4]   //分配多维数组\ndelete [] ip;   //数组的销毁方式\n/**思考题\n *1、new如何动态分配多维数组？\n    int (*ipp)[4] = new int[5][4];\n *2、分配出来的多维数组如何销毁？\n    delete[] ipp;\n **/\ndelete i;   //销毁地址\n```\n>  常见错误\n- 忘记销毁new出来的地址，会造成内存泄露  \n- 多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  \n```\nif(ip){\n    delete ip;\n    ip = 0;\n}\n```\n- 销毁一段非new分配的内存  \n- 使用被delete的内存  \n- 务必要记住，new和delete必须要成对使用  \n- new的对象不要盲目使用自增运算符  \n- 取值运算需要加上取值操作符\\*  \n---\n>  **默认参数**  \n- C++函数中可以带有默认参数  \n```\ndouble Add(int num1,int num2 = 0){\n    return num1 + num2;\n}\n· 所有参数都可以具有默认参数\n· 默认参数必须从最右边开始\n· 不可以使用形参作为默认参数\n· 一般来说，默认参数一般使用在函数参数很多的情况下，\n它避免了函数调用者必须记住太多太长的参数\n```\n>  **可变参数**  \n- C\\++提供一种“可变参数”的机制，即允许参数的数目是可变的。  \n```\n/* 要定义一个支持可变参数的函数，需要用到头文件<cstd\narg>中的一些东西 */\n#include <iostream>\n#include <cstdarg>\nusing namespace std;\nint Add(int first...);\n\nint main() {\n\tint sum = Add(11, 22, 33, -1);\n}\nint Add(int first...) {\n\t//准备读取可变参数\n\tva_list nums;\n\tva_start(nums, first);   \n\t//使用<cstdarg>中的va_xxx宏函数处理可变参数\n\tint sum = 0;\n\tint num = first;\n\t//依次读取参数，-1表示结束\n\twhile (num != -1) {\n\t\tcout << \"+\" << num << endl;\n\t\tsum += num;\n\t\tnum = va_arg(nums, int);\n\t}\n\tva_end(nums);\n\treturn sum;\n}\n------------\n以上主要思想是使用va_xxx读取参数列表，并进行加和。遇\n到-1结束，可变参数处理起来比较麻烦。\n```\n>  **内联函数**  \n- 在进行函数调用前，会将调用函数的地址和参数列表等信息\n保留在堆栈中，以便在函数执行结束后，可以返回到原先调\n用的程序继续执行。因此对于某些频繁调用的小型函数来说\n，这些堆栈存取动作，会降低的程序的执行效率，此时即可\n使用内敛函数解决问题。  \n内联函数允许函数内部的内容正在调用点直接展开，这样就\n避免了传统调用函数过程带来的性能损失。\n```\ninline int add(int,int);\nvoid add(int a,int b){\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n}\nint main(){\n    add(1,2);\n    /*编译器会改写成*/\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n    ----------\n    实际上，inline只是对编译器进行优化的一个建议，\n    编译器完全可能会不理会该建议，所以，不要滥用inl\n    ine函数\n}\n```\n>  **函数重载**  \n- 函数名相同，参数列表不同，就是函数的重载特性\n```\n函数重载经常出现的错误示例：\nint add(int a){\n    return a；\n}\nfloat add(int a){\n    return a\n}\n//不能依赖于返回值的类型不同选定一个函数\n//实参与形参类型不同\n//不要认为的制造二义性冲突，例如\nint add(int a){\n    return a;\n}\nint add(int a,int b = 10){\n    return a + b; \n}\n```\n- 安全连接和名字重组自行百度了解  \n  \n> **递归函数**  \n- 函数自己调用自己，即递归函数\n```\n#include <iostream>\nusing namespace std;\n\nvoid test(int);\n\nint main() {\n\ttest(10);\n}\nvoid test(int num1) {\n\tcout << \"函数开始\" << endl;\n\tif (num1 == 0) return;\n\ttest(num1 / 2);\n\tcout << \"函数结束\" << endl;\n}\n输出结果如下:\n函数开始\n函数开始\n函数开始\n函数开始\n函数开始\n函数结束\n函数结束--gg\n函数结束\n函数结束\n--------------\n个人是这样理解的,递归就是一个函数嵌套的过程，像上面\n的程序有五个函数开始，这是在执行递归之前的语句，也\n就是说算上第一次进入函数，这个函数执行了五次，但对\n应的函数结束却只出现了四次，那是因为最后一次执行了 \nreturn语句，直接跳出了函数，也就没有后面的语句的执\n行。结合理解使用调试功能进行观察效果会更好。\n```\n\n> **函数指针**  \n- 在C++中提供函数指针，它用以指向一个函数  \n\n```\nvoid (*fp)();   //声明一个类型为void，没有参数的函数指针\nfp = &add;  //指向add函数的地址\nfp = add    //等同与指向\n//调用的方法\nfp();       //相当于add()\n(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用\n\n```\n\n- 理解函数指针\n\n```\n#include <iostream>\nusing namespace std;\n\nint add(int a ,int b) {\n\treturn a + b;\n}\nint min(int a, int b);\nint main() {\n\tvoid (*fp1)(int);\n\tint (*fp2)(int, int);\n\tcout << typeid(fp1).name() << endl;\n\tcout << typeid(fp2).name() << endl;\n\tcout << typeid(add).name() << endl;\n\tcout << typeid(min).name() << endl;\n}\nint min(int a, int b) {\n\treturn a - b;\n}\n------------\n利用typeid输出函数指针类型来理解它\n根据这样的特性，我们可以定义函数指针数字组\nint (*fp[])(int ,int ) = {&add,&min}\n函数指针的定义有点繁琐，建议用typedef来改善可读性。\ntypedef int (*fp)(int,int);\nfp fp1 = add;\nfp fp2 = &min;\nfp fp3[] = {&add,&min};\n```\n\n- 函数与值传递  \n\n```\n·值传递有三种方式：传值方式，引用方式，传址方式\n\n·向函数传递参数的时候，除了引用方式外，其他方式都是\n在函数内部将参数内容复制一份使用。\n```\n> **类的设计**\n- 类是对象的类型，对象是类的实例  \n- 类的设计  \n\n```\n· 类的语法定义：\nclass 类名{\n访问控制符:\n    成员列表\n};\n· 类也可以先声明后定义，声明方式如下\nclass 类名;\n· 对象的定义\n类名 对象名;\n类名 * 对象名 = new 类名();\n//类的两种实例化方法\n还可以定义类对象的指针和引用\n类名 * 指针名 = &对象名;\n类名 & 引用名 = 对象名;\n· 数据成员的访问\n可以使用\".\"来访问数据成员\n对象指针用\"->\"来访问\n还支持用\"::\"域名操作符访问成员，但常用以上两种\n· 成员访问控制\n访问控制符一般包括两种\npublic:共有的，可以在任意地方访问成员\nprivate:私有的，只能在类的内部访问成员\n有一种不成文的规矩，就是把私有的数据成员加上下划线\n· 成员函数\n成员函数其实与普通的函数没有太大的差别，它可以被内\n联，也可以被重载，也可以使用默认参数，唯一的区别就\n是定义是要加上类域的帽子，但声明不需要，如\nclass A{\n    void a();\n};\nvoid A :: a(){  //数据类型 所属类名 :: 函数名\n    cout << \"我属于A类\" << endl;\n}\n· this指针\n在成员函数体内，有一种特殊的指针，this指针。this指\n针指向当前类对象本身，可以用this调用对象的成员：\nthis -> a();\n注意:this不能被改变，也不能在类作用域以外的地方使用\n· 内存中的类\n类包括数据成员和成员函数，但内存中的类只包括其数据\n成员，成员函数其实并不属于对象，它只是一个特殊的全\n局函数。\n· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\n\tint a;\n\tint b;\n\tchar c;\n\tchar d;\n};\nclass B {\npublic:\n\tint a;\n\tchar c;\n\tint b;\n\tchar d;\n};\nint main() {\n\tcout << sizeof(A) << endl;\n\tcout << sizeof(B) << endl;\n}\n输出如下：\n12\n16\n为了程序运行的效率，编译器在一定的设置下可能对成员\n排放位置做一些调整，使得整个结构体为一个字节长的整\n数倍，这就是所谓的“字节对齐”，上面演示了这种布局的\n差异，可以看出来，，不同的排列方式会引起类字节长度\n的差别，大家写代码一定要考虑这一点。\n```\n\n- UML类图可以表示一个类，便于理解，如  \n- 私有是\"-\"前缀，共有则是\"+\"前缀  \n\n|类名|  \n|:-:|\n|数据成员|\n|函数成员|\n\n\n\n\n\n>  **类的讨论**  \n\n```\n· 类与结构\nC++中提供结构和类。在数据成员上，它们唯一的差别在于\n：结构成员的默认访问控制为public，类的默认访问控制\n为private。\nclass是一个全新的概念，所以人们更愿意接受class是真\n正的面向对象概念。而对于struct，人们更愿意用来描述\n那些没有行为或者行为能力很弱的数据结构体。\n· 抽象性\n在软件开发的分析、设计时对具体问题进行归纳、概括，\n并将这一类对象的公共特性加以条理化和严格描述，它主\n张集中思想和精力，考虑关键、主要、实质性的问题，去\n掉非主要的部分，便于开发人员对整个问题准确地认识。\n为具体的对象定义一个类的过程就是抽象。\n· 封装性\n保证程序员用正确的方式操作对象，并将一些操作细节隐\n藏起来。主要体现如下方面:\n--- 保护私有数据:不允许外部程序直接访问私有的数据\n--- 隐藏了操作细节:提供公用成员函数提供外部调用\n根据这两个方面,我们可以举一个例子来说明:\n#include <iostream>\nusing namespace std;\nclass A {\n\t/**\n\t *声明一个A类，包含两个数据成员并封装成4个成员函数\n\t *这里使用this指针加深印象\n\t **/\n\tstring _name;\n\tstring _sex;\npublic:\n\tvoid setname(string name) { \n\t\tthis ->_name = name; \n\t}\n\tvoid setsex(string sex) { \n\t\tthis->_sex = sex;\n\t}\n\tstring getname() { return this ->_name; }\n\tstring getsex() { return this ->_sex; }\n};\nint main() {\n\t/**\n\t *使用指针的方法实例化A的一个对象\n\t *定义两个string临时变量\n\t *调用公共的数据成员封装函数进行赋值和输出\n\t **/\n\tA * a1 = new A();\n\tstring temp1,temp2;\n\tcout << \"请输入你的姓名\";\n\tcin >> temp1;\n\ta1->setname(temp1);\n\tcout << \"请输入你的性别\";\n\tcin >> temp2;\n\ta1->setsex(temp2);\n\tcout << \"姓名:\" << a1->getname() << endl;\n\tcout << \"性别:\" << a1->getsex() << endl;\n}\n程序员的责任就是封装复杂的数据和操作，以简单明了的\n共有函数的方式为外部程序提供对象操作接口\n```\n    \n# 类的封装性  \n\n封装性保证程序员通过正确的方式操作对象，并将操作的细节隐藏起来。\n\n- 保护私有数据：不允许外部程序访问私有的数据  \n\n- 隐藏了操作细节：提供公共方法，以供外部程序调用  \n\n## 注意点  \n\n1. 类的组合  \n\n类的数据成员可以是基本类型、复合类型、或者是一个自定义类的对象。\n\n2. 类的声明  \n\n要在调用类之前先声明这个类\n\n# 构造函数  \n\n是一个有特殊的成员函数，定义类的实例被隐式调用\n\n- 函数名与类名一致\n\n- 与正常的函数规则一致，可重载但不能有返回值例如，可以带有参数，默认值等\n\n- 一般用来初始化数据 \n\n- 没有定义构造函数时C++会自动创建默认构造函数  \n\n## 成员初始值列表  \n\n构造函数的特有的初始化方式。用以指定在调用该构造函数是完成的初始化序列\n\n以：引起，多个值以，间隔;初始化语句写成()形式\n\n# 析构函数  \n\n是与构造函数相反的一个特殊函数，销毁对象或某个对象离开作用域时会调用析构函数。\n\n- 以～引起，函数名与类名一致  \n\n- 没有返回值，参数列表为空  \n\n- 一般用来销毁对象  \n\n- 没有定义时会自动创建默认析构函数  \n\n# 转换构造函数  \n\n当某个构造函数只有一个参数，而该参数又不是本类的const引用，称为转换构造函数  \n\n## explicit  \n\n不允许显式调用函数  \n\n# 拷贝构造函数  \n\n拷贝构造函数即复制一个对象。 \n\n# 操作符重载  \n\n为类定义操作符函数  \n\n例：如果一个对象将 ～操作符 重载，则～a等同于a.operator~()\n\n## 注意点\n\n1. 操作符重载函数可以有形参  \n\n2. 一元操作符不能混当二元操作符使用，同理，二元也一样。\n\n3. 对于查找顺序来说，编译器会先查找对象操作符的重载，再去查找全局操作符的重载\n\n4. 类型转换：将对象转换成对应的类型，如：Actor::operator string()\n\n# const \n\n用来指示某个变量不能被修改  \n\n如果在对象实例前加上const，那么你就只能使用const类型的成员函数  \n\n# mutable  \n\n用来修饰数据成员，表示可变的。   \n\n加了const的函数遇到使用mutable数据成员的修改会忽略它。  \n\n# 友元  \n\n当一个类或一个函数声明为另一个类的朋友时，它就可以访问该类的私有成员\n\n## 注意点  \n\n1. 使用友元在前面加上friend  \n\n2. 注意声明的顺序  \n\n3. 如果A类声明B类为友元，那么B类可以访问A类的私有数据成员，A类则不能访问B类  \n\n4. 友元在一定程度上破坏了类的封装性，尽量不要过多使用  \n\n\n\n","source":"_posts/C++ note3.md","raw":"---\ntitle: C++ note3\ndate: 2019-06-04 16:47:12\ntags: note\ncategories: C++\n---\n关于面向对象编程的笔记  \n\n<!--more-->  \n\n# **面向对象**  \n---  \n> **new 动态内存分配**  \n```\nint* i = new int;   //类型*变量 = new 类型\nint* ip = new int[5];//分配数组\nint* (*ip)[5] = new int[5][4]   //分配多维数组\ndelete [] ip;   //数组的销毁方式\n/**思考题\n *1、new如何动态分配多维数组？\n    int (*ipp)[4] = new int[5][4];\n *2、分配出来的多维数组如何销毁？\n    delete[] ipp;\n **/\ndelete i;   //销毁地址\n```\n>  常见错误\n- 忘记销毁new出来的地址，会造成内存泄露  \n- 多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  \n```\nif(ip){\n    delete ip;\n    ip = 0;\n}\n```\n- 销毁一段非new分配的内存  \n- 使用被delete的内存  \n- 务必要记住，new和delete必须要成对使用  \n- new的对象不要盲目使用自增运算符  \n- 取值运算需要加上取值操作符\\*  \n---\n>  **默认参数**  \n- C++函数中可以带有默认参数  \n```\ndouble Add(int num1,int num2 = 0){\n    return num1 + num2;\n}\n· 所有参数都可以具有默认参数\n· 默认参数必须从最右边开始\n· 不可以使用形参作为默认参数\n· 一般来说，默认参数一般使用在函数参数很多的情况下，\n它避免了函数调用者必须记住太多太长的参数\n```\n>  **可变参数**  \n- C\\++提供一种“可变参数”的机制，即允许参数的数目是可变的。  \n```\n/* 要定义一个支持可变参数的函数，需要用到头文件<cstd\narg>中的一些东西 */\n#include <iostream>\n#include <cstdarg>\nusing namespace std;\nint Add(int first...);\n\nint main() {\n\tint sum = Add(11, 22, 33, -1);\n}\nint Add(int first...) {\n\t//准备读取可变参数\n\tva_list nums;\n\tva_start(nums, first);   \n\t//使用<cstdarg>中的va_xxx宏函数处理可变参数\n\tint sum = 0;\n\tint num = first;\n\t//依次读取参数，-1表示结束\n\twhile (num != -1) {\n\t\tcout << \"+\" << num << endl;\n\t\tsum += num;\n\t\tnum = va_arg(nums, int);\n\t}\n\tva_end(nums);\n\treturn sum;\n}\n------------\n以上主要思想是使用va_xxx读取参数列表，并进行加和。遇\n到-1结束，可变参数处理起来比较麻烦。\n```\n>  **内联函数**  \n- 在进行函数调用前，会将调用函数的地址和参数列表等信息\n保留在堆栈中，以便在函数执行结束后，可以返回到原先调\n用的程序继续执行。因此对于某些频繁调用的小型函数来说\n，这些堆栈存取动作，会降低的程序的执行效率，此时即可\n使用内敛函数解决问题。  \n内联函数允许函数内部的内容正在调用点直接展开，这样就\n避免了传统调用函数过程带来的性能损失。\n```\ninline int add(int,int);\nvoid add(int a,int b){\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n}\nint main(){\n    add(1,2);\n    /*编译器会改写成*/\n    cout << \"接收两个数计算和\" << endl;\n    cout << \"和值为:\" << a+b << endl;\n    ----------\n    实际上，inline只是对编译器进行优化的一个建议，\n    编译器完全可能会不理会该建议，所以，不要滥用inl\n    ine函数\n}\n```\n>  **函数重载**  \n- 函数名相同，参数列表不同，就是函数的重载特性\n```\n函数重载经常出现的错误示例：\nint add(int a){\n    return a；\n}\nfloat add(int a){\n    return a\n}\n//不能依赖于返回值的类型不同选定一个函数\n//实参与形参类型不同\n//不要认为的制造二义性冲突，例如\nint add(int a){\n    return a;\n}\nint add(int a,int b = 10){\n    return a + b; \n}\n```\n- 安全连接和名字重组自行百度了解  \n  \n> **递归函数**  \n- 函数自己调用自己，即递归函数\n```\n#include <iostream>\nusing namespace std;\n\nvoid test(int);\n\nint main() {\n\ttest(10);\n}\nvoid test(int num1) {\n\tcout << \"函数开始\" << endl;\n\tif (num1 == 0) return;\n\ttest(num1 / 2);\n\tcout << \"函数结束\" << endl;\n}\n输出结果如下:\n函数开始\n函数开始\n函数开始\n函数开始\n函数开始\n函数结束\n函数结束--gg\n函数结束\n函数结束\n--------------\n个人是这样理解的,递归就是一个函数嵌套的过程，像上面\n的程序有五个函数开始，这是在执行递归之前的语句，也\n就是说算上第一次进入函数，这个函数执行了五次，但对\n应的函数结束却只出现了四次，那是因为最后一次执行了 \nreturn语句，直接跳出了函数，也就没有后面的语句的执\n行。结合理解使用调试功能进行观察效果会更好。\n```\n\n> **函数指针**  \n- 在C++中提供函数指针，它用以指向一个函数  \n\n```\nvoid (*fp)();   //声明一个类型为void，没有参数的函数指针\nfp = &add;  //指向add函数的地址\nfp = add    //等同与指向\n//调用的方法\nfp();       //相当于add()\n(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用\n\n```\n\n- 理解函数指针\n\n```\n#include <iostream>\nusing namespace std;\n\nint add(int a ,int b) {\n\treturn a + b;\n}\nint min(int a, int b);\nint main() {\n\tvoid (*fp1)(int);\n\tint (*fp2)(int, int);\n\tcout << typeid(fp1).name() << endl;\n\tcout << typeid(fp2).name() << endl;\n\tcout << typeid(add).name() << endl;\n\tcout << typeid(min).name() << endl;\n}\nint min(int a, int b) {\n\treturn a - b;\n}\n------------\n利用typeid输出函数指针类型来理解它\n根据这样的特性，我们可以定义函数指针数字组\nint (*fp[])(int ,int ) = {&add,&min}\n函数指针的定义有点繁琐，建议用typedef来改善可读性。\ntypedef int (*fp)(int,int);\nfp fp1 = add;\nfp fp2 = &min;\nfp fp3[] = {&add,&min};\n```\n\n- 函数与值传递  \n\n```\n·值传递有三种方式：传值方式，引用方式，传址方式\n\n·向函数传递参数的时候，除了引用方式外，其他方式都是\n在函数内部将参数内容复制一份使用。\n```\n> **类的设计**\n- 类是对象的类型，对象是类的实例  \n- 类的设计  \n\n```\n· 类的语法定义：\nclass 类名{\n访问控制符:\n    成员列表\n};\n· 类也可以先声明后定义，声明方式如下\nclass 类名;\n· 对象的定义\n类名 对象名;\n类名 * 对象名 = new 类名();\n//类的两种实例化方法\n还可以定义类对象的指针和引用\n类名 * 指针名 = &对象名;\n类名 & 引用名 = 对象名;\n· 数据成员的访问\n可以使用\".\"来访问数据成员\n对象指针用\"->\"来访问\n还支持用\"::\"域名操作符访问成员，但常用以上两种\n· 成员访问控制\n访问控制符一般包括两种\npublic:共有的，可以在任意地方访问成员\nprivate:私有的，只能在类的内部访问成员\n有一种不成文的规矩，就是把私有的数据成员加上下划线\n· 成员函数\n成员函数其实与普通的函数没有太大的差别，它可以被内\n联，也可以被重载，也可以使用默认参数，唯一的区别就\n是定义是要加上类域的帽子，但声明不需要，如\nclass A{\n    void a();\n};\nvoid A :: a(){  //数据类型 所属类名 :: 函数名\n    cout << \"我属于A类\" << endl;\n}\n· this指针\n在成员函数体内，有一种特殊的指针，this指针。this指\n针指向当前类对象本身，可以用this调用对象的成员：\nthis -> a();\n注意:this不能被改变，也不能在类作用域以外的地方使用\n· 内存中的类\n类包括数据成员和成员函数，但内存中的类只包括其数据\n成员，成员函数其实并不属于对象，它只是一个特殊的全\n局函数。\n· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：\n#include <iostream>\nusing namespace std;\nclass A {\npublic:\n\tint a;\n\tint b;\n\tchar c;\n\tchar d;\n};\nclass B {\npublic:\n\tint a;\n\tchar c;\n\tint b;\n\tchar d;\n};\nint main() {\n\tcout << sizeof(A) << endl;\n\tcout << sizeof(B) << endl;\n}\n输出如下：\n12\n16\n为了程序运行的效率，编译器在一定的设置下可能对成员\n排放位置做一些调整，使得整个结构体为一个字节长的整\n数倍，这就是所谓的“字节对齐”，上面演示了这种布局的\n差异，可以看出来，，不同的排列方式会引起类字节长度\n的差别，大家写代码一定要考虑这一点。\n```\n\n- UML类图可以表示一个类，便于理解，如  \n- 私有是\"-\"前缀，共有则是\"+\"前缀  \n\n|类名|  \n|:-:|\n|数据成员|\n|函数成员|\n\n\n\n\n\n>  **类的讨论**  \n\n```\n· 类与结构\nC++中提供结构和类。在数据成员上，它们唯一的差别在于\n：结构成员的默认访问控制为public，类的默认访问控制\n为private。\nclass是一个全新的概念，所以人们更愿意接受class是真\n正的面向对象概念。而对于struct，人们更愿意用来描述\n那些没有行为或者行为能力很弱的数据结构体。\n· 抽象性\n在软件开发的分析、设计时对具体问题进行归纳、概括，\n并将这一类对象的公共特性加以条理化和严格描述，它主\n张集中思想和精力，考虑关键、主要、实质性的问题，去\n掉非主要的部分，便于开发人员对整个问题准确地认识。\n为具体的对象定义一个类的过程就是抽象。\n· 封装性\n保证程序员用正确的方式操作对象，并将一些操作细节隐\n藏起来。主要体现如下方面:\n--- 保护私有数据:不允许外部程序直接访问私有的数据\n--- 隐藏了操作细节:提供公用成员函数提供外部调用\n根据这两个方面,我们可以举一个例子来说明:\n#include <iostream>\nusing namespace std;\nclass A {\n\t/**\n\t *声明一个A类，包含两个数据成员并封装成4个成员函数\n\t *这里使用this指针加深印象\n\t **/\n\tstring _name;\n\tstring _sex;\npublic:\n\tvoid setname(string name) { \n\t\tthis ->_name = name; \n\t}\n\tvoid setsex(string sex) { \n\t\tthis->_sex = sex;\n\t}\n\tstring getname() { return this ->_name; }\n\tstring getsex() { return this ->_sex; }\n};\nint main() {\n\t/**\n\t *使用指针的方法实例化A的一个对象\n\t *定义两个string临时变量\n\t *调用公共的数据成员封装函数进行赋值和输出\n\t **/\n\tA * a1 = new A();\n\tstring temp1,temp2;\n\tcout << \"请输入你的姓名\";\n\tcin >> temp1;\n\ta1->setname(temp1);\n\tcout << \"请输入你的性别\";\n\tcin >> temp2;\n\ta1->setsex(temp2);\n\tcout << \"姓名:\" << a1->getname() << endl;\n\tcout << \"性别:\" << a1->getsex() << endl;\n}\n程序员的责任就是封装复杂的数据和操作，以简单明了的\n共有函数的方式为外部程序提供对象操作接口\n```\n    \n# 类的封装性  \n\n封装性保证程序员通过正确的方式操作对象，并将操作的细节隐藏起来。\n\n- 保护私有数据：不允许外部程序访问私有的数据  \n\n- 隐藏了操作细节：提供公共方法，以供外部程序调用  \n\n## 注意点  \n\n1. 类的组合  \n\n类的数据成员可以是基本类型、复合类型、或者是一个自定义类的对象。\n\n2. 类的声明  \n\n要在调用类之前先声明这个类\n\n# 构造函数  \n\n是一个有特殊的成员函数，定义类的实例被隐式调用\n\n- 函数名与类名一致\n\n- 与正常的函数规则一致，可重载但不能有返回值例如，可以带有参数，默认值等\n\n- 一般用来初始化数据 \n\n- 没有定义构造函数时C++会自动创建默认构造函数  \n\n## 成员初始值列表  \n\n构造函数的特有的初始化方式。用以指定在调用该构造函数是完成的初始化序列\n\n以：引起，多个值以，间隔;初始化语句写成()形式\n\n# 析构函数  \n\n是与构造函数相反的一个特殊函数，销毁对象或某个对象离开作用域时会调用析构函数。\n\n- 以～引起，函数名与类名一致  \n\n- 没有返回值，参数列表为空  \n\n- 一般用来销毁对象  \n\n- 没有定义时会自动创建默认析构函数  \n\n# 转换构造函数  \n\n当某个构造函数只有一个参数，而该参数又不是本类的const引用，称为转换构造函数  \n\n## explicit  \n\n不允许显式调用函数  \n\n# 拷贝构造函数  \n\n拷贝构造函数即复制一个对象。 \n\n# 操作符重载  \n\n为类定义操作符函数  \n\n例：如果一个对象将 ～操作符 重载，则～a等同于a.operator~()\n\n## 注意点\n\n1. 操作符重载函数可以有形参  \n\n2. 一元操作符不能混当二元操作符使用，同理，二元也一样。\n\n3. 对于查找顺序来说，编译器会先查找对象操作符的重载，再去查找全局操作符的重载\n\n4. 类型转换：将对象转换成对应的类型，如：Actor::operator string()\n\n# const \n\n用来指示某个变量不能被修改  \n\n如果在对象实例前加上const，那么你就只能使用const类型的成员函数  \n\n# mutable  \n\n用来修饰数据成员，表示可变的。   \n\n加了const的函数遇到使用mutable数据成员的修改会忽略它。  \n\n# 友元  \n\n当一个类或一个函数声明为另一个类的朋友时，它就可以访问该类的私有成员\n\n## 注意点  \n\n1. 使用友元在前面加上friend  \n\n2. 注意声明的顺序  \n\n3. 如果A类声明B类为友元，那么B类可以访问A类的私有数据成员，A类则不能访问B类  \n\n4. 友元在一定程度上破坏了类的封装性，尽量不要过多使用  \n\n\n\n","slug":"C++ note3","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpti00057qsgx6bldk7w","content":"<p>关于面向对象编程的笔记  </p>\n<a id=\"more\"></a>  \n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a><strong>面向对象</strong></h1><hr>\n<blockquote>\n<p><strong>new 动态内存分配</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* i = new int;   //类型*变量 = new 类型</span><br><span class=\"line\">int* ip = new int[5];//分配数组</span><br><span class=\"line\">int* (*ip)[5] = new int[5][4]   //分配多维数组</span><br><span class=\"line\">delete [] ip;   //数组的销毁方式</span><br><span class=\"line\">/**思考题</span><br><span class=\"line\"> *1、new如何动态分配多维数组？</span><br><span class=\"line\">    int (*ipp)[4] = new int[5][4];</span><br><span class=\"line\"> *2、分配出来的多维数组如何销毁？</span><br><span class=\"line\">    delete[] ipp;</span><br><span class=\"line\"> **/</span><br><span class=\"line\">delete i;   //销毁地址</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p> 常见错误</p>\n<ul>\n<li>忘记销毁new出来的地址，会造成内存泄露  </li>\n<li>多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(ip)&#123;</span><br><span class=\"line\">    delete ip;</span><br><span class=\"line\">    ip = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>销毁一段非new分配的内存  </li>\n<li>使用被delete的内存  </li>\n<li>务必要记住，new和delete必须要成对使用  </li>\n<li>new的对象不要盲目使用自增运算符  </li>\n<li>取值运算需要加上取值操作符*  </li>\n</ul>\n<hr>\n<blockquote>\n<p> <strong>默认参数</strong>  </p>\n<ul>\n<li>C++函数中可以带有默认参数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double Add(int num1,int num2 = 0)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 所有参数都可以具有默认参数</span><br><span class=\"line\">· 默认参数必须从最右边开始</span><br><span class=\"line\">· 不可以使用形参作为默认参数</span><br><span class=\"line\">· 一般来说，默认参数一般使用在函数参数很多的情况下，</span><br><span class=\"line\">它避免了函数调用者必须记住太多太长的参数</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>可变参数</strong>  </p>\n<ul>\n<li>C++提供一种“可变参数”的机制，即允许参数的数目是可变的。  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 要定义一个支持可变参数的函数，需要用到头文件&lt;cstd</span><br><span class=\"line\">arg&gt;中的一些东西 */</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstdarg&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int Add(int first...);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tint sum = Add(11, 22, 33, -1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int Add(int first...) &#123;</span><br><span class=\"line\">\t//准备读取可变参数</span><br><span class=\"line\">\tva_list nums;</span><br><span class=\"line\">\tva_start(nums, first);   </span><br><span class=\"line\">\t//使用&lt;cstdarg&gt;中的va_xxx宏函数处理可变参数</span><br><span class=\"line\">\tint sum = 0;</span><br><span class=\"line\">\tint num = first;</span><br><span class=\"line\">\t//依次读取参数，-1表示结束</span><br><span class=\"line\">\twhile (num != -1) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;+&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\tnum = va_arg(nums, int);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tva_end(nums);</span><br><span class=\"line\">\treturn sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">以上主要思想是使用va_xxx读取参数列表，并进行加和。遇</span><br><span class=\"line\">到-1结束，可变参数处理起来比较麻烦。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>内联函数</strong>  </p>\n<ul>\n<li>在进行函数调用前，会将调用函数的地址和参数列表等信息<br>保留在堆栈中，以便在函数执行结束后，可以返回到原先调<br>用的程序继续执行。因此对于某些频繁调用的小型函数来说<br>，这些堆栈存取动作，会降低的程序的执行效率，此时即可<br>使用内敛函数解决问题。<br>内联函数允许函数内部的内容正在调用点直接展开，这样就<br>避免了传统调用函数过程带来的性能损失。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline int add(int,int);</span><br><span class=\"line\">void add(int a,int b)&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    add(1,2);</span><br><span class=\"line\">    /*编译器会改写成*/</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">    ----------</span><br><span class=\"line\">    实际上，inline只是对编译器进行优化的一个建议，</span><br><span class=\"line\">    编译器完全可能会不理会该建议，所以，不要滥用inl</span><br><span class=\"line\">    ine函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>函数重载</strong>  </p>\n<ul>\n<li>函数名相同，参数列表不同，就是函数的重载特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数重载经常出现的错误示例：</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float add(int a)&#123;</span><br><span class=\"line\">    return a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不能依赖于返回值的类型不同选定一个函数</span><br><span class=\"line\">//实参与形参类型不同</span><br><span class=\"line\">//不要认为的制造二义性冲突，例如</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int add(int a,int b = 10)&#123;</span><br><span class=\"line\">    return a + b; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>安全连接和名字重组自行百度了解  </li>\n</ul>\n<blockquote>\n<p><strong>递归函数</strong>  </p>\n<ul>\n<li>函数自己调用自己，即递归函数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">void test(int);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\ttest(10);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test(int num1) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数开始&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tif (num1 == 0) return;</span><br><span class=\"line\">\ttest(num1 / 2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数结束&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果如下:</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束--gg</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">--------------</span><br><span class=\"line\">个人是这样理解的,递归就是一个函数嵌套的过程，像上面</span><br><span class=\"line\">的程序有五个函数开始，这是在执行递归之前的语句，也</span><br><span class=\"line\">就是说算上第一次进入函数，这个函数执行了五次，但对</span><br><span class=\"line\">应的函数结束却只出现了四次，那是因为最后一次执行了 </span><br><span class=\"line\">return语句，直接跳出了函数，也就没有后面的语句的执</span><br><span class=\"line\">行。结合理解使用调试功能进行观察效果会更好。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>函数指针</strong>  </p>\n<ul>\n<li>在C++中提供函数指针，它用以指向一个函数  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void (*fp)();   //声明一个类型为void，没有参数的函数指针</span><br><span class=\"line\">fp = &amp;add;  //指向add函数的地址</span><br><span class=\"line\">fp = add    //等同与指向</span><br><span class=\"line\">//调用的方法</span><br><span class=\"line\">fp();       //相当于add()</span><br><span class=\"line\">(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>理解函数指针</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int add(int a ,int b) &#123;</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b);</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tvoid (*fp1)(int);</span><br><span class=\"line\">\tint (*fp2)(int, int);</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp1).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp2).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(add).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(min).name() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b) &#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">利用typeid输出函数指针类型来理解它</span><br><span class=\"line\">根据这样的特性，我们可以定义函数指针数字组</span><br><span class=\"line\">int (*fp[])(int ,int ) = &#123;&amp;add,&amp;min&#125;</span><br><span class=\"line\">函数指针的定义有点繁琐，建议用typedef来改善可读性。</span><br><span class=\"line\">typedef int (*fp)(int,int);</span><br><span class=\"line\">fp fp1 = add;</span><br><span class=\"line\">fp fp2 = &amp;min;</span><br><span class=\"line\">fp fp3[] = &#123;&amp;add,&amp;min&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数与值传递  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">·值传递有三种方式：传值方式，引用方式，传址方式</span><br><span class=\"line\"></span><br><span class=\"line\">·向函数传递参数的时候，除了引用方式外，其他方式都是</span><br><span class=\"line\">在函数内部将参数内容复制一份使用。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>类的设计</strong></p>\n<ul>\n<li>类是对象的类型，对象是类的实例  </li>\n<li>类的设计  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类的语法定义：</span><br><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">访问控制符:</span><br><span class=\"line\">    成员列表</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">· 类也可以先声明后定义，声明方式如下</span><br><span class=\"line\">class 类名;</span><br><span class=\"line\">· 对象的定义</span><br><span class=\"line\">类名 对象名;</span><br><span class=\"line\">类名 * 对象名 = new 类名();</span><br><span class=\"line\">//类的两种实例化方法</span><br><span class=\"line\">还可以定义类对象的指针和引用</span><br><span class=\"line\">类名 * 指针名 = &amp;对象名;</span><br><span class=\"line\">类名 &amp; 引用名 = 对象名;</span><br><span class=\"line\">· 数据成员的访问</span><br><span class=\"line\">可以使用&quot;.&quot;来访问数据成员</span><br><span class=\"line\">对象指针用&quot;-&gt;&quot;来访问</span><br><span class=\"line\">还支持用&quot;::&quot;域名操作符访问成员，但常用以上两种</span><br><span class=\"line\">· 成员访问控制</span><br><span class=\"line\">访问控制符一般包括两种</span><br><span class=\"line\">public:共有的，可以在任意地方访问成员</span><br><span class=\"line\">private:私有的，只能在类的内部访问成员</span><br><span class=\"line\">有一种不成文的规矩，就是把私有的数据成员加上下划线</span><br><span class=\"line\">· 成员函数</span><br><span class=\"line\">成员函数其实与普通的函数没有太大的差别，它可以被内</span><br><span class=\"line\">联，也可以被重载，也可以使用默认参数，唯一的区别就</span><br><span class=\"line\">是定义是要加上类域的帽子，但声明不需要，如</span><br><span class=\"line\">class A&#123;</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void A :: a()&#123;  //数据类型 所属类名 :: 函数名</span><br><span class=\"line\">    cout &lt;&lt; &quot;我属于A类&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· this指针</span><br><span class=\"line\">在成员函数体内，有一种特殊的指针，this指针。this指</span><br><span class=\"line\">针指向当前类对象本身，可以用this调用对象的成员：</span><br><span class=\"line\">this -&gt; a();</span><br><span class=\"line\">注意:this不能被改变，也不能在类作用域以外的地方使用</span><br><span class=\"line\">· 内存中的类</span><br><span class=\"line\">类包括数据成员和成员函数，但内存中的类只包括其数据</span><br><span class=\"line\">成员，成员函数其实并不属于对象，它只是一个特殊的全</span><br><span class=\"line\">局函数。</span><br><span class=\"line\">· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class B &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出如下：</span><br><span class=\"line\">12</span><br><span class=\"line\">16</span><br><span class=\"line\">为了程序运行的效率，编译器在一定的设置下可能对成员</span><br><span class=\"line\">排放位置做一些调整，使得整个结构体为一个字节长的整</span><br><span class=\"line\">数倍，这就是所谓的“字节对齐”，上面演示了这种布局的</span><br><span class=\"line\">差异，可以看出来，，不同的排列方式会引起类字节长度</span><br><span class=\"line\">的差别，大家写代码一定要考虑这一点。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>UML类图可以表示一个类，便于理解，如  </li>\n<li>私有是”-“前缀，共有则是”+”前缀  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数据成员</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">函数成员</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p> <strong>类的讨论</strong>  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类与结构</span><br><span class=\"line\">C++中提供结构和类。在数据成员上，它们唯一的差别在于</span><br><span class=\"line\">：结构成员的默认访问控制为public，类的默认访问控制</span><br><span class=\"line\">为private。</span><br><span class=\"line\">class是一个全新的概念，所以人们更愿意接受class是真</span><br><span class=\"line\">正的面向对象概念。而对于struct，人们更愿意用来描述</span><br><span class=\"line\">那些没有行为或者行为能力很弱的数据结构体。</span><br><span class=\"line\">· 抽象性</span><br><span class=\"line\">在软件开发的分析、设计时对具体问题进行归纳、概括，</span><br><span class=\"line\">并将这一类对象的公共特性加以条理化和严格描述，它主</span><br><span class=\"line\">张集中思想和精力，考虑关键、主要、实质性的问题，去</span><br><span class=\"line\">掉非主要的部分，便于开发人员对整个问题准确地认识。</span><br><span class=\"line\">为具体的对象定义一个类的过程就是抽象。</span><br><span class=\"line\">· 封装性</span><br><span class=\"line\">保证程序员用正确的方式操作对象，并将一些操作细节隐</span><br><span class=\"line\">藏起来。主要体现如下方面:</span><br><span class=\"line\">--- 保护私有数据:不允许外部程序直接访问私有的数据</span><br><span class=\"line\">--- 隐藏了操作细节:提供公用成员函数提供外部调用</span><br><span class=\"line\">根据这两个方面,我们可以举一个例子来说明:</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *声明一个A类，包含两个数据成员并封装成4个成员函数</span><br><span class=\"line\">\t *这里使用this指针加深印象</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _sex;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid setname(string name) &#123; </span><br><span class=\"line\">\t\tthis -&gt;_name = name; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setsex(string sex) &#123; </span><br><span class=\"line\">\t\tthis-&gt;_sex = sex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring getname() &#123; return this -&gt;_name; &#125;</span><br><span class=\"line\">\tstring getsex() &#123; return this -&gt;_sex; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *使用指针的方法实例化A的一个对象</span><br><span class=\"line\">\t *定义两个string临时变量</span><br><span class=\"line\">\t *调用公共的数据成员封装函数进行赋值和输出</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tA * a1 = new A();</span><br><span class=\"line\">\tstring temp1,temp2;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的姓名&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp1;</span><br><span class=\"line\">\ta1-&gt;setname(temp1);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的性别&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp2;</span><br><span class=\"line\">\ta1-&gt;setsex(temp2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;姓名:&quot; &lt;&lt; a1-&gt;getname() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;性别:&quot; &lt;&lt; a1-&gt;getsex() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">程序员的责任就是封装复杂的数据和操作，以简单明了的</span><br><span class=\"line\">共有函数的方式为外部程序提供对象操作接口</span><br></pre></td></tr></table></figure>\n<h1 id=\"类的封装性\"><a href=\"#类的封装性\" class=\"headerlink\" title=\"类的封装性\"></a>类的封装性</h1><p>封装性保证程序员通过正确的方式操作对象，并将操作的细节隐藏起来。</p>\n<ul>\n<li><p>保护私有数据：不允许外部程序访问私有的数据  </p>\n</li>\n<li><p>隐藏了操作细节：提供公共方法，以供外部程序调用  </p>\n</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li>类的组合  </li>\n</ol>\n<p>类的数据成员可以是基本类型、复合类型、或者是一个自定义类的对象。</p>\n<ol start=\"2\">\n<li>类的声明  </li>\n</ol>\n<p>要在调用类之前先声明这个类</p>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>是一个有特殊的成员函数，定义类的实例被隐式调用</p>\n<ul>\n<li><p>函数名与类名一致</p>\n</li>\n<li><p>与正常的函数规则一致，可重载但不能有返回值例如，可以带有参数，默认值等</p>\n</li>\n<li><p>一般用来初始化数据 </p>\n</li>\n<li><p>没有定义构造函数时C++会自动创建默认构造函数  </p>\n</li>\n</ul>\n<h2 id=\"成员初始值列表\"><a href=\"#成员初始值列表\" class=\"headerlink\" title=\"成员初始值列表\"></a>成员初始值列表</h2><p>构造函数的特有的初始化方式。用以指定在调用该构造函数是完成的初始化序列</p>\n<p>以：引起，多个值以，间隔;初始化语句写成()形式</p>\n<h1 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h1><p>是与构造函数相反的一个特殊函数，销毁对象或某个对象离开作用域时会调用析构函数。</p>\n<ul>\n<li><p>以～引起，函数名与类名一致  </p>\n</li>\n<li><p>没有返回值，参数列表为空  </p>\n</li>\n<li><p>一般用来销毁对象  </p>\n</li>\n<li><p>没有定义时会自动创建默认析构函数  </p>\n</li>\n</ul>\n<h1 id=\"转换构造函数\"><a href=\"#转换构造函数\" class=\"headerlink\" title=\"转换构造函数\"></a>转换构造函数</h1><p>当某个构造函数只有一个参数，而该参数又不是本类的const引用，称为转换构造函数  </p>\n<h2 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h2><p>不允许显式调用函数  </p>\n<h1 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><p>拷贝构造函数即复制一个对象。 </p>\n<h1 id=\"操作符重载\"><a href=\"#操作符重载\" class=\"headerlink\" title=\"操作符重载\"></a>操作符重载</h1><p>为类定义操作符函数  </p>\n<p>例：如果一个对象将 ～操作符 重载，则～a等同于a.operator~()</p>\n<h2 id=\"注意点-1\"><a href=\"#注意点-1\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li><p>操作符重载函数可以有形参  </p>\n</li>\n<li><p>一元操作符不能混当二元操作符使用，同理，二元也一样。</p>\n</li>\n<li><p>对于查找顺序来说，编译器会先查找对象操作符的重载，再去查找全局操作符的重载</p>\n</li>\n<li><p>类型转换：将对象转换成对应的类型，如：Actor::operator string()</p>\n</li>\n</ol>\n<h1 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h1><p>用来指示某个变量不能被修改  </p>\n<p>如果在对象实例前加上const，那么你就只能使用const类型的成员函数  </p>\n<h1 id=\"mutable\"><a href=\"#mutable\" class=\"headerlink\" title=\"mutable\"></a>mutable</h1><p>用来修饰数据成员，表示可变的。   </p>\n<p>加了const的函数遇到使用mutable数据成员的修改会忽略它。  </p>\n<h1 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h1><p>当一个类或一个函数声明为另一个类的朋友时，它就可以访问该类的私有成员</p>\n<h2 id=\"注意点-2\"><a href=\"#注意点-2\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li><p>使用友元在前面加上friend  </p>\n</li>\n<li><p>注意声明的顺序  </p>\n</li>\n<li><p>如果A类声明B类为友元，那么B类可以访问A类的私有数据成员，A类则不能访问B类  </p>\n</li>\n<li><p>友元在一定程度上破坏了类的封装性，尽量不要过多使用  </p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>关于面向对象编程的笔记  </p>","more":"<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a><strong>面向对象</strong></h1><hr>\n<blockquote>\n<p><strong>new 动态内存分配</strong><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int* i = new int;   //类型*变量 = new 类型</span><br><span class=\"line\">int* ip = new int[5];//分配数组</span><br><span class=\"line\">int* (*ip)[5] = new int[5][4]   //分配多维数组</span><br><span class=\"line\">delete [] ip;   //数组的销毁方式</span><br><span class=\"line\">/**思考题</span><br><span class=\"line\"> *1、new如何动态分配多维数组？</span><br><span class=\"line\">    int (*ipp)[4] = new int[5][4];</span><br><span class=\"line\"> *2、分配出来的多维数组如何销毁？</span><br><span class=\"line\">    delete[] ipp;</span><br><span class=\"line\"> **/</span><br><span class=\"line\">delete i;   //销毁地址</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<blockquote>\n<p> 常见错误</p>\n<ul>\n<li>忘记销毁new出来的地址，会造成内存泄露  </li>\n<li>多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过；  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(ip)&#123;</span><br><span class=\"line\">    delete ip;</span><br><span class=\"line\">    ip = 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>销毁一段非new分配的内存  </li>\n<li>使用被delete的内存  </li>\n<li>务必要记住，new和delete必须要成对使用  </li>\n<li>new的对象不要盲目使用自增运算符  </li>\n<li>取值运算需要加上取值操作符*  </li>\n</ul>\n<hr>\n<blockquote>\n<p> <strong>默认参数</strong>  </p>\n<ul>\n<li>C++函数中可以带有默认参数  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">double Add(int num1,int num2 = 0)&#123;</span><br><span class=\"line\">    return num1 + num2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 所有参数都可以具有默认参数</span><br><span class=\"line\">· 默认参数必须从最右边开始</span><br><span class=\"line\">· 不可以使用形参作为默认参数</span><br><span class=\"line\">· 一般来说，默认参数一般使用在函数参数很多的情况下，</span><br><span class=\"line\">它避免了函数调用者必须记住太多太长的参数</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>可变参数</strong>  </p>\n<ul>\n<li>C++提供一种“可变参数”的机制，即允许参数的数目是可变的。  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* 要定义一个支持可变参数的函数，需要用到头文件&lt;cstd</span><br><span class=\"line\">arg&gt;中的一些东西 */</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">#include &lt;cstdarg&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">int Add(int first...);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tint sum = Add(11, 22, 33, -1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int Add(int first...) &#123;</span><br><span class=\"line\">\t//准备读取可变参数</span><br><span class=\"line\">\tva_list nums;</span><br><span class=\"line\">\tva_start(nums, first);   </span><br><span class=\"line\">\t//使用&lt;cstdarg&gt;中的va_xxx宏函数处理可变参数</span><br><span class=\"line\">\tint sum = 0;</span><br><span class=\"line\">\tint num = first;</span><br><span class=\"line\">\t//依次读取参数，-1表示结束</span><br><span class=\"line\">\twhile (num != -1) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;+&quot; &lt;&lt; num &lt;&lt; endl;</span><br><span class=\"line\">\t\tsum += num;</span><br><span class=\"line\">\t\tnum = va_arg(nums, int);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tva_end(nums);</span><br><span class=\"line\">\treturn sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">以上主要思想是使用va_xxx读取参数列表，并进行加和。遇</span><br><span class=\"line\">到-1结束，可变参数处理起来比较麻烦。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>内联函数</strong>  </p>\n<ul>\n<li>在进行函数调用前，会将调用函数的地址和参数列表等信息<br>保留在堆栈中，以便在函数执行结束后，可以返回到原先调<br>用的程序继续执行。因此对于某些频繁调用的小型函数来说<br>，这些堆栈存取动作，会降低的程序的执行效率，此时即可<br>使用内敛函数解决问题。<br>内联函数允许函数内部的内容正在调用点直接展开，这样就<br>避免了传统调用函数过程带来的性能损失。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline int add(int,int);</span><br><span class=\"line\">void add(int a,int b)&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    add(1,2);</span><br><span class=\"line\">    /*编译器会改写成*/</span><br><span class=\"line\">    cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;</span><br><span class=\"line\">    ----------</span><br><span class=\"line\">    实际上，inline只是对编译器进行优化的一个建议，</span><br><span class=\"line\">    编译器完全可能会不理会该建议，所以，不要滥用inl</span><br><span class=\"line\">    ine函数</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p> <strong>函数重载</strong>  </p>\n<ul>\n<li>函数名相同，参数列表不同，就是函数的重载特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数重载经常出现的错误示例：</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a；</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">float add(int a)&#123;</span><br><span class=\"line\">    return a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//不能依赖于返回值的类型不同选定一个函数</span><br><span class=\"line\">//实参与形参类型不同</span><br><span class=\"line\">//不要认为的制造二义性冲突，例如</span><br><span class=\"line\">int add(int a)&#123;</span><br><span class=\"line\">    return a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int add(int a,int b = 10)&#123;</span><br><span class=\"line\">    return a + b; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>安全连接和名字重组自行百度了解  </li>\n</ul>\n<blockquote>\n<p><strong>递归函数</strong>  </p>\n<ul>\n<li>函数自己调用自己，即递归函数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">void test(int);</span><br><span class=\"line\"></span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\ttest(10);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">void test(int num1) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数开始&quot; &lt;&lt; endl;</span><br><span class=\"line\">\tif (num1 == 0) return;</span><br><span class=\"line\">\ttest(num1 / 2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;函数结束&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果如下:</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数开始</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束--gg</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">函数结束</span><br><span class=\"line\">--------------</span><br><span class=\"line\">个人是这样理解的,递归就是一个函数嵌套的过程，像上面</span><br><span class=\"line\">的程序有五个函数开始，这是在执行递归之前的语句，也</span><br><span class=\"line\">就是说算上第一次进入函数，这个函数执行了五次，但对</span><br><span class=\"line\">应的函数结束却只出现了四次，那是因为最后一次执行了 </span><br><span class=\"line\">return语句，直接跳出了函数，也就没有后面的语句的执</span><br><span class=\"line\">行。结合理解使用调试功能进行观察效果会更好。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p><strong>函数指针</strong>  </p>\n<ul>\n<li>在C++中提供函数指针，它用以指向一个函数  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void (*fp)();   //声明一个类型为void，没有参数的函数指针</span><br><span class=\"line\">fp = &amp;add;  //指向add函数的地址</span><br><span class=\"line\">fp = add    //等同与指向</span><br><span class=\"line\">//调用的方法</span><br><span class=\"line\">fp();       //相当于add()</span><br><span class=\"line\">(*fp)();    //相当于add()，一般用这种来区别这是一个函数指针的调用</span><br></pre></td></tr></table></figure>\n<ul>\n<li>理解函数指针</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\"></span><br><span class=\"line\">int add(int a ,int b) &#123;</span><br><span class=\"line\">\treturn a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b);</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tvoid (*fp1)(int);</span><br><span class=\"line\">\tint (*fp2)(int, int);</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp1).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(fp2).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(add).name() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; typeid(min).name() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">int min(int a, int b) &#123;</span><br><span class=\"line\">\treturn a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">------------</span><br><span class=\"line\">利用typeid输出函数指针类型来理解它</span><br><span class=\"line\">根据这样的特性，我们可以定义函数指针数字组</span><br><span class=\"line\">int (*fp[])(int ,int ) = &#123;&amp;add,&amp;min&#125;</span><br><span class=\"line\">函数指针的定义有点繁琐，建议用typedef来改善可读性。</span><br><span class=\"line\">typedef int (*fp)(int,int);</span><br><span class=\"line\">fp fp1 = add;</span><br><span class=\"line\">fp fp2 = &amp;min;</span><br><span class=\"line\">fp fp3[] = &#123;&amp;add,&amp;min&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>函数与值传递  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">·值传递有三种方式：传值方式，引用方式，传址方式</span><br><span class=\"line\"></span><br><span class=\"line\">·向函数传递参数的时候，除了引用方式外，其他方式都是</span><br><span class=\"line\">在函数内部将参数内容复制一份使用。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>类的设计</strong></p>\n<ul>\n<li>类是对象的类型，对象是类的实例  </li>\n<li>类的设计  </li>\n</ul>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类的语法定义：</span><br><span class=\"line\">class 类名&#123;</span><br><span class=\"line\">访问控制符:</span><br><span class=\"line\">    成员列表</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">· 类也可以先声明后定义，声明方式如下</span><br><span class=\"line\">class 类名;</span><br><span class=\"line\">· 对象的定义</span><br><span class=\"line\">类名 对象名;</span><br><span class=\"line\">类名 * 对象名 = new 类名();</span><br><span class=\"line\">//类的两种实例化方法</span><br><span class=\"line\">还可以定义类对象的指针和引用</span><br><span class=\"line\">类名 * 指针名 = &amp;对象名;</span><br><span class=\"line\">类名 &amp; 引用名 = 对象名;</span><br><span class=\"line\">· 数据成员的访问</span><br><span class=\"line\">可以使用&quot;.&quot;来访问数据成员</span><br><span class=\"line\">对象指针用&quot;-&gt;&quot;来访问</span><br><span class=\"line\">还支持用&quot;::&quot;域名操作符访问成员，但常用以上两种</span><br><span class=\"line\">· 成员访问控制</span><br><span class=\"line\">访问控制符一般包括两种</span><br><span class=\"line\">public:共有的，可以在任意地方访问成员</span><br><span class=\"line\">private:私有的，只能在类的内部访问成员</span><br><span class=\"line\">有一种不成文的规矩，就是把私有的数据成员加上下划线</span><br><span class=\"line\">· 成员函数</span><br><span class=\"line\">成员函数其实与普通的函数没有太大的差别，它可以被内</span><br><span class=\"line\">联，也可以被重载，也可以使用默认参数，唯一的区别就</span><br><span class=\"line\">是定义是要加上类域的帽子，但声明不需要，如</span><br><span class=\"line\">class A&#123;</span><br><span class=\"line\">    void a();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">void A :: a()&#123;  //数据类型 所属类名 :: 函数名</span><br><span class=\"line\">    cout &lt;&lt; &quot;我属于A类&quot; &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· this指针</span><br><span class=\"line\">在成员函数体内，有一种特殊的指针，this指针。this指</span><br><span class=\"line\">针指向当前类对象本身，可以用this调用对象的成员：</span><br><span class=\"line\">this -&gt; a();</span><br><span class=\"line\">注意:this不能被改变，也不能在类作用域以外的地方使用</span><br><span class=\"line\">· 内存中的类</span><br><span class=\"line\">类包括数据成员和成员函数，但内存中的类只包括其数据</span><br><span class=\"line\">成员，成员函数其实并不属于对象，它只是一个特殊的全</span><br><span class=\"line\">局函数。</span><br><span class=\"line\">· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">class B &#123;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tint a;</span><br><span class=\"line\">\tchar c;</span><br><span class=\"line\">\tint b;</span><br><span class=\"line\">\tchar d;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; sizeof(B) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出如下：</span><br><span class=\"line\">12</span><br><span class=\"line\">16</span><br><span class=\"line\">为了程序运行的效率，编译器在一定的设置下可能对成员</span><br><span class=\"line\">排放位置做一些调整，使得整个结构体为一个字节长的整</span><br><span class=\"line\">数倍，这就是所谓的“字节对齐”，上面演示了这种布局的</span><br><span class=\"line\">差异，可以看出来，，不同的排列方式会引起类字节长度</span><br><span class=\"line\">的差别，大家写代码一定要考虑这一点。</span><br></pre></td></tr></table></figure>\n<ul>\n<li>UML类图可以表示一个类，便于理解，如  </li>\n<li>私有是”-“前缀，共有则是”+”前缀  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">数据成员</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">函数成员</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p> <strong>类的讨论</strong>  </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 类与结构</span><br><span class=\"line\">C++中提供结构和类。在数据成员上，它们唯一的差别在于</span><br><span class=\"line\">：结构成员的默认访问控制为public，类的默认访问控制</span><br><span class=\"line\">为private。</span><br><span class=\"line\">class是一个全新的概念，所以人们更愿意接受class是真</span><br><span class=\"line\">正的面向对象概念。而对于struct，人们更愿意用来描述</span><br><span class=\"line\">那些没有行为或者行为能力很弱的数据结构体。</span><br><span class=\"line\">· 抽象性</span><br><span class=\"line\">在软件开发的分析、设计时对具体问题进行归纳、概括，</span><br><span class=\"line\">并将这一类对象的公共特性加以条理化和严格描述，它主</span><br><span class=\"line\">张集中思想和精力，考虑关键、主要、实质性的问题，去</span><br><span class=\"line\">掉非主要的部分，便于开发人员对整个问题准确地认识。</span><br><span class=\"line\">为具体的对象定义一个类的过程就是抽象。</span><br><span class=\"line\">· 封装性</span><br><span class=\"line\">保证程序员用正确的方式操作对象，并将一些操作细节隐</span><br><span class=\"line\">藏起来。主要体现如下方面:</span><br><span class=\"line\">--- 保护私有数据:不允许外部程序直接访问私有的数据</span><br><span class=\"line\">--- 隐藏了操作细节:提供公用成员函数提供外部调用</span><br><span class=\"line\">根据这两个方面,我们可以举一个例子来说明:</span><br><span class=\"line\">#include &lt;iostream&gt;</span><br><span class=\"line\">using namespace std;</span><br><span class=\"line\">class A &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *声明一个A类，包含两个数据成员并封装成4个成员函数</span><br><span class=\"line\">\t *这里使用this指针加深印象</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tstring _name;</span><br><span class=\"line\">\tstring _sex;</span><br><span class=\"line\">public:</span><br><span class=\"line\">\tvoid setname(string name) &#123; </span><br><span class=\"line\">\t\tthis -&gt;_name = name; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tvoid setsex(string sex) &#123; </span><br><span class=\"line\">\t\tthis-&gt;_sex = sex;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tstring getname() &#123; return this -&gt;_name; &#125;</span><br><span class=\"line\">\tstring getsex() &#123; return this -&gt;_sex; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\t/**</span><br><span class=\"line\">\t *使用指针的方法实例化A的一个对象</span><br><span class=\"line\">\t *定义两个string临时变量</span><br><span class=\"line\">\t *调用公共的数据成员封装函数进行赋值和输出</span><br><span class=\"line\">\t **/</span><br><span class=\"line\">\tA * a1 = new A();</span><br><span class=\"line\">\tstring temp1,temp2;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的姓名&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp1;</span><br><span class=\"line\">\ta1-&gt;setname(temp1);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;请输入你的性别&quot;;</span><br><span class=\"line\">\tcin &gt;&gt; temp2;</span><br><span class=\"line\">\ta1-&gt;setsex(temp2);</span><br><span class=\"line\">\tcout &lt;&lt; &quot;姓名:&quot; &lt;&lt; a1-&gt;getname() &lt;&lt; endl;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;性别:&quot; &lt;&lt; a1-&gt;getsex() &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">程序员的责任就是封装复杂的数据和操作，以简单明了的</span><br><span class=\"line\">共有函数的方式为外部程序提供对象操作接口</span><br></pre></td></tr></table></figure>\n<h1 id=\"类的封装性\"><a href=\"#类的封装性\" class=\"headerlink\" title=\"类的封装性\"></a>类的封装性</h1><p>封装性保证程序员通过正确的方式操作对象，并将操作的细节隐藏起来。</p>\n<ul>\n<li><p>保护私有数据：不允许外部程序访问私有的数据  </p>\n</li>\n<li><p>隐藏了操作细节：提供公共方法，以供外部程序调用  </p>\n</li>\n</ul>\n<h2 id=\"注意点\"><a href=\"#注意点\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li>类的组合  </li>\n</ol>\n<p>类的数据成员可以是基本类型、复合类型、或者是一个自定义类的对象。</p>\n<ol start=\"2\">\n<li>类的声明  </li>\n</ol>\n<p>要在调用类之前先声明这个类</p>\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p>是一个有特殊的成员函数，定义类的实例被隐式调用</p>\n<ul>\n<li><p>函数名与类名一致</p>\n</li>\n<li><p>与正常的函数规则一致，可重载但不能有返回值例如，可以带有参数，默认值等</p>\n</li>\n<li><p>一般用来初始化数据 </p>\n</li>\n<li><p>没有定义构造函数时C++会自动创建默认构造函数  </p>\n</li>\n</ul>\n<h2 id=\"成员初始值列表\"><a href=\"#成员初始值列表\" class=\"headerlink\" title=\"成员初始值列表\"></a>成员初始值列表</h2><p>构造函数的特有的初始化方式。用以指定在调用该构造函数是完成的初始化序列</p>\n<p>以：引起，多个值以，间隔;初始化语句写成()形式</p>\n<h1 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h1><p>是与构造函数相反的一个特殊函数，销毁对象或某个对象离开作用域时会调用析构函数。</p>\n<ul>\n<li><p>以～引起，函数名与类名一致  </p>\n</li>\n<li><p>没有返回值，参数列表为空  </p>\n</li>\n<li><p>一般用来销毁对象  </p>\n</li>\n<li><p>没有定义时会自动创建默认析构函数  </p>\n</li>\n</ul>\n<h1 id=\"转换构造函数\"><a href=\"#转换构造函数\" class=\"headerlink\" title=\"转换构造函数\"></a>转换构造函数</h1><p>当某个构造函数只有一个参数，而该参数又不是本类的const引用，称为转换构造函数  </p>\n<h2 id=\"explicit\"><a href=\"#explicit\" class=\"headerlink\" title=\"explicit\"></a>explicit</h2><p>不允许显式调用函数  </p>\n<h1 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h1><p>拷贝构造函数即复制一个对象。 </p>\n<h1 id=\"操作符重载\"><a href=\"#操作符重载\" class=\"headerlink\" title=\"操作符重载\"></a>操作符重载</h1><p>为类定义操作符函数  </p>\n<p>例：如果一个对象将 ～操作符 重载，则～a等同于a.operator~()</p>\n<h2 id=\"注意点-1\"><a href=\"#注意点-1\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li><p>操作符重载函数可以有形参  </p>\n</li>\n<li><p>一元操作符不能混当二元操作符使用，同理，二元也一样。</p>\n</li>\n<li><p>对于查找顺序来说，编译器会先查找对象操作符的重载，再去查找全局操作符的重载</p>\n</li>\n<li><p>类型转换：将对象转换成对应的类型，如：Actor::operator string()</p>\n</li>\n</ol>\n<h1 id=\"const\"><a href=\"#const\" class=\"headerlink\" title=\"const\"></a>const</h1><p>用来指示某个变量不能被修改  </p>\n<p>如果在对象实例前加上const，那么你就只能使用const类型的成员函数  </p>\n<h1 id=\"mutable\"><a href=\"#mutable\" class=\"headerlink\" title=\"mutable\"></a>mutable</h1><p>用来修饰数据成员，表示可变的。   </p>\n<p>加了const的函数遇到使用mutable数据成员的修改会忽略它。  </p>\n<h1 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h1><p>当一个类或一个函数声明为另一个类的朋友时，它就可以访问该类的私有成员</p>\n<h2 id=\"注意点-2\"><a href=\"#注意点-2\" class=\"headerlink\" title=\"注意点\"></a>注意点</h2><ol>\n<li><p>使用友元在前面加上friend  </p>\n</li>\n<li><p>注意声明的顺序  </p>\n</li>\n<li><p>如果A类声明B类为友元，那么B类可以访问A类的私有数据成员，A类则不能访问B类  </p>\n</li>\n<li><p>友元在一定程度上破坏了类的封装性，尽量不要过多使用  </p>\n</li>\n</ol>"},{"title":"C++_高级特性","date":"2019-09-07T11:16:38.000Z","_content":"\nC++中的高级特性\n\n<!--more-->\n\n# 类的继承   \n\n继承可以理解为父子，子类继承父类的的基因，父类又称作基类，子类又称作派生类  \n\n派生类的写法：class A : B ;  \n\n## 内存中的派生类  \n\n在内存中派生类实际上是基类的内容加上自己的内容。  \n\n## protected  \n\n派生类可以访问到基类的保护成员，但不可以访问私有成员  \n\n## 基类访问控制  \n\n在定义派生类的基类列表时，可以指定对基类访问控制的类型，即继承方式。\n\n1. 公有继承时：原基类的非私有成员访问属性在派生类中不变\n\n2. 私有继承时：原基类的非私有成员访问属性在派生类中变为私有成员  \n\n3. 保护继承时：原基类的非私有成员访问属性在派生类中变为保护成员\n\n## 构造与析构  \n\n派生类不会继承基类的构造函数和析构函数  \n\n## 基类的初始化  \n\n派生类可以在构造函数中使用初始值列表对基类进行初始化  \n\n## 默认构造函数  \n\n隐式的默认构造函数创建有两个条件  \n\n1. 用户没有为该类创建任何构造函数  \n\n2. 如果为派生类，其基类必须要有默认构造函数，否则不知道如何初始化基类  \n\n## 派生类的析构  \n\n析构的顺序为：基类的构造在派生类之前，析构在派生类之后。\n\n## 名字隐藏  \n\n实质上就是跟探讨作用域的问题一样  \n\n派生类就如同局部，基类为全局;如果一个派生类和基类有一个数据成员一样，那么编译器会先找到派生类的数据成员，并且使用他。如若在派生类找不到才会向基类再去寻找。  \n\n# 类的多态性  \n\n继承与虚函数构成了多态性。\n\n## 向上转换  \n\n派生类可以转换为基类，但是基类不可以转换成派生类 \n\n## 向下转换  \n\n有时候，我们知道当前指针指向的对象为什么类型，可以使用强制转换完成向下转换  \n\n向下转换必须显式的向编译器提出，向下转换具有一定的风险，如果给定的并非是一个派生类的对象，那么，将他进行强制转换，是不可预料的。  \n\n## 虚函数  \n\n关键字virtual用以声明基类的某个函数为虚函数  \n\n我们通常把基类虚函数的实现称作“覆盖”。  \n\n## 虚析构函数  \n\n如果基类的虚析构函数不是虚函数，针对基类的析构操作将无法引起派生类的析构。  \n\n保险起见，一般建议将基类的析构函数声明为虚的\n\n## 纯虚函数  \n\n纯虚函数是一种特殊的虚函数，它没有函数的实现。  \n\nvirtual void say() = 0;  \n\n注意区分函数体为空的情形，不可再为虚函数定义函数体  \n\n## 抽象类  \n\n具有纯虚函数的类即为抽象类。抽象类不能被实例化  \n\n抽象类一般用来设计一套统一的接口，派生类必须实现其中的虚函数，才能被实例化。  \n\n## 多级继承  \n\n派生类的继承可以是任何一个合法的类，也可以继承于某一个派生类。  \n\n## 虚函数的多次填充  \n\n虚函数的特性是自动遗传的，也就是说，在基类定义了某个虚函数，不管派生类覆盖不覆盖这个函数，其属性仍然是虚的，那么，虚函数可以随着多级继承而被多次填充  \n\n## 多继承   \n\n派生类可以继承多个基类  \n\n## 多继承带来的问题  \n\n二义性和内存冗余即可能会在派生类的对象同时保存基类的多份复制  \n\n## 虚拟继承  \n\n可以实现多个派生类之间共同享受某个相同的基类  \n\n在要继承的基类名之前加virtual  \n\n在UML使用虚线表示虚拟继承  \n\n# 模板  \n\n函数模板即带有参数的函数\n\n模板的参数与函数的参数相似与不同  \n\n1. 函数的参数列表由()引起,模板的参数列表由<>括起\n\n2. 函数的参数为对象，模板的参数大部分为类型，例如：typename T。T的类型必须是typename或者class。  \n\n3. 函数的参数是0～N个，而模板的参数是1～N个  \n\n4. 函数模板也可以被重载  \n\n5. 使用模板时，可以不指定模板的参数。编译器根据实际调用正确猜测出模板参数的值  \n\n6. 模板的参数不能具有默认值，但是类模板中模板参数可以有默认值  \n\n## 函数模板的实例化  \n\n函数模板必须被实例化才能被正常调用 \n\n注意函数的实例化可以隐式完成  \n\n## 函数模板的重载   \n\n函数模板可以重载  \n\n普通的函数与模板函数同名同参数时，C++会优先选择普通函数  \n\n## 函数模板的特化  \n\n可以针对某个类型进行特化（？特殊化）。特化的函数以“template<>”开头  \n\n## 类模板  \n\n类模板的成员函数定义之前必须包含一段模板参数的声明  \n\n类模板可以声明多个参数  \n\n可以具有默认参数类型  \n\n# 异常处理  \n\n## 抛出异常  \n\n使用异常机制，就是在错误的地方，抛出一个异常变量。  \n\nthrow关键字用以抛出一个异常，这个异常可以是任何类型的对象。  \n\n## 捕获异常  \n\n可以使用try...catch捕获抛出的异常。try中文含义为尝试，catch为捕获，意思就是先尝试执行一段代码，如果捕获到异常，则执行catch的代码。\n\n## 捕获不同类型的异常  \n\n异常可以由程序员自定义异常类。  \n\n## 捕获所有异常  \n\n可以使用带有省略号的catch语句块，它用以捕获所有未经捕获的异常。  \n\n## 在catch块抛出异常  \n\n我们可以在catch语句块中再次抛出异常  \n\n## 未经捕获的异常  \n\n异常不一定都被捕获  \n\n如果一个异常没有被捕获，C++不知道怎么处理这个异常的情况下。它将会调用temiante()函数，默认情况下，该函数只会简单的调用abort()函数，用以中断程序的执行。  \n\n## 定制terminate()的行为  \n\n可以认为terminate()函数使用一个全局的函数指针进行调用  \n\n因此，可以使用set_terminate()函数来指定一个新的处理函数。  \n\n## 对抛出异常的声明  \n\n当声明函数的时候，可以同时指明该函数可能会抛出的异常  \n\n对抛出异常作出声明不是强制性的\n\n1. 如果一个函数可能抛出异常，不一定要使用throw抛出异常，反之一样  \n\n2. 声明的异常不必与实际抛出的类型相符  \n\n3. 在catch语句中，其捕获的异常不必与函数声明的异常中的类型相符  \n\n对抛出的异常作出声明，只是为了指导意义，为了让使用者知道调用此函数可能会带来的风险。  \n\n# 名字空间与域  \n\n用以解决名字冲突问题  \n\n## 名字空间定义  \n\n可以定义一个名字空间，将自己的类、和对象括起来。  \n\n## using声明  \n\nusing声明告诉编译器尝试从名字空间查找对象  \n\n## using指令   \n\n可以直接声明待使用的名字空间的成员名\n\n## 名字空间的别名  \n\n可以使用namespace为已定义的名字空间指定别名  \n\n## 作用域  \n\nC++支持三种作用域  \n\n## 局部作用域  \n\n1. 每段语句块都包含一个局部的作用域，在语句块声明的对象只在本语句块内部其作用  \n\n2. 局部变量的存储类型  \n\n局部变量可以具有不同的存储类型  \n\n- 自动存储类型：当程序执行超出当前作用域，变量自动销毁  \n\n- 寄存器存储类型：将变量存储在寄存器中进行存取，可以提高函数的执行程度，但是编译器有可能会选择其他方式处理  \n\n- 静态存储类型：超出局部作用域，静态局部变量不会被销毁  \n\n## 名字空间域  \n\n1. 由名字空间所指定的作用域  \n\n2. 外部存储类型：extern，可以在a源文件声明b源文件的对象  \n\n3. 最外成的空间即全局域  \n\n## 类域 \n\n类域包括定义体和所有的成员函数体  \n\n类可以具有static数据成员  \n\n作用域、语句块、名字空间、类都可以嵌套  \n\n语句块中定义的类为内部类  \n\n## 对象的生命周期  \n\n生命周期与作用域有某种关系，如：一段语句块中定义的自动对象在离开当前局部作用域的时候，总会被销毁。  \n\n# C++标准库  \n\n## 字符串库<string>\n\n1. 字符串的构造和赋值  \n\n由多个重复的字符构成的string：string s(8,'f')  \n\n2. 字符串连接  \n\n可以使用+号将两个字符串连接起来  \n\n3. 字符串可以用运算符直接比较  \n\n4. 字符串的下标  \n\n可以通过字符串的下标来访问字符串中的某个字符  \n\n通过length()获取字符串的长度  \n\n5. 子串：字符串中的一部分  \n\n6. 字符串的查找  \n\n可以从字符串中查找某个字串，并返回字串所在的位置，使用是string类的find()方法，查找失败返回-1  \n\n7. string与C-style字符串：可以通过c_str()函数获取string的字符数组，c_str返回的是一个const的字符指针，指向string内部的实际存储地址，值会随着string的改变。  \n\n8. 空字符串：不包含任何内容，使用clear()清空字符串，empty()判断字符串是否为空  \n\n## 复数类<complex>  \n\n1. 复数的构造  \n\ncomplex是一个类模板，它可以采用float、double、long double 3种类型进行定制，如：complex<double> c(1,2)  \n\n2. 复数可以进行四则运算  \n\n3. 复数的操作函数  \n\nreal()返回复数的实部  \n\nimag()返回复数的虚部  \n\nabs(x)返回复数x的模  \n\narg(x)返回复数x的相角  \n\nconj(x)返回复数x的共軛复数  \n\nnarm(x)返回复数x的模的平方  \n\n## 异常类<stdexcept>\n\n包含了C++中各种各样的异常  \n\n# C标准库  \n\n## assert宏  \n\n在<cassert>中定义一个很有用的宏：assert()用以调试代码  \n\n如果想取消掉assert()的功能，可以在包含<cassert>头文件之前定义NDEBUG宏：  \n\n## 类型函数  \n\n<cctype>定义了一堆字符处理函数和宏\n\n- isdigit(c):判断c是否为数字\n\n- isupper(c):判断c是否为大写字母\n\n- islower(c):判断c是否为小写字母  \n\n- isalpha(c):判断c是否为字母\n\n- isalnum(c):判断c是否为字母或者数字  \n\n- isprint(c):判断c是否是可显示的ASCII字符  \n\n- isspace(c):判断c是否为空字符\n\n- touper(c):将c转换成大写字符 \n\n- tolower(c):将c转换成小写字符 \n\n## 类型转换函数  \n\n- double atof(char*a):将字符串a转换成浮点数并返回  \n\n- int atoi(char*a):将字符串a转换成整数并返回  \n\n- long atol(char*a):将字符串a转换成长整型并返回  \n\n- char *itoa(int value,char *string,int radix):将整数value转换成字符串存入string  \n\n## 随机数函数  \n\n随机数函数定义在<stdlib>  \n\nrang()返回0～RAND_MAX中随机的一个整数  \n\nrang()的产生依赖于一个发生器序列，一般需要调用srand()函数初始化，初始值一般被称作随机种子  \n\n## 可变参数处理  \n\n<cstdarg>提供了几个宏和类型，以支持可变参数  \n\n- va_list：记录参数类型  \n\n- va_start(list,p0):建议扫描参数表的起始指针，并保存参数信息至va_list的变量list  \n\n- va_arg(list,type):提取参数表list中的参数，并转换成type类型  \n\n- va_end(list):结束可变参数处理  \n\n## 内存操作函数  \n\n<cstring>和<cstdlib>中定义了如下内存操作函数  \n\n- void *memchr(buffer,c,count):在内存中查找指定字符  \n\n- int memcmp(buf1,buf2,count):比较两块内存中的字符  \n\n- void *memcpy(dest,src,count):拷贝源内存块至目的的内存块  \n\n- void *memmove(dest,src,count):移动源内存块至目的内存块  \n\n- void *memset(dest,c,count):使用指定数值设置内存块的内容  \n\n- void *malloc(size):分配一块内存  \n\n- void *calloc(size,n):分配size\\*n字节的内存，并清零  \n\n- void *free(buffer):释放分配的内存  \n\n## 系统控制函数  \n\n<cstdlib>  \n\n- void abort():异常终止程序  \n\n- int exit(int status):终止当前程序  \n\n- int system(chat *command):执行Shell命令  \n\n# C++流  \n\n## 格式化输出流  \n\niostream提供了格式化输出函数，用以制定输出的格式  \n\n- width(n):将输出宽度设置为n个字符，默认情况下，输出宽度等于字符串实际长度  \n\n- idth():获取当前的宽度设置  \n\n- fill(ch):设置填充字符为ch，默认情况为空格  \n\n- fill():获取当前的填充字符  \n\n- precision(p):设置浮点数精度为p\n\n- precision():获取浮点数精度  \n\n- setf(m):打开格式化标志m  \n\n- unsetf(m):关闭格式化标志m  \n\n- setf(m1,m2):打开m1,关闭m2  \n\n格式化标志可以上网搜索\n\n## 格式操纵符  \n\n可以直接使用<<输出  \n\n格式操纵符见互联网  \n\n## 文件流  \n\n使用ofstream对象写入文件  \n\nopen打开文件 -> <<或者write函数写入文件 -> close关闭文件  \n\n使用ifstream对象读取文件  \n\nopen打开文件 -> >>或者read函数读取文件 -> close关闭文件  \n\n打开文件的模式包括  \n\nios::app:追加模式  \n\nios::ate:打开文件定位到文件尾  \n\nios::binary:二进制方式打开  \n\nios::in:输入方式打开  \n\nios::out:输出方式打开  \n\n可以配合|使用  \n\n- 文件的定位  \n\nifstream& seekg(streampos pos);\n","source":"_posts/C-高级特性.md","raw":"---\ntitle: C++_高级特性\ndate: 2019-09-07 19:16:38\ntags:\ncategories:\n---\n\nC++中的高级特性\n\n<!--more-->\n\n# 类的继承   \n\n继承可以理解为父子，子类继承父类的的基因，父类又称作基类，子类又称作派生类  \n\n派生类的写法：class A : B ;  \n\n## 内存中的派生类  \n\n在内存中派生类实际上是基类的内容加上自己的内容。  \n\n## protected  \n\n派生类可以访问到基类的保护成员，但不可以访问私有成员  \n\n## 基类访问控制  \n\n在定义派生类的基类列表时，可以指定对基类访问控制的类型，即继承方式。\n\n1. 公有继承时：原基类的非私有成员访问属性在派生类中不变\n\n2. 私有继承时：原基类的非私有成员访问属性在派生类中变为私有成员  \n\n3. 保护继承时：原基类的非私有成员访问属性在派生类中变为保护成员\n\n## 构造与析构  \n\n派生类不会继承基类的构造函数和析构函数  \n\n## 基类的初始化  \n\n派生类可以在构造函数中使用初始值列表对基类进行初始化  \n\n## 默认构造函数  \n\n隐式的默认构造函数创建有两个条件  \n\n1. 用户没有为该类创建任何构造函数  \n\n2. 如果为派生类，其基类必须要有默认构造函数，否则不知道如何初始化基类  \n\n## 派生类的析构  \n\n析构的顺序为：基类的构造在派生类之前，析构在派生类之后。\n\n## 名字隐藏  \n\n实质上就是跟探讨作用域的问题一样  \n\n派生类就如同局部，基类为全局;如果一个派生类和基类有一个数据成员一样，那么编译器会先找到派生类的数据成员，并且使用他。如若在派生类找不到才会向基类再去寻找。  \n\n# 类的多态性  \n\n继承与虚函数构成了多态性。\n\n## 向上转换  \n\n派生类可以转换为基类，但是基类不可以转换成派生类 \n\n## 向下转换  \n\n有时候，我们知道当前指针指向的对象为什么类型，可以使用强制转换完成向下转换  \n\n向下转换必须显式的向编译器提出，向下转换具有一定的风险，如果给定的并非是一个派生类的对象，那么，将他进行强制转换，是不可预料的。  \n\n## 虚函数  \n\n关键字virtual用以声明基类的某个函数为虚函数  \n\n我们通常把基类虚函数的实现称作“覆盖”。  \n\n## 虚析构函数  \n\n如果基类的虚析构函数不是虚函数，针对基类的析构操作将无法引起派生类的析构。  \n\n保险起见，一般建议将基类的析构函数声明为虚的\n\n## 纯虚函数  \n\n纯虚函数是一种特殊的虚函数，它没有函数的实现。  \n\nvirtual void say() = 0;  \n\n注意区分函数体为空的情形，不可再为虚函数定义函数体  \n\n## 抽象类  \n\n具有纯虚函数的类即为抽象类。抽象类不能被实例化  \n\n抽象类一般用来设计一套统一的接口，派生类必须实现其中的虚函数，才能被实例化。  \n\n## 多级继承  \n\n派生类的继承可以是任何一个合法的类，也可以继承于某一个派生类。  \n\n## 虚函数的多次填充  \n\n虚函数的特性是自动遗传的，也就是说，在基类定义了某个虚函数，不管派生类覆盖不覆盖这个函数，其属性仍然是虚的，那么，虚函数可以随着多级继承而被多次填充  \n\n## 多继承   \n\n派生类可以继承多个基类  \n\n## 多继承带来的问题  \n\n二义性和内存冗余即可能会在派生类的对象同时保存基类的多份复制  \n\n## 虚拟继承  \n\n可以实现多个派生类之间共同享受某个相同的基类  \n\n在要继承的基类名之前加virtual  \n\n在UML使用虚线表示虚拟继承  \n\n# 模板  \n\n函数模板即带有参数的函数\n\n模板的参数与函数的参数相似与不同  \n\n1. 函数的参数列表由()引起,模板的参数列表由<>括起\n\n2. 函数的参数为对象，模板的参数大部分为类型，例如：typename T。T的类型必须是typename或者class。  \n\n3. 函数的参数是0～N个，而模板的参数是1～N个  \n\n4. 函数模板也可以被重载  \n\n5. 使用模板时，可以不指定模板的参数。编译器根据实际调用正确猜测出模板参数的值  \n\n6. 模板的参数不能具有默认值，但是类模板中模板参数可以有默认值  \n\n## 函数模板的实例化  \n\n函数模板必须被实例化才能被正常调用 \n\n注意函数的实例化可以隐式完成  \n\n## 函数模板的重载   \n\n函数模板可以重载  \n\n普通的函数与模板函数同名同参数时，C++会优先选择普通函数  \n\n## 函数模板的特化  \n\n可以针对某个类型进行特化（？特殊化）。特化的函数以“template<>”开头  \n\n## 类模板  \n\n类模板的成员函数定义之前必须包含一段模板参数的声明  \n\n类模板可以声明多个参数  \n\n可以具有默认参数类型  \n\n# 异常处理  \n\n## 抛出异常  \n\n使用异常机制，就是在错误的地方，抛出一个异常变量。  \n\nthrow关键字用以抛出一个异常，这个异常可以是任何类型的对象。  \n\n## 捕获异常  \n\n可以使用try...catch捕获抛出的异常。try中文含义为尝试，catch为捕获，意思就是先尝试执行一段代码，如果捕获到异常，则执行catch的代码。\n\n## 捕获不同类型的异常  \n\n异常可以由程序员自定义异常类。  \n\n## 捕获所有异常  \n\n可以使用带有省略号的catch语句块，它用以捕获所有未经捕获的异常。  \n\n## 在catch块抛出异常  \n\n我们可以在catch语句块中再次抛出异常  \n\n## 未经捕获的异常  \n\n异常不一定都被捕获  \n\n如果一个异常没有被捕获，C++不知道怎么处理这个异常的情况下。它将会调用temiante()函数，默认情况下，该函数只会简单的调用abort()函数，用以中断程序的执行。  \n\n## 定制terminate()的行为  \n\n可以认为terminate()函数使用一个全局的函数指针进行调用  \n\n因此，可以使用set_terminate()函数来指定一个新的处理函数。  \n\n## 对抛出异常的声明  \n\n当声明函数的时候，可以同时指明该函数可能会抛出的异常  \n\n对抛出异常作出声明不是强制性的\n\n1. 如果一个函数可能抛出异常，不一定要使用throw抛出异常，反之一样  \n\n2. 声明的异常不必与实际抛出的类型相符  \n\n3. 在catch语句中，其捕获的异常不必与函数声明的异常中的类型相符  \n\n对抛出的异常作出声明，只是为了指导意义，为了让使用者知道调用此函数可能会带来的风险。  \n\n# 名字空间与域  \n\n用以解决名字冲突问题  \n\n## 名字空间定义  \n\n可以定义一个名字空间，将自己的类、和对象括起来。  \n\n## using声明  \n\nusing声明告诉编译器尝试从名字空间查找对象  \n\n## using指令   \n\n可以直接声明待使用的名字空间的成员名\n\n## 名字空间的别名  \n\n可以使用namespace为已定义的名字空间指定别名  \n\n## 作用域  \n\nC++支持三种作用域  \n\n## 局部作用域  \n\n1. 每段语句块都包含一个局部的作用域，在语句块声明的对象只在本语句块内部其作用  \n\n2. 局部变量的存储类型  \n\n局部变量可以具有不同的存储类型  \n\n- 自动存储类型：当程序执行超出当前作用域，变量自动销毁  \n\n- 寄存器存储类型：将变量存储在寄存器中进行存取，可以提高函数的执行程度，但是编译器有可能会选择其他方式处理  \n\n- 静态存储类型：超出局部作用域，静态局部变量不会被销毁  \n\n## 名字空间域  \n\n1. 由名字空间所指定的作用域  \n\n2. 外部存储类型：extern，可以在a源文件声明b源文件的对象  \n\n3. 最外成的空间即全局域  \n\n## 类域 \n\n类域包括定义体和所有的成员函数体  \n\n类可以具有static数据成员  \n\n作用域、语句块、名字空间、类都可以嵌套  \n\n语句块中定义的类为内部类  \n\n## 对象的生命周期  \n\n生命周期与作用域有某种关系，如：一段语句块中定义的自动对象在离开当前局部作用域的时候，总会被销毁。  \n\n# C++标准库  \n\n## 字符串库<string>\n\n1. 字符串的构造和赋值  \n\n由多个重复的字符构成的string：string s(8,'f')  \n\n2. 字符串连接  \n\n可以使用+号将两个字符串连接起来  \n\n3. 字符串可以用运算符直接比较  \n\n4. 字符串的下标  \n\n可以通过字符串的下标来访问字符串中的某个字符  \n\n通过length()获取字符串的长度  \n\n5. 子串：字符串中的一部分  \n\n6. 字符串的查找  \n\n可以从字符串中查找某个字串，并返回字串所在的位置，使用是string类的find()方法，查找失败返回-1  \n\n7. string与C-style字符串：可以通过c_str()函数获取string的字符数组，c_str返回的是一个const的字符指针，指向string内部的实际存储地址，值会随着string的改变。  \n\n8. 空字符串：不包含任何内容，使用clear()清空字符串，empty()判断字符串是否为空  \n\n## 复数类<complex>  \n\n1. 复数的构造  \n\ncomplex是一个类模板，它可以采用float、double、long double 3种类型进行定制，如：complex<double> c(1,2)  \n\n2. 复数可以进行四则运算  \n\n3. 复数的操作函数  \n\nreal()返回复数的实部  \n\nimag()返回复数的虚部  \n\nabs(x)返回复数x的模  \n\narg(x)返回复数x的相角  \n\nconj(x)返回复数x的共軛复数  \n\nnarm(x)返回复数x的模的平方  \n\n## 异常类<stdexcept>\n\n包含了C++中各种各样的异常  \n\n# C标准库  \n\n## assert宏  \n\n在<cassert>中定义一个很有用的宏：assert()用以调试代码  \n\n如果想取消掉assert()的功能，可以在包含<cassert>头文件之前定义NDEBUG宏：  \n\n## 类型函数  \n\n<cctype>定义了一堆字符处理函数和宏\n\n- isdigit(c):判断c是否为数字\n\n- isupper(c):判断c是否为大写字母\n\n- islower(c):判断c是否为小写字母  \n\n- isalpha(c):判断c是否为字母\n\n- isalnum(c):判断c是否为字母或者数字  \n\n- isprint(c):判断c是否是可显示的ASCII字符  \n\n- isspace(c):判断c是否为空字符\n\n- touper(c):将c转换成大写字符 \n\n- tolower(c):将c转换成小写字符 \n\n## 类型转换函数  \n\n- double atof(char*a):将字符串a转换成浮点数并返回  \n\n- int atoi(char*a):将字符串a转换成整数并返回  \n\n- long atol(char*a):将字符串a转换成长整型并返回  \n\n- char *itoa(int value,char *string,int radix):将整数value转换成字符串存入string  \n\n## 随机数函数  \n\n随机数函数定义在<stdlib>  \n\nrang()返回0～RAND_MAX中随机的一个整数  \n\nrang()的产生依赖于一个发生器序列，一般需要调用srand()函数初始化，初始值一般被称作随机种子  \n\n## 可变参数处理  \n\n<cstdarg>提供了几个宏和类型，以支持可变参数  \n\n- va_list：记录参数类型  \n\n- va_start(list,p0):建议扫描参数表的起始指针，并保存参数信息至va_list的变量list  \n\n- va_arg(list,type):提取参数表list中的参数，并转换成type类型  \n\n- va_end(list):结束可变参数处理  \n\n## 内存操作函数  \n\n<cstring>和<cstdlib>中定义了如下内存操作函数  \n\n- void *memchr(buffer,c,count):在内存中查找指定字符  \n\n- int memcmp(buf1,buf2,count):比较两块内存中的字符  \n\n- void *memcpy(dest,src,count):拷贝源内存块至目的的内存块  \n\n- void *memmove(dest,src,count):移动源内存块至目的内存块  \n\n- void *memset(dest,c,count):使用指定数值设置内存块的内容  \n\n- void *malloc(size):分配一块内存  \n\n- void *calloc(size,n):分配size\\*n字节的内存，并清零  \n\n- void *free(buffer):释放分配的内存  \n\n## 系统控制函数  \n\n<cstdlib>  \n\n- void abort():异常终止程序  \n\n- int exit(int status):终止当前程序  \n\n- int system(chat *command):执行Shell命令  \n\n# C++流  \n\n## 格式化输出流  \n\niostream提供了格式化输出函数，用以制定输出的格式  \n\n- width(n):将输出宽度设置为n个字符，默认情况下，输出宽度等于字符串实际长度  \n\n- idth():获取当前的宽度设置  \n\n- fill(ch):设置填充字符为ch，默认情况为空格  \n\n- fill():获取当前的填充字符  \n\n- precision(p):设置浮点数精度为p\n\n- precision():获取浮点数精度  \n\n- setf(m):打开格式化标志m  \n\n- unsetf(m):关闭格式化标志m  \n\n- setf(m1,m2):打开m1,关闭m2  \n\n格式化标志可以上网搜索\n\n## 格式操纵符  \n\n可以直接使用<<输出  \n\n格式操纵符见互联网  \n\n## 文件流  \n\n使用ofstream对象写入文件  \n\nopen打开文件 -> <<或者write函数写入文件 -> close关闭文件  \n\n使用ifstream对象读取文件  \n\nopen打开文件 -> >>或者read函数读取文件 -> close关闭文件  \n\n打开文件的模式包括  \n\nios::app:追加模式  \n\nios::ate:打开文件定位到文件尾  \n\nios::binary:二进制方式打开  \n\nios::in:输入方式打开  \n\nios::out:输出方式打开  \n\n可以配合|使用  \n\n- 文件的定位  \n\nifstream& seekg(streampos pos);\n","slug":"C-高级特性","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akptl00087qsgcakzcumd","content":"<p>C++中的高级特性</p>\n<a id=\"more\"></a>\n<h1 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h1><p>继承可以理解为父子，子类继承父类的的基因，父类又称作基类，子类又称作派生类  </p>\n<p>派生类的写法：class A : B ;  </p>\n<h2 id=\"内存中的派生类\"><a href=\"#内存中的派生类\" class=\"headerlink\" title=\"内存中的派生类\"></a>内存中的派生类</h2><p>在内存中派生类实际上是基类的内容加上自己的内容。  </p>\n<h2 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h2><p>派生类可以访问到基类的保护成员，但不可以访问私有成员  </p>\n<h2 id=\"基类访问控制\"><a href=\"#基类访问控制\" class=\"headerlink\" title=\"基类访问控制\"></a>基类访问控制</h2><p>在定义派生类的基类列表时，可以指定对基类访问控制的类型，即继承方式。</p>\n<ol>\n<li><p>公有继承时：原基类的非私有成员访问属性在派生类中不变</p>\n</li>\n<li><p>私有继承时：原基类的非私有成员访问属性在派生类中变为私有成员  </p>\n</li>\n<li><p>保护继承时：原基类的非私有成员访问属性在派生类中变为保护成员</p>\n</li>\n</ol>\n<h2 id=\"构造与析构\"><a href=\"#构造与析构\" class=\"headerlink\" title=\"构造与析构\"></a>构造与析构</h2><p>派生类不会继承基类的构造函数和析构函数  </p>\n<h2 id=\"基类的初始化\"><a href=\"#基类的初始化\" class=\"headerlink\" title=\"基类的初始化\"></a>基类的初始化</h2><p>派生类可以在构造函数中使用初始值列表对基类进行初始化  </p>\n<h2 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h2><p>隐式的默认构造函数创建有两个条件  </p>\n<ol>\n<li><p>用户没有为该类创建任何构造函数  </p>\n</li>\n<li><p>如果为派生类，其基类必须要有默认构造函数，否则不知道如何初始化基类  </p>\n</li>\n</ol>\n<h2 id=\"派生类的析构\"><a href=\"#派生类的析构\" class=\"headerlink\" title=\"派生类的析构\"></a>派生类的析构</h2><p>析构的顺序为：基类的构造在派生类之前，析构在派生类之后。</p>\n<h2 id=\"名字隐藏\"><a href=\"#名字隐藏\" class=\"headerlink\" title=\"名字隐藏\"></a>名字隐藏</h2><p>实质上就是跟探讨作用域的问题一样  </p>\n<p>派生类就如同局部，基类为全局;如果一个派生类和基类有一个数据成员一样，那么编译器会先找到派生类的数据成员，并且使用他。如若在派生类找不到才会向基类再去寻找。  </p>\n<h1 id=\"类的多态性\"><a href=\"#类的多态性\" class=\"headerlink\" title=\"类的多态性\"></a>类的多态性</h1><p>继承与虚函数构成了多态性。</p>\n<h2 id=\"向上转换\"><a href=\"#向上转换\" class=\"headerlink\" title=\"向上转换\"></a>向上转换</h2><p>派生类可以转换为基类，但是基类不可以转换成派生类 </p>\n<h2 id=\"向下转换\"><a href=\"#向下转换\" class=\"headerlink\" title=\"向下转换\"></a>向下转换</h2><p>有时候，我们知道当前指针指向的对象为什么类型，可以使用强制转换完成向下转换  </p>\n<p>向下转换必须显式的向编译器提出，向下转换具有一定的风险，如果给定的并非是一个派生类的对象，那么，将他进行强制转换，是不可预料的。  </p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>关键字virtual用以声明基类的某个函数为虚函数  </p>\n<p>我们通常把基类虚函数的实现称作“覆盖”。  </p>\n<h2 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h2><p>如果基类的虚析构函数不是虚函数，针对基类的析构操作将无法引起派生类的析构。  </p>\n<p>保险起见，一般建议将基类的析构函数声明为虚的</p>\n<h2 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h2><p>纯虚函数是一种特殊的虚函数，它没有函数的实现。  </p>\n<p>virtual void say() = 0;  </p>\n<p>注意区分函数体为空的情形，不可再为虚函数定义函数体  </p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>具有纯虚函数的类即为抽象类。抽象类不能被实例化  </p>\n<p>抽象类一般用来设计一套统一的接口，派生类必须实现其中的虚函数，才能被实例化。  </p>\n<h2 id=\"多级继承\"><a href=\"#多级继承\" class=\"headerlink\" title=\"多级继承\"></a>多级继承</h2><p>派生类的继承可以是任何一个合法的类，也可以继承于某一个派生类。  </p>\n<h2 id=\"虚函数的多次填充\"><a href=\"#虚函数的多次填充\" class=\"headerlink\" title=\"虚函数的多次填充\"></a>虚函数的多次填充</h2><p>虚函数的特性是自动遗传的，也就是说，在基类定义了某个虚函数，不管派生类覆盖不覆盖这个函数，其属性仍然是虚的，那么，虚函数可以随着多级继承而被多次填充  </p>\n<h2 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h2><p>派生类可以继承多个基类  </p>\n<h2 id=\"多继承带来的问题\"><a href=\"#多继承带来的问题\" class=\"headerlink\" title=\"多继承带来的问题\"></a>多继承带来的问题</h2><p>二义性和内存冗余即可能会在派生类的对象同时保存基类的多份复制  </p>\n<h2 id=\"虚拟继承\"><a href=\"#虚拟继承\" class=\"headerlink\" title=\"虚拟继承\"></a>虚拟继承</h2><p>可以实现多个派生类之间共同享受某个相同的基类  </p>\n<p>在要继承的基类名之前加virtual  </p>\n<p>在UML使用虚线表示虚拟继承  </p>\n<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1><p>函数模板即带有参数的函数</p>\n<p>模板的参数与函数的参数相似与不同  </p>\n<ol>\n<li><p>函数的参数列表由()引起,模板的参数列表由&lt;&gt;括起</p>\n</li>\n<li><p>函数的参数为对象，模板的参数大部分为类型，例如：typename T。T的类型必须是typename或者class。  </p>\n</li>\n<li><p>函数的参数是0～N个，而模板的参数是1～N个  </p>\n</li>\n<li><p>函数模板也可以被重载  </p>\n</li>\n<li><p>使用模板时，可以不指定模板的参数。编译器根据实际调用正确猜测出模板参数的值  </p>\n</li>\n<li><p>模板的参数不能具有默认值，但是类模板中模板参数可以有默认值  </p>\n</li>\n</ol>\n<h2 id=\"函数模板的实例化\"><a href=\"#函数模板的实例化\" class=\"headerlink\" title=\"函数模板的实例化\"></a>函数模板的实例化</h2><p>函数模板必须被实例化才能被正常调用 </p>\n<p>注意函数的实例化可以隐式完成  </p>\n<h2 id=\"函数模板的重载\"><a href=\"#函数模板的重载\" class=\"headerlink\" title=\"函数模板的重载\"></a>函数模板的重载</h2><p>函数模板可以重载  </p>\n<p>普通的函数与模板函数同名同参数时，C++会优先选择普通函数  </p>\n<h2 id=\"函数模板的特化\"><a href=\"#函数模板的特化\" class=\"headerlink\" title=\"函数模板的特化\"></a>函数模板的特化</h2><p>可以针对某个类型进行特化（？特殊化）。特化的函数以“template&lt;&gt;”开头  </p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>类模板的成员函数定义之前必须包含一段模板参数的声明  </p>\n<p>类模板可以声明多个参数  </p>\n<p>可以具有默认参数类型  </p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><h2 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h2><p>使用异常机制，就是在错误的地方，抛出一个异常变量。  </p>\n<p>throw关键字用以抛出一个异常，这个异常可以是任何类型的对象。  </p>\n<h2 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h2><p>可以使用try…catch捕获抛出的异常。try中文含义为尝试，catch为捕获，意思就是先尝试执行一段代码，如果捕获到异常，则执行catch的代码。</p>\n<h2 id=\"捕获不同类型的异常\"><a href=\"#捕获不同类型的异常\" class=\"headerlink\" title=\"捕获不同类型的异常\"></a>捕获不同类型的异常</h2><p>异常可以由程序员自定义异常类。  </p>\n<h2 id=\"捕获所有异常\"><a href=\"#捕获所有异常\" class=\"headerlink\" title=\"捕获所有异常\"></a>捕获所有异常</h2><p>可以使用带有省略号的catch语句块，它用以捕获所有未经捕获的异常。  </p>\n<h2 id=\"在catch块抛出异常\"><a href=\"#在catch块抛出异常\" class=\"headerlink\" title=\"在catch块抛出异常\"></a>在catch块抛出异常</h2><p>我们可以在catch语句块中再次抛出异常  </p>\n<h2 id=\"未经捕获的异常\"><a href=\"#未经捕获的异常\" class=\"headerlink\" title=\"未经捕获的异常\"></a>未经捕获的异常</h2><p>异常不一定都被捕获  </p>\n<p>如果一个异常没有被捕获，C++不知道怎么处理这个异常的情况下。它将会调用temiante()函数，默认情况下，该函数只会简单的调用abort()函数，用以中断程序的执行。  </p>\n<h2 id=\"定制terminate-的行为\"><a href=\"#定制terminate-的行为\" class=\"headerlink\" title=\"定制terminate()的行为\"></a>定制terminate()的行为</h2><p>可以认为terminate()函数使用一个全局的函数指针进行调用  </p>\n<p>因此，可以使用set_terminate()函数来指定一个新的处理函数。  </p>\n<h2 id=\"对抛出异常的声明\"><a href=\"#对抛出异常的声明\" class=\"headerlink\" title=\"对抛出异常的声明\"></a>对抛出异常的声明</h2><p>当声明函数的时候，可以同时指明该函数可能会抛出的异常  </p>\n<p>对抛出异常作出声明不是强制性的</p>\n<ol>\n<li><p>如果一个函数可能抛出异常，不一定要使用throw抛出异常，反之一样  </p>\n</li>\n<li><p>声明的异常不必与实际抛出的类型相符  </p>\n</li>\n<li><p>在catch语句中，其捕获的异常不必与函数声明的异常中的类型相符  </p>\n</li>\n</ol>\n<p>对抛出的异常作出声明，只是为了指导意义，为了让使用者知道调用此函数可能会带来的风险。  </p>\n<h1 id=\"名字空间与域\"><a href=\"#名字空间与域\" class=\"headerlink\" title=\"名字空间与域\"></a>名字空间与域</h1><p>用以解决名字冲突问题  </p>\n<h2 id=\"名字空间定义\"><a href=\"#名字空间定义\" class=\"headerlink\" title=\"名字空间定义\"></a>名字空间定义</h2><p>可以定义一个名字空间，将自己的类、和对象括起来。  </p>\n<h2 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a>using声明</h2><p>using声明告诉编译器尝试从名字空间查找对象  </p>\n<h2 id=\"using指令\"><a href=\"#using指令\" class=\"headerlink\" title=\"using指令\"></a>using指令</h2><p>可以直接声明待使用的名字空间的成员名</p>\n<h2 id=\"名字空间的别名\"><a href=\"#名字空间的别名\" class=\"headerlink\" title=\"名字空间的别名\"></a>名字空间的别名</h2><p>可以使用namespace为已定义的名字空间指定别名  </p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>C++支持三种作用域  </p>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h2><ol>\n<li><p>每段语句块都包含一个局部的作用域，在语句块声明的对象只在本语句块内部其作用  </p>\n</li>\n<li><p>局部变量的存储类型  </p>\n</li>\n</ol>\n<p>局部变量可以具有不同的存储类型  </p>\n<ul>\n<li><p>自动存储类型：当程序执行超出当前作用域，变量自动销毁  </p>\n</li>\n<li><p>寄存器存储类型：将变量存储在寄存器中进行存取，可以提高函数的执行程度，但是编译器有可能会选择其他方式处理  </p>\n</li>\n<li><p>静态存储类型：超出局部作用域，静态局部变量不会被销毁  </p>\n</li>\n</ul>\n<h2 id=\"名字空间域\"><a href=\"#名字空间域\" class=\"headerlink\" title=\"名字空间域\"></a>名字空间域</h2><ol>\n<li><p>由名字空间所指定的作用域  </p>\n</li>\n<li><p>外部存储类型：extern，可以在a源文件声明b源文件的对象  </p>\n</li>\n<li><p>最外成的空间即全局域  </p>\n</li>\n</ol>\n<h2 id=\"类域\"><a href=\"#类域\" class=\"headerlink\" title=\"类域\"></a>类域</h2><p>类域包括定义体和所有的成员函数体  </p>\n<p>类可以具有static数据成员  </p>\n<p>作用域、语句块、名字空间、类都可以嵌套  </p>\n<p>语句块中定义的类为内部类  </p>\n<h2 id=\"对象的生命周期\"><a href=\"#对象的生命周期\" class=\"headerlink\" title=\"对象的生命周期\"></a>对象的生命周期</h2><p>生命周期与作用域有某种关系，如：一段语句块中定义的自动对象在离开当前局部作用域的时候，总会被销毁。  </p>\n<h1 id=\"C-标准库\"><a href=\"#C-标准库\" class=\"headerlink\" title=\"C++标准库\"></a>C++标准库</h1><h2 id=\"字符串库\"><a href=\"#字符串库\" class=\"headerlink\" title=\"字符串库\"></a>字符串库<string></string></h2><ol>\n<li>字符串的构造和赋值  </li>\n</ol>\n<p>由多个重复的字符构成的string：string s(8,’f’)  </p>\n<ol start=\"2\">\n<li>字符串连接  </li>\n</ol>\n<p>可以使用+号将两个字符串连接起来  </p>\n<ol start=\"3\">\n<li><p>字符串可以用运算符直接比较  </p>\n</li>\n<li><p>字符串的下标  </p>\n</li>\n</ol>\n<p>可以通过字符串的下标来访问字符串中的某个字符  </p>\n<p>通过length()获取字符串的长度  </p>\n<ol start=\"5\">\n<li><p>子串：字符串中的一部分  </p>\n</li>\n<li><p>字符串的查找  </p>\n</li>\n</ol>\n<p>可以从字符串中查找某个字串，并返回字串所在的位置，使用是string类的find()方法，查找失败返回-1  </p>\n<ol start=\"7\">\n<li><p>string与C-style字符串：可以通过c_str()函数获取string的字符数组，c_str返回的是一个const的字符指针，指向string内部的实际存储地址，值会随着string的改变。  </p>\n</li>\n<li><p>空字符串：不包含任何内容，使用clear()清空字符串，empty()判断字符串是否为空  </p>\n</li>\n</ol>\n<h2 id=\"复数类\"><a href=\"#复数类\" class=\"headerlink\" title=\"复数类\"></a>复数类<complex></complex></h2><ol>\n<li>复数的构造  </li>\n</ol>\n<p>complex是一个类模板，它可以采用float、double、long double 3种类型进行定制，如：complex<double> c(1,2)  </double></p>\n<ol start=\"2\">\n<li><p>复数可以进行四则运算  </p>\n</li>\n<li><p>复数的操作函数  </p>\n</li>\n</ol>\n<p>real()返回复数的实部  </p>\n<p>imag()返回复数的虚部  </p>\n<p>abs(x)返回复数x的模  </p>\n<p>arg(x)返回复数x的相角  </p>\n<p>conj(x)返回复数x的共軛复数  </p>\n<p>narm(x)返回复数x的模的平方  </p>\n<h2 id=\"异常类\"><a href=\"#异常类\" class=\"headerlink\" title=\"异常类\"></a>异常类<stdexcept></stdexcept></h2><p>包含了C++中各种各样的异常  </p>\n<h1 id=\"C标准库\"><a href=\"#C标准库\" class=\"headerlink\" title=\"C标准库\"></a>C标准库</h1><h2 id=\"assert宏\"><a href=\"#assert宏\" class=\"headerlink\" title=\"assert宏\"></a>assert宏</h2><p>在<cassert>中定义一个很有用的宏：assert()用以调试代码  </cassert></p>\n<p>如果想取消掉assert()的功能，可以在包含<cassert>头文件之前定义NDEBUG宏：  </cassert></p>\n<h2 id=\"类型函数\"><a href=\"#类型函数\" class=\"headerlink\" title=\"类型函数\"></a>类型函数</h2><p><cctype>定义了一堆字符处理函数和宏</cctype></p>\n<ul>\n<li><p>isdigit(c):判断c是否为数字</p>\n</li>\n<li><p>isupper(c):判断c是否为大写字母</p>\n</li>\n<li><p>islower(c):判断c是否为小写字母  </p>\n</li>\n<li><p>isalpha(c):判断c是否为字母</p>\n</li>\n<li><p>isalnum(c):判断c是否为字母或者数字  </p>\n</li>\n<li><p>isprint(c):判断c是否是可显示的ASCII字符  </p>\n</li>\n<li><p>isspace(c):判断c是否为空字符</p>\n</li>\n<li><p>touper(c):将c转换成大写字符 </p>\n</li>\n<li><p>tolower(c):将c转换成小写字符 </p>\n</li>\n</ul>\n<h2 id=\"类型转换函数\"><a href=\"#类型转换函数\" class=\"headerlink\" title=\"类型转换函数\"></a>类型转换函数</h2><ul>\n<li><p>double atof(char*a):将字符串a转换成浮点数并返回  </p>\n</li>\n<li><p>int atoi(char*a):将字符串a转换成整数并返回  </p>\n</li>\n<li><p>long atol(char*a):将字符串a转换成长整型并返回  </p>\n</li>\n<li><p>char <em>itoa(int value,char </em>string,int radix):将整数value转换成字符串存入string  </p>\n</li>\n</ul>\n<h2 id=\"随机数函数\"><a href=\"#随机数函数\" class=\"headerlink\" title=\"随机数函数\"></a>随机数函数</h2><p>随机数函数定义在<stdlib>  </stdlib></p>\n<p>rang()返回0～RAND_MAX中随机的一个整数  </p>\n<p>rang()的产生依赖于一个发生器序列，一般需要调用srand()函数初始化，初始值一般被称作随机种子  </p>\n<h2 id=\"可变参数处理\"><a href=\"#可变参数处理\" class=\"headerlink\" title=\"可变参数处理\"></a>可变参数处理</h2><p><cstdarg>提供了几个宏和类型，以支持可变参数  </cstdarg></p>\n<ul>\n<li><p>va_list：记录参数类型  </p>\n</li>\n<li><p>va_start(list,p0):建议扫描参数表的起始指针，并保存参数信息至va_list的变量list  </p>\n</li>\n<li><p>va_arg(list,type):提取参数表list中的参数，并转换成type类型  </p>\n</li>\n<li><p>va_end(list):结束可变参数处理  </p>\n</li>\n</ul>\n<h2 id=\"内存操作函数\"><a href=\"#内存操作函数\" class=\"headerlink\" title=\"内存操作函数\"></a>内存操作函数</h2><p><cstring>和<cstdlib>中定义了如下内存操作函数  </cstdlib></cstring></p>\n<ul>\n<li><p>void *memchr(buffer,c,count):在内存中查找指定字符  </p>\n</li>\n<li><p>int memcmp(buf1,buf2,count):比较两块内存中的字符  </p>\n</li>\n<li><p>void *memcpy(dest,src,count):拷贝源内存块至目的的内存块  </p>\n</li>\n<li><p>void *memmove(dest,src,count):移动源内存块至目的内存块  </p>\n</li>\n<li><p>void *memset(dest,c,count):使用指定数值设置内存块的内容  </p>\n</li>\n<li><p>void *malloc(size):分配一块内存  </p>\n</li>\n<li><p>void <em>calloc(size,n):分配size\\</em>n字节的内存，并清零  </p>\n</li>\n<li><p>void *free(buffer):释放分配的内存  </p>\n</li>\n</ul>\n<h2 id=\"系统控制函数\"><a href=\"#系统控制函数\" class=\"headerlink\" title=\"系统控制函数\"></a>系统控制函数</h2><cstdlib>  \n\n<ul>\n<li><p>void abort():异常终止程序  </p>\n</li>\n<li><p>int exit(int status):终止当前程序  </p>\n</li>\n<li><p>int system(chat *command):执行Shell命令  </p>\n</li>\n</ul>\n<h1 id=\"C-流\"><a href=\"#C-流\" class=\"headerlink\" title=\"C++流\"></a>C++流</h1><h2 id=\"格式化输出流\"><a href=\"#格式化输出流\" class=\"headerlink\" title=\"格式化输出流\"></a>格式化输出流</h2><p>iostream提供了格式化输出函数，用以制定输出的格式  </p>\n<ul>\n<li><p>width(n):将输出宽度设置为n个字符，默认情况下，输出宽度等于字符串实际长度  </p>\n</li>\n<li><p>idth():获取当前的宽度设置  </p>\n</li>\n<li><p>fill(ch):设置填充字符为ch，默认情况为空格  </p>\n</li>\n<li><p>fill():获取当前的填充字符  </p>\n</li>\n<li><p>precision(p):设置浮点数精度为p</p>\n</li>\n<li><p>precision():获取浮点数精度  </p>\n</li>\n<li><p>setf(m):打开格式化标志m  </p>\n</li>\n<li><p>unsetf(m):关闭格式化标志m  </p>\n</li>\n<li><p>setf(m1,m2):打开m1,关闭m2  </p>\n</li>\n</ul>\n<p>格式化标志可以上网搜索</p>\n<h2 id=\"格式操纵符\"><a href=\"#格式操纵符\" class=\"headerlink\" title=\"格式操纵符\"></a>格式操纵符</h2><p>可以直接使用&lt;&lt;输出  </p>\n<p>格式操纵符见互联网  </p>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><p>使用ofstream对象写入文件  </p>\n<p>open打开文件 -&gt; &lt;&lt;或者write函数写入文件 -&gt; close关闭文件  </p>\n<p>使用ifstream对象读取文件  </p>\n<p>open打开文件 -&gt; &gt;&gt;或者read函数读取文件 -&gt; close关闭文件  </p>\n<p>打开文件的模式包括  </p>\n<p>ios::app:追加模式  </p>\n<p>ios::ate:打开文件定位到文件尾  </p>\n<p>ios::binary:二进制方式打开  </p>\n<p>ios::in:输入方式打开  </p>\n<p>ios::out:输出方式打开  </p>\n<p>可以配合|使用  </p>\n<ul>\n<li>文件的定位  </li>\n</ul>\n<p>ifstream&amp; seekg(streampos pos);</p>\n</cstdlib>","site":{"data":{}},"excerpt":"<p>C++中的高级特性</p>","more":"<h1 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h1><p>继承可以理解为父子，子类继承父类的的基因，父类又称作基类，子类又称作派生类  </p>\n<p>派生类的写法：class A : B ;  </p>\n<h2 id=\"内存中的派生类\"><a href=\"#内存中的派生类\" class=\"headerlink\" title=\"内存中的派生类\"></a>内存中的派生类</h2><p>在内存中派生类实际上是基类的内容加上自己的内容。  </p>\n<h2 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a>protected</h2><p>派生类可以访问到基类的保护成员，但不可以访问私有成员  </p>\n<h2 id=\"基类访问控制\"><a href=\"#基类访问控制\" class=\"headerlink\" title=\"基类访问控制\"></a>基类访问控制</h2><p>在定义派生类的基类列表时，可以指定对基类访问控制的类型，即继承方式。</p>\n<ol>\n<li><p>公有继承时：原基类的非私有成员访问属性在派生类中不变</p>\n</li>\n<li><p>私有继承时：原基类的非私有成员访问属性在派生类中变为私有成员  </p>\n</li>\n<li><p>保护继承时：原基类的非私有成员访问属性在派生类中变为保护成员</p>\n</li>\n</ol>\n<h2 id=\"构造与析构\"><a href=\"#构造与析构\" class=\"headerlink\" title=\"构造与析构\"></a>构造与析构</h2><p>派生类不会继承基类的构造函数和析构函数  </p>\n<h2 id=\"基类的初始化\"><a href=\"#基类的初始化\" class=\"headerlink\" title=\"基类的初始化\"></a>基类的初始化</h2><p>派生类可以在构造函数中使用初始值列表对基类进行初始化  </p>\n<h2 id=\"默认构造函数\"><a href=\"#默认构造函数\" class=\"headerlink\" title=\"默认构造函数\"></a>默认构造函数</h2><p>隐式的默认构造函数创建有两个条件  </p>\n<ol>\n<li><p>用户没有为该类创建任何构造函数  </p>\n</li>\n<li><p>如果为派生类，其基类必须要有默认构造函数，否则不知道如何初始化基类  </p>\n</li>\n</ol>\n<h2 id=\"派生类的析构\"><a href=\"#派生类的析构\" class=\"headerlink\" title=\"派生类的析构\"></a>派生类的析构</h2><p>析构的顺序为：基类的构造在派生类之前，析构在派生类之后。</p>\n<h2 id=\"名字隐藏\"><a href=\"#名字隐藏\" class=\"headerlink\" title=\"名字隐藏\"></a>名字隐藏</h2><p>实质上就是跟探讨作用域的问题一样  </p>\n<p>派生类就如同局部，基类为全局;如果一个派生类和基类有一个数据成员一样，那么编译器会先找到派生类的数据成员，并且使用他。如若在派生类找不到才会向基类再去寻找。  </p>\n<h1 id=\"类的多态性\"><a href=\"#类的多态性\" class=\"headerlink\" title=\"类的多态性\"></a>类的多态性</h1><p>继承与虚函数构成了多态性。</p>\n<h2 id=\"向上转换\"><a href=\"#向上转换\" class=\"headerlink\" title=\"向上转换\"></a>向上转换</h2><p>派生类可以转换为基类，但是基类不可以转换成派生类 </p>\n<h2 id=\"向下转换\"><a href=\"#向下转换\" class=\"headerlink\" title=\"向下转换\"></a>向下转换</h2><p>有时候，我们知道当前指针指向的对象为什么类型，可以使用强制转换完成向下转换  </p>\n<p>向下转换必须显式的向编译器提出，向下转换具有一定的风险，如果给定的并非是一个派生类的对象，那么，将他进行强制转换，是不可预料的。  </p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>关键字virtual用以声明基类的某个函数为虚函数  </p>\n<p>我们通常把基类虚函数的实现称作“覆盖”。  </p>\n<h2 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h2><p>如果基类的虚析构函数不是虚函数，针对基类的析构操作将无法引起派生类的析构。  </p>\n<p>保险起见，一般建议将基类的析构函数声明为虚的</p>\n<h2 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h2><p>纯虚函数是一种特殊的虚函数，它没有函数的实现。  </p>\n<p>virtual void say() = 0;  </p>\n<p>注意区分函数体为空的情形，不可再为虚函数定义函数体  </p>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>具有纯虚函数的类即为抽象类。抽象类不能被实例化  </p>\n<p>抽象类一般用来设计一套统一的接口，派生类必须实现其中的虚函数，才能被实例化。  </p>\n<h2 id=\"多级继承\"><a href=\"#多级继承\" class=\"headerlink\" title=\"多级继承\"></a>多级继承</h2><p>派生类的继承可以是任何一个合法的类，也可以继承于某一个派生类。  </p>\n<h2 id=\"虚函数的多次填充\"><a href=\"#虚函数的多次填充\" class=\"headerlink\" title=\"虚函数的多次填充\"></a>虚函数的多次填充</h2><p>虚函数的特性是自动遗传的，也就是说，在基类定义了某个虚函数，不管派生类覆盖不覆盖这个函数，其属性仍然是虚的，那么，虚函数可以随着多级继承而被多次填充  </p>\n<h2 id=\"多继承\"><a href=\"#多继承\" class=\"headerlink\" title=\"多继承\"></a>多继承</h2><p>派生类可以继承多个基类  </p>\n<h2 id=\"多继承带来的问题\"><a href=\"#多继承带来的问题\" class=\"headerlink\" title=\"多继承带来的问题\"></a>多继承带来的问题</h2><p>二义性和内存冗余即可能会在派生类的对象同时保存基类的多份复制  </p>\n<h2 id=\"虚拟继承\"><a href=\"#虚拟继承\" class=\"headerlink\" title=\"虚拟继承\"></a>虚拟继承</h2><p>可以实现多个派生类之间共同享受某个相同的基类  </p>\n<p>在要继承的基类名之前加virtual  </p>\n<p>在UML使用虚线表示虚拟继承  </p>\n<h1 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h1><p>函数模板即带有参数的函数</p>\n<p>模板的参数与函数的参数相似与不同  </p>\n<ol>\n<li><p>函数的参数列表由()引起,模板的参数列表由&lt;&gt;括起</p>\n</li>\n<li><p>函数的参数为对象，模板的参数大部分为类型，例如：typename T。T的类型必须是typename或者class。  </p>\n</li>\n<li><p>函数的参数是0～N个，而模板的参数是1～N个  </p>\n</li>\n<li><p>函数模板也可以被重载  </p>\n</li>\n<li><p>使用模板时，可以不指定模板的参数。编译器根据实际调用正确猜测出模板参数的值  </p>\n</li>\n<li><p>模板的参数不能具有默认值，但是类模板中模板参数可以有默认值  </p>\n</li>\n</ol>\n<h2 id=\"函数模板的实例化\"><a href=\"#函数模板的实例化\" class=\"headerlink\" title=\"函数模板的实例化\"></a>函数模板的实例化</h2><p>函数模板必须被实例化才能被正常调用 </p>\n<p>注意函数的实例化可以隐式完成  </p>\n<h2 id=\"函数模板的重载\"><a href=\"#函数模板的重载\" class=\"headerlink\" title=\"函数模板的重载\"></a>函数模板的重载</h2><p>函数模板可以重载  </p>\n<p>普通的函数与模板函数同名同参数时，C++会优先选择普通函数  </p>\n<h2 id=\"函数模板的特化\"><a href=\"#函数模板的特化\" class=\"headerlink\" title=\"函数模板的特化\"></a>函数模板的特化</h2><p>可以针对某个类型进行特化（？特殊化）。特化的函数以“template&lt;&gt;”开头  </p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><p>类模板的成员函数定义之前必须包含一段模板参数的声明  </p>\n<p>类模板可以声明多个参数  </p>\n<p>可以具有默认参数类型  </p>\n<h1 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h1><h2 id=\"抛出异常\"><a href=\"#抛出异常\" class=\"headerlink\" title=\"抛出异常\"></a>抛出异常</h2><p>使用异常机制，就是在错误的地方，抛出一个异常变量。  </p>\n<p>throw关键字用以抛出一个异常，这个异常可以是任何类型的对象。  </p>\n<h2 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h2><p>可以使用try…catch捕获抛出的异常。try中文含义为尝试，catch为捕获，意思就是先尝试执行一段代码，如果捕获到异常，则执行catch的代码。</p>\n<h2 id=\"捕获不同类型的异常\"><a href=\"#捕获不同类型的异常\" class=\"headerlink\" title=\"捕获不同类型的异常\"></a>捕获不同类型的异常</h2><p>异常可以由程序员自定义异常类。  </p>\n<h2 id=\"捕获所有异常\"><a href=\"#捕获所有异常\" class=\"headerlink\" title=\"捕获所有异常\"></a>捕获所有异常</h2><p>可以使用带有省略号的catch语句块，它用以捕获所有未经捕获的异常。  </p>\n<h2 id=\"在catch块抛出异常\"><a href=\"#在catch块抛出异常\" class=\"headerlink\" title=\"在catch块抛出异常\"></a>在catch块抛出异常</h2><p>我们可以在catch语句块中再次抛出异常  </p>\n<h2 id=\"未经捕获的异常\"><a href=\"#未经捕获的异常\" class=\"headerlink\" title=\"未经捕获的异常\"></a>未经捕获的异常</h2><p>异常不一定都被捕获  </p>\n<p>如果一个异常没有被捕获，C++不知道怎么处理这个异常的情况下。它将会调用temiante()函数，默认情况下，该函数只会简单的调用abort()函数，用以中断程序的执行。  </p>\n<h2 id=\"定制terminate-的行为\"><a href=\"#定制terminate-的行为\" class=\"headerlink\" title=\"定制terminate()的行为\"></a>定制terminate()的行为</h2><p>可以认为terminate()函数使用一个全局的函数指针进行调用  </p>\n<p>因此，可以使用set_terminate()函数来指定一个新的处理函数。  </p>\n<h2 id=\"对抛出异常的声明\"><a href=\"#对抛出异常的声明\" class=\"headerlink\" title=\"对抛出异常的声明\"></a>对抛出异常的声明</h2><p>当声明函数的时候，可以同时指明该函数可能会抛出的异常  </p>\n<p>对抛出异常作出声明不是强制性的</p>\n<ol>\n<li><p>如果一个函数可能抛出异常，不一定要使用throw抛出异常，反之一样  </p>\n</li>\n<li><p>声明的异常不必与实际抛出的类型相符  </p>\n</li>\n<li><p>在catch语句中，其捕获的异常不必与函数声明的异常中的类型相符  </p>\n</li>\n</ol>\n<p>对抛出的异常作出声明，只是为了指导意义，为了让使用者知道调用此函数可能会带来的风险。  </p>\n<h1 id=\"名字空间与域\"><a href=\"#名字空间与域\" class=\"headerlink\" title=\"名字空间与域\"></a>名字空间与域</h1><p>用以解决名字冲突问题  </p>\n<h2 id=\"名字空间定义\"><a href=\"#名字空间定义\" class=\"headerlink\" title=\"名字空间定义\"></a>名字空间定义</h2><p>可以定义一个名字空间，将自己的类、和对象括起来。  </p>\n<h2 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a>using声明</h2><p>using声明告诉编译器尝试从名字空间查找对象  </p>\n<h2 id=\"using指令\"><a href=\"#using指令\" class=\"headerlink\" title=\"using指令\"></a>using指令</h2><p>可以直接声明待使用的名字空间的成员名</p>\n<h2 id=\"名字空间的别名\"><a href=\"#名字空间的别名\" class=\"headerlink\" title=\"名字空间的别名\"></a>名字空间的别名</h2><p>可以使用namespace为已定义的名字空间指定别名  </p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>C++支持三种作用域  </p>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h2><ol>\n<li><p>每段语句块都包含一个局部的作用域，在语句块声明的对象只在本语句块内部其作用  </p>\n</li>\n<li><p>局部变量的存储类型  </p>\n</li>\n</ol>\n<p>局部变量可以具有不同的存储类型  </p>\n<ul>\n<li><p>自动存储类型：当程序执行超出当前作用域，变量自动销毁  </p>\n</li>\n<li><p>寄存器存储类型：将变量存储在寄存器中进行存取，可以提高函数的执行程度，但是编译器有可能会选择其他方式处理  </p>\n</li>\n<li><p>静态存储类型：超出局部作用域，静态局部变量不会被销毁  </p>\n</li>\n</ul>\n<h2 id=\"名字空间域\"><a href=\"#名字空间域\" class=\"headerlink\" title=\"名字空间域\"></a>名字空间域</h2><ol>\n<li><p>由名字空间所指定的作用域  </p>\n</li>\n<li><p>外部存储类型：extern，可以在a源文件声明b源文件的对象  </p>\n</li>\n<li><p>最外成的空间即全局域  </p>\n</li>\n</ol>\n<h2 id=\"类域\"><a href=\"#类域\" class=\"headerlink\" title=\"类域\"></a>类域</h2><p>类域包括定义体和所有的成员函数体  </p>\n<p>类可以具有static数据成员  </p>\n<p>作用域、语句块、名字空间、类都可以嵌套  </p>\n<p>语句块中定义的类为内部类  </p>\n<h2 id=\"对象的生命周期\"><a href=\"#对象的生命周期\" class=\"headerlink\" title=\"对象的生命周期\"></a>对象的生命周期</h2><p>生命周期与作用域有某种关系，如：一段语句块中定义的自动对象在离开当前局部作用域的时候，总会被销毁。  </p>\n<h1 id=\"C-标准库\"><a href=\"#C-标准库\" class=\"headerlink\" title=\"C++标准库\"></a>C++标准库</h1><h2 id=\"字符串库\"><a href=\"#字符串库\" class=\"headerlink\" title=\"字符串库\"></a>字符串库<string></string></h2><ol>\n<li>字符串的构造和赋值  </li>\n</ol>\n<p>由多个重复的字符构成的string：string s(8,’f’)  </p>\n<ol start=\"2\">\n<li>字符串连接  </li>\n</ol>\n<p>可以使用+号将两个字符串连接起来  </p>\n<ol start=\"3\">\n<li><p>字符串可以用运算符直接比较  </p>\n</li>\n<li><p>字符串的下标  </p>\n</li>\n</ol>\n<p>可以通过字符串的下标来访问字符串中的某个字符  </p>\n<p>通过length()获取字符串的长度  </p>\n<ol start=\"5\">\n<li><p>子串：字符串中的一部分  </p>\n</li>\n<li><p>字符串的查找  </p>\n</li>\n</ol>\n<p>可以从字符串中查找某个字串，并返回字串所在的位置，使用是string类的find()方法，查找失败返回-1  </p>\n<ol start=\"7\">\n<li><p>string与C-style字符串：可以通过c_str()函数获取string的字符数组，c_str返回的是一个const的字符指针，指向string内部的实际存储地址，值会随着string的改变。  </p>\n</li>\n<li><p>空字符串：不包含任何内容，使用clear()清空字符串，empty()判断字符串是否为空  </p>\n</li>\n</ol>\n<h2 id=\"复数类\"><a href=\"#复数类\" class=\"headerlink\" title=\"复数类\"></a>复数类<complex></complex></h2><ol>\n<li>复数的构造  </li>\n</ol>\n<p>complex是一个类模板，它可以采用float、double、long double 3种类型进行定制，如：complex<double> c(1,2)  </double></p>\n<ol start=\"2\">\n<li><p>复数可以进行四则运算  </p>\n</li>\n<li><p>复数的操作函数  </p>\n</li>\n</ol>\n<p>real()返回复数的实部  </p>\n<p>imag()返回复数的虚部  </p>\n<p>abs(x)返回复数x的模  </p>\n<p>arg(x)返回复数x的相角  </p>\n<p>conj(x)返回复数x的共軛复数  </p>\n<p>narm(x)返回复数x的模的平方  </p>\n<h2 id=\"异常类\"><a href=\"#异常类\" class=\"headerlink\" title=\"异常类\"></a>异常类<stdexcept></stdexcept></h2><p>包含了C++中各种各样的异常  </p>\n<h1 id=\"C标准库\"><a href=\"#C标准库\" class=\"headerlink\" title=\"C标准库\"></a>C标准库</h1><h2 id=\"assert宏\"><a href=\"#assert宏\" class=\"headerlink\" title=\"assert宏\"></a>assert宏</h2><p>在<cassert>中定义一个很有用的宏：assert()用以调试代码  </cassert></p>\n<p>如果想取消掉assert()的功能，可以在包含<cassert>头文件之前定义NDEBUG宏：  </cassert></p>\n<h2 id=\"类型函数\"><a href=\"#类型函数\" class=\"headerlink\" title=\"类型函数\"></a>类型函数</h2><p><cctype>定义了一堆字符处理函数和宏</cctype></p>\n<ul>\n<li><p>isdigit(c):判断c是否为数字</p>\n</li>\n<li><p>isupper(c):判断c是否为大写字母</p>\n</li>\n<li><p>islower(c):判断c是否为小写字母  </p>\n</li>\n<li><p>isalpha(c):判断c是否为字母</p>\n</li>\n<li><p>isalnum(c):判断c是否为字母或者数字  </p>\n</li>\n<li><p>isprint(c):判断c是否是可显示的ASCII字符  </p>\n</li>\n<li><p>isspace(c):判断c是否为空字符</p>\n</li>\n<li><p>touper(c):将c转换成大写字符 </p>\n</li>\n<li><p>tolower(c):将c转换成小写字符 </p>\n</li>\n</ul>\n<h2 id=\"类型转换函数\"><a href=\"#类型转换函数\" class=\"headerlink\" title=\"类型转换函数\"></a>类型转换函数</h2><ul>\n<li><p>double atof(char*a):将字符串a转换成浮点数并返回  </p>\n</li>\n<li><p>int atoi(char*a):将字符串a转换成整数并返回  </p>\n</li>\n<li><p>long atol(char*a):将字符串a转换成长整型并返回  </p>\n</li>\n<li><p>char <em>itoa(int value,char </em>string,int radix):将整数value转换成字符串存入string  </p>\n</li>\n</ul>\n<h2 id=\"随机数函数\"><a href=\"#随机数函数\" class=\"headerlink\" title=\"随机数函数\"></a>随机数函数</h2><p>随机数函数定义在<stdlib>  </stdlib></p>\n<p>rang()返回0～RAND_MAX中随机的一个整数  </p>\n<p>rang()的产生依赖于一个发生器序列，一般需要调用srand()函数初始化，初始值一般被称作随机种子  </p>\n<h2 id=\"可变参数处理\"><a href=\"#可变参数处理\" class=\"headerlink\" title=\"可变参数处理\"></a>可变参数处理</h2><p><cstdarg>提供了几个宏和类型，以支持可变参数  </cstdarg></p>\n<ul>\n<li><p>va_list：记录参数类型  </p>\n</li>\n<li><p>va_start(list,p0):建议扫描参数表的起始指针，并保存参数信息至va_list的变量list  </p>\n</li>\n<li><p>va_arg(list,type):提取参数表list中的参数，并转换成type类型  </p>\n</li>\n<li><p>va_end(list):结束可变参数处理  </p>\n</li>\n</ul>\n<h2 id=\"内存操作函数\"><a href=\"#内存操作函数\" class=\"headerlink\" title=\"内存操作函数\"></a>内存操作函数</h2><p><cstring>和<cstdlib>中定义了如下内存操作函数  </cstdlib></cstring></p>\n<ul>\n<li><p>void *memchr(buffer,c,count):在内存中查找指定字符  </p>\n</li>\n<li><p>int memcmp(buf1,buf2,count):比较两块内存中的字符  </p>\n</li>\n<li><p>void *memcpy(dest,src,count):拷贝源内存块至目的的内存块  </p>\n</li>\n<li><p>void *memmove(dest,src,count):移动源内存块至目的内存块  </p>\n</li>\n<li><p>void *memset(dest,c,count):使用指定数值设置内存块的内容  </p>\n</li>\n<li><p>void *malloc(size):分配一块内存  </p>\n</li>\n<li><p>void <em>calloc(size,n):分配size\\</em>n字节的内存，并清零  </p>\n</li>\n<li><p>void *free(buffer):释放分配的内存  </p>\n</li>\n</ul>\n<h2 id=\"系统控制函数\"><a href=\"#系统控制函数\" class=\"headerlink\" title=\"系统控制函数\"></a>系统控制函数</h2><cstdlib>  \n\n<ul>\n<li><p>void abort():异常终止程序  </p>\n</li>\n<li><p>int exit(int status):终止当前程序  </p>\n</li>\n<li><p>int system(chat *command):执行Shell命令  </p>\n</li>\n</ul>\n<h1 id=\"C-流\"><a href=\"#C-流\" class=\"headerlink\" title=\"C++流\"></a>C++流</h1><h2 id=\"格式化输出流\"><a href=\"#格式化输出流\" class=\"headerlink\" title=\"格式化输出流\"></a>格式化输出流</h2><p>iostream提供了格式化输出函数，用以制定输出的格式  </p>\n<ul>\n<li><p>width(n):将输出宽度设置为n个字符，默认情况下，输出宽度等于字符串实际长度  </p>\n</li>\n<li><p>idth():获取当前的宽度设置  </p>\n</li>\n<li><p>fill(ch):设置填充字符为ch，默认情况为空格  </p>\n</li>\n<li><p>fill():获取当前的填充字符  </p>\n</li>\n<li><p>precision(p):设置浮点数精度为p</p>\n</li>\n<li><p>precision():获取浮点数精度  </p>\n</li>\n<li><p>setf(m):打开格式化标志m  </p>\n</li>\n<li><p>unsetf(m):关闭格式化标志m  </p>\n</li>\n<li><p>setf(m1,m2):打开m1,关闭m2  </p>\n</li>\n</ul>\n<p>格式化标志可以上网搜索</p>\n<h2 id=\"格式操纵符\"><a href=\"#格式操纵符\" class=\"headerlink\" title=\"格式操纵符\"></a>格式操纵符</h2><p>可以直接使用&lt;&lt;输出  </p>\n<p>格式操纵符见互联网  </p>\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><p>使用ofstream对象写入文件  </p>\n<p>open打开文件 -&gt; &lt;&lt;或者write函数写入文件 -&gt; close关闭文件  </p>\n<p>使用ifstream对象读取文件  </p>\n<p>open打开文件 -&gt; &gt;&gt;或者read函数读取文件 -&gt; close关闭文件  </p>\n<p>打开文件的模式包括  </p>\n<p>ios::app:追加模式  </p>\n<p>ios::ate:打开文件定位到文件尾  </p>\n<p>ios::binary:二进制方式打开  </p>\n<p>ios::in:输入方式打开  </p>\n<p>ios::out:输出方式打开  </p>\n<p>可以配合|使用  </p>\n<ul>\n<li>文件的定位  </li>\n</ul>\n<p>ifstream&amp; seekg(streampos pos);</p>\n</cstdlib>"},{"title":"C++ note2","date":"2019-06-04T08:46:54.000Z","_content":"C++的一些知识补充   1\n<!--more-->  \n# C++笔记 \n\n# **学习方法**  \n\n- 学习C\\++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C\\++源程序。一旦发现\n了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、\n高效的C++程序。\n\n\n# **条件操作符**  \n\n-  用法 :: <表达式1#?<表达式2#:<表达式3#  \n 如果表达式为true，返回表达式2的值；否则返回表达式3的值         \n\n\n# **typeid操作符**  \n\n-  用法 :: typeid(类型 || 变量).name()  \n 通过name()函数获取该类型或变量的名字。  \n    \n# **安全使用数组下标**  \n\n- 当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋\n值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。  \n\n# **安全使用字符串**  \n\n- 字符数组不是C\\++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:\n\n```\nchar str1[] = \"hello\";\ncout << str1 << endl;\nstr1[5] = '!';\ncout << str1 << endl;\n改代码输出了str1的末字符，输出如下:\nhello \nhello!烫烫烫？\n很显然，这不是我们想要的结果。使用'\\0'作为字符串时C\n++的非强制性约定，编译器不负责字符串的安全。另一方\n面，由于字符串本身就是字符数组，也会带来越界访问的\n隐患。\n```\n\n# **void\\*指针**\n\n- 一种特殊的指针类型，可以存放任意对象的地址   \n- 注意:  \n void\\*指针地址存放一个内存地址，地址指向内容不确定  \n void\\*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void\\*指针  \n   \n# **引用**\n\n```\nint i;\nint & ri = i;   //类型 & 变量 = 引用对象\n```\n\n# **结构常见错误**  \n\n- 使用了未初始化的结构成员  \n- 指定了太多的初始值 \n\n  \n   \n\n# **枚举**  \n\n- 枚举采用关键字enum，用来定义一组常量\n\n~~~\nenum Arrow{\n    UP,DOWN,LEFT,RIGHT\n};\nArrow a1 = UP;  //ok\nArrow a2 = 100; //error\ncout << a1 << endl;\n输出结果为:\n0\n~~~\n\n\n- 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个\n枚举值。  \n\n# **typedef**  \n\n- typedef提供了为某种既有类型取别名的功能。 \n\n```\ntypedef int zhengxing;\nint t1;\nzhengxing t2;   //int == zhengxing\n常见用法\n· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。\n· 另外一种就是函数的指针的类型定义，如：在Windows线\n程编程中，就有类似的线程函数接口定义：\ntypedef void * LPVOID;\ntypedef DWORD WINARI ThreadProc(LPVOID 1pParamter);\n```\n# **定义带参数的main()函数**  \n\n- main()函数支持另外一种原型  \n\n```\nint main(int argc,char * argv[]) {\n\tcout << \"参数数目:\\t\" << argc << endl;\n\tfor (int i = 0; i < argc; i++) {\n\t\tcout << \"参数\" << i << \":\\t\\t\" << argv[i] << endl;\n\t}\n\treturn 0;\n}\n输出结果为exe文件所在目录\n可以打开命令窗口进入到程序所在目录输入命令\n程序名+空格+bluejoe+vcer.net\n会输出程序的参数列表\n```\n# **预处理指令**\n\n```\n预处理器一般完成如下操作：\n· 格式化代码，去多余的空格和注释；\n· 进行一些宏替换\n· 包含另外一段代码\n· 通过一些条件的判断，动态决定是否编译某段代码\n预处理指令\n#define     //定义宏\n#undef      //取消宏的定义\n#if         //判断\n#else       \n#elif\n#endif\n#error      //输出错误信息\n#include    //包含文件\n```\n\n# **宏指令**     \n\n```\n· 一般的，定义宏的时候可以为其指定替换的文本\n· 也可以把宏定义成某个表达式\n· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R\nAND_MAX是由标准库函数定义的宏。如果需要取指定范围的\n随机数可以用到RAND_MAX,如\nint i = rand * 10 / RAND_MAX;   //0~10之间的数\n· 宏可以包含参数，这样的宏也可以叫做宏函数，如：\n#define S(x) x * x\nint main(){\n    cout << \"9的平方是:\"     << S(9) << endl;\n}\n· 宏函数具有一个很明显的优点，那就是避免了C++的强类\n型检测，如\n#define S(a,b) a+b\nint main() {\n\tstring s1 = \"Hello\";\n\tstring s2 = \"World\";\n\tcout << S(s1, s2) << endl;\n}\n· 宏与常量很相似，所以不能引用和指向宏定义的常量\n· 宏函数也是会有副作用的，如\n#define S(x) ((x) * (x))\nint i = 100;\ncout << \"S(101);\" << S(i++) << endl;\n输出如下: \nS(101): 10000\n结果并不是我们期待的101*101，避免副作用的方法，那就\n是正确运用宏，把宏看成一种预编译时期的文本替换，而\n这，也正是宏原本的含义。\n\n· #操作符\n如果宏定义中出现了‘#’，预处理器会将#后面的参数括成\n一个字符串进行替换，如\n#define S(i) cout << \"S(\"#i\")\" << ((i) * (i)) << endl;\nS(90);//等同于cout << \"S(\"90\")\" << ((90) * (90)) << endl;\n· #操作符\n“#”用于将两侧的参数合并成一个。如\n#define RGB(rr,gg,bb) 0x#rr#gg#bb\nint red = RGB(FF,00,00);\n//会被替换成\nint red = 0xFF0000;\n· 取消宏\n“#undef”用于取消指定名字的宏，然后修改宏的值\n吐槽一下：个人不知道为什么不能直接删除然后修改\n· C++预定义宏\n_LINE_      //整数，代表代号所在行号  \n_FILE_      //字符串，代表当前代码所在的文件路径\n_DATe_      //字符串代表当前文件的编译日期\n_TIME_      //字符串代表当前文件的编译时间\n_STDC_      //代表是否为标准C\n_cplusplus_ //当前当前的C++版本\n· 可以使用这些宏实现特定的功能\nbool ok = false;\nif(!ok){\n    cout << \"发生错误:\" << _FILE_ << \"(\" << _LINK_ << \")\" << endl;\n    cout << \"该软件最后发布时间：\" << _DATE_ << \" \" << _TIME_ << endl;\n}\n```\n# **条件编译指令**  \n\n- 预处理通过某些条件的判断有选择的进行处理  \n\n```\n· #if···#endif(条件编译的结尾) \n· #else 和 #elif  \n与if语句相似\n分别与if语句中的else和else if相似\n#define IS 9\nint main(){\n#if IS < 10\n    cout << \"TEST\" << endl;\n#elif Is < 5\n    cout << \"TEST2\" << endl;\n#else \n    cout << \"error\" << endl;\n#endif\n    return 0;\n}\n· #if define 和 #if !define\n前者用于检测指定的宏是否定义\n#if define IS\n    cout << \"已定义\" << endl;\n#else \n    cout << \"未定义\" << endl;\n#endif\n这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）\n还可以使用\"!\"操作符，指定某个宏没有被定义的情形，\n也就是#if !define.(个人感觉等同于#undef)\n#if !define IS\n    cout << \"未定义\" << endl;\n#endif\n· #ifdef 和 #ifndef\n前者等价于#if define,后者等价于#if !define：相当于缩写\n```\n# **文件包含指令**  \n\n```\n· #include\n用于包含一个源文件\n文件名用<#时，它指示预处理器从预设的标准路径中搜索\n指定的头文件。预设路径一般是编译器自带的include目\n录，当前也可以自己添加其他的目录\n文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。\n在一些编译器中，还可以使用相对路径查找头文件\n· C标准库头文件\n<cassert#   //assert宏的定义   \n<cctype#    //字符操作函数的操作\n<cerrno#    //错误码的定义\n<cmath#     //数学函数库\n<setjmp#    //错误处理库\n<cstdarg#   //可变参数处理宏的定义\n<stdio#     //标准输入输出的声明\n<stdlib#    //数字函数、内存管理函数、系统函数、随\n              机函数等的声明\n<cstring#   //C类型的字符串的操作函数的声明\n<ctime#     //日期、时间操作函数的声明\n· C++标准库的头文件\n<string#        //字符串\n<iostream#      //流操作\n<fstream#       //文件流\n<complex#       //复数\n<stdexcept#     //标准异常\nSTL             //标准模板库\n· 合理的使用头文件\n考虑如下情况：\na.h 包含 point.h    b.h 包含 point.h\nc.h 包含 a.h 和 b.h\n这种情况下，当编译器处理c.h时，重复定义就出现了\n解决办法是，类似如下的办法，重新设计point.h的内容\n#ifndef _HEADER_POINt_H_\n#define _HEADER_POINt_H_\n头文件内容\n#endif\n以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通\n过它来 判断当前文件是否已经被包含。这样一来，即使po\nin.h被包含多次，由#ifndef...#endif定义的point.h文件\n的内容也不会被包含多次\n· #error\n当编译器遇到#error指令时，会停止下来，并在编译窗口\n输出#error后面的信息\n· #line\n用于改变当前行的行号和文件名\n· #pragma\n属于自定义指令，每个编译器可以自己定义自己的功能\n```\n\n# **位域**    \n\n- 定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省\n内存。\n\n```\nstruct Time{\n  unsigned hour : 5;    //5 bits,0~31\n  unsigned minute : 6;    //6 bits,0~63\n  unsigned second : 6;    //6 bits,0~63\n};\ncout << sizeof(Time) <<endl;\n输出结果：\n4\n```\n\n# **数据类型修饰符**  \n\n- const  \n    中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，\n    它具有自己的内存地址，不过它不可以被修改。\n\n\n```\nint i = 100;\nint m = 200;\nint* ip0 = &i;  //非const\nint* const ip1 = &i;    //const 修饰int*\nint const * ip2 = &i;   //const 修饰int\nconst int* ip3 = &i;    //const 修饰int\nconst int* const ip4 = &i;  //const 同时修饰ip4和*ip4\n\nip0 = &m;\n*ip0 = 101;\n\n//ip1 = &m;\n*ip1 = 101;\n\nip2 = &m;\n//*ip2 = 101;\n\nip3 = &m;\n//*ip3 = 101;\n\n//ip4 = &m;\n//*ip4 = 101;\n\n注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2\n和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip\n3恰恰相反。它们本身可以被指来指去，但是它们指向的内\n容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。\n\n·常见用法\n取代宏，定义一些不可更改的值\n```  \n\n- volatile  \n 不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  \n\n---\n\n\n\n\n\n\n\n","source":"_posts/C++ note2.md","raw":"---\ntitle: C++ note2\ndate: 2019-06-04 16:46:54\ntags: note\ncategories: C++ \n---\nC++的一些知识补充   1\n<!--more-->  \n# C++笔记 \n\n# **学习方法**  \n\n- 学习C\\++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C\\++源程序。一旦发现\n了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、\n高效的C++程序。\n\n\n# **条件操作符**  \n\n-  用法 :: <表达式1#?<表达式2#:<表达式3#  \n 如果表达式为true，返回表达式2的值；否则返回表达式3的值         \n\n\n# **typeid操作符**  \n\n-  用法 :: typeid(类型 || 变量).name()  \n 通过name()函数获取该类型或变量的名字。  \n    \n# **安全使用数组下标**  \n\n- 当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋\n值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。  \n\n# **安全使用字符串**  \n\n- 字符数组不是C\\++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:\n\n```\nchar str1[] = \"hello\";\ncout << str1 << endl;\nstr1[5] = '!';\ncout << str1 << endl;\n改代码输出了str1的末字符，输出如下:\nhello \nhello!烫烫烫？\n很显然，这不是我们想要的结果。使用'\\0'作为字符串时C\n++的非强制性约定，编译器不负责字符串的安全。另一方\n面，由于字符串本身就是字符数组，也会带来越界访问的\n隐患。\n```\n\n# **void\\*指针**\n\n- 一种特殊的指针类型，可以存放任意对象的地址   \n- 注意:  \n void\\*指针地址存放一个内存地址，地址指向内容不确定  \n void\\*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void\\*指针  \n   \n# **引用**\n\n```\nint i;\nint & ri = i;   //类型 & 变量 = 引用对象\n```\n\n# **结构常见错误**  \n\n- 使用了未初始化的结构成员  \n- 指定了太多的初始值 \n\n  \n   \n\n# **枚举**  \n\n- 枚举采用关键字enum，用来定义一组常量\n\n~~~\nenum Arrow{\n    UP,DOWN,LEFT,RIGHT\n};\nArrow a1 = UP;  //ok\nArrow a2 = 100; //error\ncout << a1 << endl;\n输出结果为:\n0\n~~~\n\n\n- 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个\n枚举值。  \n\n# **typedef**  \n\n- typedef提供了为某种既有类型取别名的功能。 \n\n```\ntypedef int zhengxing;\nint t1;\nzhengxing t2;   //int == zhengxing\n常见用法\n· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。\n· 另外一种就是函数的指针的类型定义，如：在Windows线\n程编程中，就有类似的线程函数接口定义：\ntypedef void * LPVOID;\ntypedef DWORD WINARI ThreadProc(LPVOID 1pParamter);\n```\n# **定义带参数的main()函数**  \n\n- main()函数支持另外一种原型  \n\n```\nint main(int argc,char * argv[]) {\n\tcout << \"参数数目:\\t\" << argc << endl;\n\tfor (int i = 0; i < argc; i++) {\n\t\tcout << \"参数\" << i << \":\\t\\t\" << argv[i] << endl;\n\t}\n\treturn 0;\n}\n输出结果为exe文件所在目录\n可以打开命令窗口进入到程序所在目录输入命令\n程序名+空格+bluejoe+vcer.net\n会输出程序的参数列表\n```\n# **预处理指令**\n\n```\n预处理器一般完成如下操作：\n· 格式化代码，去多余的空格和注释；\n· 进行一些宏替换\n· 包含另外一段代码\n· 通过一些条件的判断，动态决定是否编译某段代码\n预处理指令\n#define     //定义宏\n#undef      //取消宏的定义\n#if         //判断\n#else       \n#elif\n#endif\n#error      //输出错误信息\n#include    //包含文件\n```\n\n# **宏指令**     \n\n```\n· 一般的，定义宏的时候可以为其指定替换的文本\n· 也可以把宏定义成某个表达式\n· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R\nAND_MAX是由标准库函数定义的宏。如果需要取指定范围的\n随机数可以用到RAND_MAX,如\nint i = rand * 10 / RAND_MAX;   //0~10之间的数\n· 宏可以包含参数，这样的宏也可以叫做宏函数，如：\n#define S(x) x * x\nint main(){\n    cout << \"9的平方是:\"     << S(9) << endl;\n}\n· 宏函数具有一个很明显的优点，那就是避免了C++的强类\n型检测，如\n#define S(a,b) a+b\nint main() {\n\tstring s1 = \"Hello\";\n\tstring s2 = \"World\";\n\tcout << S(s1, s2) << endl;\n}\n· 宏与常量很相似，所以不能引用和指向宏定义的常量\n· 宏函数也是会有副作用的，如\n#define S(x) ((x) * (x))\nint i = 100;\ncout << \"S(101);\" << S(i++) << endl;\n输出如下: \nS(101): 10000\n结果并不是我们期待的101*101，避免副作用的方法，那就\n是正确运用宏，把宏看成一种预编译时期的文本替换，而\n这，也正是宏原本的含义。\n\n· #操作符\n如果宏定义中出现了‘#’，预处理器会将#后面的参数括成\n一个字符串进行替换，如\n#define S(i) cout << \"S(\"#i\")\" << ((i) * (i)) << endl;\nS(90);//等同于cout << \"S(\"90\")\" << ((90) * (90)) << endl;\n· #操作符\n“#”用于将两侧的参数合并成一个。如\n#define RGB(rr,gg,bb) 0x#rr#gg#bb\nint red = RGB(FF,00,00);\n//会被替换成\nint red = 0xFF0000;\n· 取消宏\n“#undef”用于取消指定名字的宏，然后修改宏的值\n吐槽一下：个人不知道为什么不能直接删除然后修改\n· C++预定义宏\n_LINE_      //整数，代表代号所在行号  \n_FILE_      //字符串，代表当前代码所在的文件路径\n_DATe_      //字符串代表当前文件的编译日期\n_TIME_      //字符串代表当前文件的编译时间\n_STDC_      //代表是否为标准C\n_cplusplus_ //当前当前的C++版本\n· 可以使用这些宏实现特定的功能\nbool ok = false;\nif(!ok){\n    cout << \"发生错误:\" << _FILE_ << \"(\" << _LINK_ << \")\" << endl;\n    cout << \"该软件最后发布时间：\" << _DATE_ << \" \" << _TIME_ << endl;\n}\n```\n# **条件编译指令**  \n\n- 预处理通过某些条件的判断有选择的进行处理  \n\n```\n· #if···#endif(条件编译的结尾) \n· #else 和 #elif  \n与if语句相似\n分别与if语句中的else和else if相似\n#define IS 9\nint main(){\n#if IS < 10\n    cout << \"TEST\" << endl;\n#elif Is < 5\n    cout << \"TEST2\" << endl;\n#else \n    cout << \"error\" << endl;\n#endif\n    return 0;\n}\n· #if define 和 #if !define\n前者用于检测指定的宏是否定义\n#if define IS\n    cout << \"已定义\" << endl;\n#else \n    cout << \"未定义\" << endl;\n#endif\n这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）\n还可以使用\"!\"操作符，指定某个宏没有被定义的情形，\n也就是#if !define.(个人感觉等同于#undef)\n#if !define IS\n    cout << \"未定义\" << endl;\n#endif\n· #ifdef 和 #ifndef\n前者等价于#if define,后者等价于#if !define：相当于缩写\n```\n# **文件包含指令**  \n\n```\n· #include\n用于包含一个源文件\n文件名用<#时，它指示预处理器从预设的标准路径中搜索\n指定的头文件。预设路径一般是编译器自带的include目\n录，当前也可以自己添加其他的目录\n文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。\n在一些编译器中，还可以使用相对路径查找头文件\n· C标准库头文件\n<cassert#   //assert宏的定义   \n<cctype#    //字符操作函数的操作\n<cerrno#    //错误码的定义\n<cmath#     //数学函数库\n<setjmp#    //错误处理库\n<cstdarg#   //可变参数处理宏的定义\n<stdio#     //标准输入输出的声明\n<stdlib#    //数字函数、内存管理函数、系统函数、随\n              机函数等的声明\n<cstring#   //C类型的字符串的操作函数的声明\n<ctime#     //日期、时间操作函数的声明\n· C++标准库的头文件\n<string#        //字符串\n<iostream#      //流操作\n<fstream#       //文件流\n<complex#       //复数\n<stdexcept#     //标准异常\nSTL             //标准模板库\n· 合理的使用头文件\n考虑如下情况：\na.h 包含 point.h    b.h 包含 point.h\nc.h 包含 a.h 和 b.h\n这种情况下，当编译器处理c.h时，重复定义就出现了\n解决办法是，类似如下的办法，重新设计point.h的内容\n#ifndef _HEADER_POINt_H_\n#define _HEADER_POINt_H_\n头文件内容\n#endif\n以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通\n过它来 判断当前文件是否已经被包含。这样一来，即使po\nin.h被包含多次，由#ifndef...#endif定义的point.h文件\n的内容也不会被包含多次\n· #error\n当编译器遇到#error指令时，会停止下来，并在编译窗口\n输出#error后面的信息\n· #line\n用于改变当前行的行号和文件名\n· #pragma\n属于自定义指令，每个编译器可以自己定义自己的功能\n```\n\n# **位域**    \n\n- 定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省\n内存。\n\n```\nstruct Time{\n  unsigned hour : 5;    //5 bits,0~31\n  unsigned minute : 6;    //6 bits,0~63\n  unsigned second : 6;    //6 bits,0~63\n};\ncout << sizeof(Time) <<endl;\n输出结果：\n4\n```\n\n# **数据类型修饰符**  \n\n- const  \n    中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，\n    它具有自己的内存地址，不过它不可以被修改。\n\n\n```\nint i = 100;\nint m = 200;\nint* ip0 = &i;  //非const\nint* const ip1 = &i;    //const 修饰int*\nint const * ip2 = &i;   //const 修饰int\nconst int* ip3 = &i;    //const 修饰int\nconst int* const ip4 = &i;  //const 同时修饰ip4和*ip4\n\nip0 = &m;\n*ip0 = 101;\n\n//ip1 = &m;\n*ip1 = 101;\n\nip2 = &m;\n//*ip2 = 101;\n\nip3 = &m;\n//*ip3 = 101;\n\n//ip4 = &m;\n//*ip4 = 101;\n\n注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2\n和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip\n3恰恰相反。它们本身可以被指来指去，但是它们指向的内\n容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。\n\n·常见用法\n取代宏，定义一些不可更改的值\n```  \n\n- volatile  \n 不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  \n\n---\n\n\n\n\n\n\n\n","slug":"C++ note2","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akptn00097qsgzph2wboi","content":"<p>C++的一些知识补充   1<br><a id=\"more\"></a>  </p>\n<h1 id=\"C-笔记\"><a href=\"#C-笔记\" class=\"headerlink\" title=\"C++笔记\"></a>C++笔记</h1><h1 id=\"学习方法\"><a href=\"#学习方法\" class=\"headerlink\" title=\"学习方法\"></a><strong>学习方法</strong></h1><ul>\n<li>学习C++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C++源程序。一旦发现<br>了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、<br>高效的C++程序。</li>\n</ul>\n<h1 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a><strong>条件操作符</strong></h1><ul>\n<li>用法 :: &lt;表达式1#?&lt;表达式2#:&lt;表达式3#<br>如果表达式为true，返回表达式2的值；否则返回表达式3的值         </li>\n</ul>\n<h1 id=\"typeid操作符\"><a href=\"#typeid操作符\" class=\"headerlink\" title=\"typeid操作符\"></a><strong>typeid操作符</strong></h1><ul>\n<li>用法 :: typeid(类型 || 变量).name()<br>通过name()函数获取该类型或变量的名字。  </li>\n</ul>\n<h1 id=\"安全使用数组下标\"><a href=\"#安全使用数组下标\" class=\"headerlink\" title=\"安全使用数组下标\"></a><strong>安全使用数组下标</strong></h1><ul>\n<li>当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋<br>值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。  </li>\n</ul>\n<h1 id=\"安全使用字符串\"><a href=\"#安全使用字符串\" class=\"headerlink\" title=\"安全使用字符串\"></a><strong>安全使用字符串</strong></h1><ul>\n<li>字符数组不是C++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str1[] = &quot;hello&quot;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">str1[5] = &apos;!&apos;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">改代码输出了str1的末字符，输出如下:</span><br><span class=\"line\">hello </span><br><span class=\"line\">hello!烫烫烫？</span><br><span class=\"line\">很显然，这不是我们想要的结果。使用&apos;\\0&apos;作为字符串时C</span><br><span class=\"line\">++的非强制性约定，编译器不负责字符串的安全。另一方</span><br><span class=\"line\">面，由于字符串本身就是字符数组，也会带来越界访问的</span><br><span class=\"line\">隐患。</span><br></pre></td></tr></table></figure>\n<h1 id=\"void-指针\"><a href=\"#void-指针\" class=\"headerlink\" title=\"void*指针\"></a><strong>void*指针</strong></h1><ul>\n<li>一种特殊的指针类型，可以存放任意对象的地址   </li>\n<li>注意:<br>void*指针地址存放一个内存地址，地址指向内容不确定<br>void*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void*指针  </li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a><strong>引用</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i;</span><br><span class=\"line\">int &amp; ri = i;   //类型 &amp; 变量 = 引用对象</span><br></pre></td></tr></table></figure>\n<h1 id=\"结构常见错误\"><a href=\"#结构常见错误\" class=\"headerlink\" title=\"结构常见错误\"></a><strong>结构常见错误</strong></h1><ul>\n<li>使用了未初始化的结构成员  </li>\n<li>指定了太多的初始值 </li>\n</ul>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a><strong>枚举</strong></h1><ul>\n<li>枚举采用关键字enum，用来定义一组常量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Arrow&#123;</span><br><span class=\"line\">    UP,DOWN,LEFT,RIGHT</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrow a1 = UP;  //ok</span><br><span class=\"line\">Arrow a2 = 100; //error</span><br><span class=\"line\">cout &lt;&lt; a1 &lt;&lt; endl;</span><br><span class=\"line\">输出结果为:</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个<br>枚举值。  </li>\n</ul>\n<h1 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a><strong>typedef</strong></h1><ul>\n<li>typedef提供了为某种既有类型取别名的功能。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int zhengxing;</span><br><span class=\"line\">int t1;</span><br><span class=\"line\">zhengxing t2;   //int == zhengxing</span><br><span class=\"line\">常见用法</span><br><span class=\"line\">· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。</span><br><span class=\"line\">· 另外一种就是函数的指针的类型定义，如：在Windows线</span><br><span class=\"line\">程编程中，就有类似的线程函数接口定义：</span><br><span class=\"line\">typedef void * LPVOID;</span><br><span class=\"line\">typedef DWORD WINARI ThreadProc(LPVOID 1pParamter);</span><br></pre></td></tr></table></figure>\n<h1 id=\"定义带参数的main-函数\"><a href=\"#定义带参数的main-函数\" class=\"headerlink\" title=\"定义带参数的main()函数\"></a><strong>定义带参数的main()函数</strong></h1><ul>\n<li>main()函数支持另外一种原型  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc,char * argv[]) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;参数数目:\\t&quot; &lt;&lt; argc &lt;&lt; endl;</span><br><span class=\"line\">\tfor (int i = 0; i &lt; argc; i++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;参数&quot; &lt;&lt; i &lt;&lt; &quot;:\\t\\t&quot; &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果为exe文件所在目录</span><br><span class=\"line\">可以打开命令窗口进入到程序所在目录输入命令</span><br><span class=\"line\">程序名+空格+bluejoe+vcer.net</span><br><span class=\"line\">会输出程序的参数列表</span><br></pre></td></tr></table></figure>\n<h1 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a><strong>预处理指令</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">预处理器一般完成如下操作：</span><br><span class=\"line\">· 格式化代码，去多余的空格和注释；</span><br><span class=\"line\">· 进行一些宏替换</span><br><span class=\"line\">· 包含另外一段代码</span><br><span class=\"line\">· 通过一些条件的判断，动态决定是否编译某段代码</span><br><span class=\"line\">预处理指令</span><br><span class=\"line\">#define     //定义宏</span><br><span class=\"line\">#undef      //取消宏的定义</span><br><span class=\"line\">#if         //判断</span><br><span class=\"line\">#else       </span><br><span class=\"line\">#elif</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#error      //输出错误信息</span><br><span class=\"line\">#include    //包含文件</span><br></pre></td></tr></table></figure>\n<h1 id=\"宏指令\"><a href=\"#宏指令\" class=\"headerlink\" title=\"宏指令\"></a><strong>宏指令</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 一般的，定义宏的时候可以为其指定替换的文本</span><br><span class=\"line\">· 也可以把宏定义成某个表达式</span><br><span class=\"line\">· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R</span><br><span class=\"line\">AND_MAX是由标准库函数定义的宏。如果需要取指定范围的</span><br><span class=\"line\">随机数可以用到RAND_MAX,如</span><br><span class=\"line\">int i = rand * 10 / RAND_MAX;   //0~10之间的数</span><br><span class=\"line\">· 宏可以包含参数，这样的宏也可以叫做宏函数，如：</span><br><span class=\"line\">#define S(x) x * x</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;9的平方是:&quot;     &lt;&lt; S(9) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 宏函数具有一个很明显的优点，那就是避免了C++的强类</span><br><span class=\"line\">型检测，如</span><br><span class=\"line\">#define S(a,b) a+b</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tstring s1 = &quot;Hello&quot;;</span><br><span class=\"line\">\tstring s2 = &quot;World&quot;;</span><br><span class=\"line\">\tcout &lt;&lt; S(s1, s2) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 宏与常量很相似，所以不能引用和指向宏定义的常量</span><br><span class=\"line\">· 宏函数也是会有副作用的，如</span><br><span class=\"line\">#define S(x) ((x) * (x))</span><br><span class=\"line\">int i = 100;</span><br><span class=\"line\">cout &lt;&lt; &quot;S(101);&quot; &lt;&lt; S(i++) &lt;&lt; endl;</span><br><span class=\"line\">输出如下: </span><br><span class=\"line\">S(101): 10000</span><br><span class=\"line\">结果并不是我们期待的101*101，避免副作用的方法，那就</span><br><span class=\"line\">是正确运用宏，把宏看成一种预编译时期的文本替换，而</span><br><span class=\"line\">这，也正是宏原本的含义。</span><br><span class=\"line\"></span><br><span class=\"line\">· #操作符</span><br><span class=\"line\">如果宏定义中出现了‘#’，预处理器会将#后面的参数括成</span><br><span class=\"line\">一个字符串进行替换，如</span><br><span class=\"line\">#define S(i) cout &lt;&lt; &quot;S(&quot;#i&quot;)&quot; &lt;&lt; ((i) * (i)) &lt;&lt; endl;</span><br><span class=\"line\">S(90);//等同于cout &lt;&lt; &quot;S(&quot;90&quot;)&quot; &lt;&lt; ((90) * (90)) &lt;&lt; endl;</span><br><span class=\"line\">· #操作符</span><br><span class=\"line\">“#”用于将两侧的参数合并成一个。如</span><br><span class=\"line\">#define RGB(rr,gg,bb) 0x#rr#gg#bb</span><br><span class=\"line\">int red = RGB(FF,00,00);</span><br><span class=\"line\">//会被替换成</span><br><span class=\"line\">int red = 0xFF0000;</span><br><span class=\"line\">· 取消宏</span><br><span class=\"line\">“#undef”用于取消指定名字的宏，然后修改宏的值</span><br><span class=\"line\">吐槽一下：个人不知道为什么不能直接删除然后修改</span><br><span class=\"line\">· C++预定义宏</span><br><span class=\"line\">_LINE_      //整数，代表代号所在行号  </span><br><span class=\"line\">_FILE_      //字符串，代表当前代码所在的文件路径</span><br><span class=\"line\">_DATe_      //字符串代表当前文件的编译日期</span><br><span class=\"line\">_TIME_      //字符串代表当前文件的编译时间</span><br><span class=\"line\">_STDC_      //代表是否为标准C</span><br><span class=\"line\">_cplusplus_ //当前当前的C++版本</span><br><span class=\"line\">· 可以使用这些宏实现特定的功能</span><br><span class=\"line\">bool ok = false;</span><br><span class=\"line\">if(!ok)&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;发生错误:&quot; &lt;&lt; _FILE_ &lt;&lt; &quot;(&quot; &lt;&lt; _LINK_ &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;该软件最后发布时间：&quot; &lt;&lt; _DATE_ &lt;&lt; &quot; &quot; &lt;&lt; _TIME_ &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"条件编译指令\"><a href=\"#条件编译指令\" class=\"headerlink\" title=\"条件编译指令\"></a><strong>条件编译指令</strong></h1><ul>\n<li>预处理通过某些条件的判断有选择的进行处理  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· #if···#endif(条件编译的结尾) </span><br><span class=\"line\">· #else 和 #elif  </span><br><span class=\"line\">与if语句相似</span><br><span class=\"line\">分别与if语句中的else和else if相似</span><br><span class=\"line\">#define IS 9</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">#if IS &lt; 10</span><br><span class=\"line\">    cout &lt;&lt; &quot;TEST&quot; &lt;&lt; endl;</span><br><span class=\"line\">#elif Is &lt; 5</span><br><span class=\"line\">    cout &lt;&lt; &quot;TEST2&quot; &lt;&lt; endl;</span><br><span class=\"line\">#else </span><br><span class=\"line\">    cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· #if define 和 #if !define</span><br><span class=\"line\">前者用于检测指定的宏是否定义</span><br><span class=\"line\">#if define IS</span><br><span class=\"line\">    cout &lt;&lt; &quot;已定义&quot; &lt;&lt; endl;</span><br><span class=\"line\">#else </span><br><span class=\"line\">    cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）</span><br><span class=\"line\">还可以使用&quot;!&quot;操作符，指定某个宏没有被定义的情形，</span><br><span class=\"line\">也就是#if !define.(个人感觉等同于#undef)</span><br><span class=\"line\">#if !define IS</span><br><span class=\"line\">    cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">· #ifdef 和 #ifndef</span><br><span class=\"line\">前者等价于#if define,后者等价于#if !define：相当于缩写</span><br></pre></td></tr></table></figure>\n<h1 id=\"文件包含指令\"><a href=\"#文件包含指令\" class=\"headerlink\" title=\"文件包含指令\"></a><strong>文件包含指令</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· #include</span><br><span class=\"line\">用于包含一个源文件</span><br><span class=\"line\">文件名用&lt;#时，它指示预处理器从预设的标准路径中搜索</span><br><span class=\"line\">指定的头文件。预设路径一般是编译器自带的include目</span><br><span class=\"line\">录，当前也可以自己添加其他的目录</span><br><span class=\"line\">文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。</span><br><span class=\"line\">在一些编译器中，还可以使用相对路径查找头文件</span><br><span class=\"line\">· C标准库头文件</span><br><span class=\"line\">&lt;cassert#   //assert宏的定义   </span><br><span class=\"line\">&lt;cctype#    //字符操作函数的操作</span><br><span class=\"line\">&lt;cerrno#    //错误码的定义</span><br><span class=\"line\">&lt;cmath#     //数学函数库</span><br><span class=\"line\">&lt;setjmp#    //错误处理库</span><br><span class=\"line\">&lt;cstdarg#   //可变参数处理宏的定义</span><br><span class=\"line\">&lt;stdio#     //标准输入输出的声明</span><br><span class=\"line\">&lt;stdlib#    //数字函数、内存管理函数、系统函数、随</span><br><span class=\"line\">              机函数等的声明</span><br><span class=\"line\">&lt;cstring#   //C类型的字符串的操作函数的声明</span><br><span class=\"line\">&lt;ctime#     //日期、时间操作函数的声明</span><br><span class=\"line\">· C++标准库的头文件</span><br><span class=\"line\">&lt;string#        //字符串</span><br><span class=\"line\">&lt;iostream#      //流操作</span><br><span class=\"line\">&lt;fstream#       //文件流</span><br><span class=\"line\">&lt;complex#       //复数</span><br><span class=\"line\">&lt;stdexcept#     //标准异常</span><br><span class=\"line\">STL             //标准模板库</span><br><span class=\"line\">· 合理的使用头文件</span><br><span class=\"line\">考虑如下情况：</span><br><span class=\"line\">a.h 包含 point.h    b.h 包含 point.h</span><br><span class=\"line\">c.h 包含 a.h 和 b.h</span><br><span class=\"line\">这种情况下，当编译器处理c.h时，重复定义就出现了</span><br><span class=\"line\">解决办法是，类似如下的办法，重新设计point.h的内容</span><br><span class=\"line\">#ifndef _HEADER_POINt_H_</span><br><span class=\"line\">#define _HEADER_POINt_H_</span><br><span class=\"line\">头文件内容</span><br><span class=\"line\">#endif</span><br><span class=\"line\">以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通</span><br><span class=\"line\">过它来 判断当前文件是否已经被包含。这样一来，即使po</span><br><span class=\"line\">in.h被包含多次，由#ifndef...#endif定义的point.h文件</span><br><span class=\"line\">的内容也不会被包含多次</span><br><span class=\"line\">· #error</span><br><span class=\"line\">当编译器遇到#error指令时，会停止下来，并在编译窗口</span><br><span class=\"line\">输出#error后面的信息</span><br><span class=\"line\">· #line</span><br><span class=\"line\">用于改变当前行的行号和文件名</span><br><span class=\"line\">· #pragma</span><br><span class=\"line\">属于自定义指令，每个编译器可以自己定义自己的功能</span><br></pre></td></tr></table></figure>\n<h1 id=\"位域\"><a href=\"#位域\" class=\"headerlink\" title=\"位域\"></a><strong>位域</strong></h1><ul>\n<li>定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省<br>内存。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Time&#123;</span><br><span class=\"line\">  unsigned hour : 5;    //5 bits,0~31</span><br><span class=\"line\">  unsigned minute : 6;    //6 bits,0~63</span><br><span class=\"line\">  unsigned second : 6;    //6 bits,0~63</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; sizeof(Time) &lt;&lt;endl;</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<h1 id=\"数据类型修饰符\"><a href=\"#数据类型修饰符\" class=\"headerlink\" title=\"数据类型修饰符\"></a><strong>数据类型修饰符</strong></h1><ul>\n<li>const<br>  中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，<br>  它具有自己的内存地址，不过它不可以被修改。</li>\n</ul>\n<pre><code>int i = 100;\nint m = 200;\nint* ip0 = &amp;i;  //非const\nint* const ip1 = &amp;i;    //const 修饰int*\nint const * ip2 = &amp;i;   //const 修饰int\nconst int* ip3 = &amp;i;    //const 修饰int\nconst int* const ip4 = &amp;i;  //const 同时修饰ip4和*ip4\n\nip0 = &amp;m;\n*ip0 = 101;\n\n//ip1 = &amp;m;\n*ip1 = 101;\n\nip2 = &amp;m;\n//*ip2 = 101;\n\nip3 = &amp;m;\n//*ip3 = 101;\n\n//ip4 = &amp;m;\n//*ip4 = 101;\n\n注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2\n和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip\n3恰恰相反。它们本身可以被指来指去，但是它们指向的内\n容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。\n\n·常见用法\n取代宏，定义一些不可更改的值\n</code></pre><ul>\n<li>volatile<br>不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  </li>\n</ul>\n<hr>\n","site":{"data":{}},"excerpt":"<p>C++的一些知识补充   1<br></p>","more":"<p></p>\n<h1 id=\"C-笔记\"><a href=\"#C-笔记\" class=\"headerlink\" title=\"C++笔记\"></a>C++笔记</h1><h1 id=\"学习方法\"><a href=\"#学习方法\" class=\"headerlink\" title=\"学习方法\"></a><strong>学习方法</strong></h1><ul>\n<li>学习C++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C++源程序。一旦发现<br>了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、<br>高效的C++程序。</li>\n</ul>\n<h1 id=\"条件操作符\"><a href=\"#条件操作符\" class=\"headerlink\" title=\"条件操作符\"></a><strong>条件操作符</strong></h1><ul>\n<li>用法 :: &lt;表达式1#?&lt;表达式2#:&lt;表达式3#<br>如果表达式为true，返回表达式2的值；否则返回表达式3的值         </li>\n</ul>\n<h1 id=\"typeid操作符\"><a href=\"#typeid操作符\" class=\"headerlink\" title=\"typeid操作符\"></a><strong>typeid操作符</strong></h1><ul>\n<li>用法 :: typeid(类型 || 变量).name()<br>通过name()函数获取该类型或变量的名字。  </li>\n</ul>\n<h1 id=\"安全使用数组下标\"><a href=\"#安全使用数组下标\" class=\"headerlink\" title=\"安全使用数组下标\"></a><strong>安全使用数组下标</strong></h1><ul>\n<li>当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋<br>值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。  </li>\n</ul>\n<h1 id=\"安全使用字符串\"><a href=\"#安全使用字符串\" class=\"headerlink\" title=\"安全使用字符串\"></a><strong>安全使用字符串</strong></h1><ul>\n<li>字符数组不是C++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char str1[] = &quot;hello&quot;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">str1[5] = &apos;!&apos;;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\">改代码输出了str1的末字符，输出如下:</span><br><span class=\"line\">hello </span><br><span class=\"line\">hello!烫烫烫？</span><br><span class=\"line\">很显然，这不是我们想要的结果。使用&apos;\\0&apos;作为字符串时C</span><br><span class=\"line\">++的非强制性约定，编译器不负责字符串的安全。另一方</span><br><span class=\"line\">面，由于字符串本身就是字符数组，也会带来越界访问的</span><br><span class=\"line\">隐患。</span><br></pre></td></tr></table></figure>\n<h1 id=\"void-指针\"><a href=\"#void-指针\" class=\"headerlink\" title=\"void*指针\"></a><strong>void*指针</strong></h1><ul>\n<li>一种特殊的指针类型，可以存放任意对象的地址   </li>\n<li>注意:<br>void*指针地址存放一个内存地址，地址指向内容不确定<br>void*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void*指针  </li>\n</ul>\n<h1 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a><strong>引用</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i;</span><br><span class=\"line\">int &amp; ri = i;   //类型 &amp; 变量 = 引用对象</span><br></pre></td></tr></table></figure>\n<h1 id=\"结构常见错误\"><a href=\"#结构常见错误\" class=\"headerlink\" title=\"结构常见错误\"></a><strong>结构常见错误</strong></h1><ul>\n<li>使用了未初始化的结构成员  </li>\n<li>指定了太多的初始值 </li>\n</ul>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a><strong>枚举</strong></h1><ul>\n<li>枚举采用关键字enum，用来定义一组常量</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enum Arrow&#123;</span><br><span class=\"line\">    UP,DOWN,LEFT,RIGHT</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Arrow a1 = UP;  //ok</span><br><span class=\"line\">Arrow a2 = 100; //error</span><br><span class=\"line\">cout &lt;&lt; a1 &lt;&lt; endl;</span><br><span class=\"line\">输出结果为:</span><br><span class=\"line\">0</span><br></pre></td></tr></table></figure>\n<ul>\n<li>默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个<br>枚举值。  </li>\n</ul>\n<h1 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a><strong>typedef</strong></h1><ul>\n<li>typedef提供了为某种既有类型取别名的功能。 </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typedef int zhengxing;</span><br><span class=\"line\">int t1;</span><br><span class=\"line\">zhengxing t2;   //int == zhengxing</span><br><span class=\"line\">常见用法</span><br><span class=\"line\">· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。</span><br><span class=\"line\">· 另外一种就是函数的指针的类型定义，如：在Windows线</span><br><span class=\"line\">程编程中，就有类似的线程函数接口定义：</span><br><span class=\"line\">typedef void * LPVOID;</span><br><span class=\"line\">typedef DWORD WINARI ThreadProc(LPVOID 1pParamter);</span><br></pre></td></tr></table></figure>\n<h1 id=\"定义带参数的main-函数\"><a href=\"#定义带参数的main-函数\" class=\"headerlink\" title=\"定义带参数的main()函数\"></a><strong>定义带参数的main()函数</strong></h1><ul>\n<li>main()函数支持另外一种原型  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main(int argc,char * argv[]) &#123;</span><br><span class=\"line\">\tcout &lt;&lt; &quot;参数数目:\\t&quot; &lt;&lt; argc &lt;&lt; endl;</span><br><span class=\"line\">\tfor (int i = 0; i &lt; argc; i++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; &quot;参数&quot; &lt;&lt; i &lt;&lt; &quot;:\\t\\t&quot; &lt;&lt; argv[i] &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">输出结果为exe文件所在目录</span><br><span class=\"line\">可以打开命令窗口进入到程序所在目录输入命令</span><br><span class=\"line\">程序名+空格+bluejoe+vcer.net</span><br><span class=\"line\">会输出程序的参数列表</span><br></pre></td></tr></table></figure>\n<h1 id=\"预处理指令\"><a href=\"#预处理指令\" class=\"headerlink\" title=\"预处理指令\"></a><strong>预处理指令</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">预处理器一般完成如下操作：</span><br><span class=\"line\">· 格式化代码，去多余的空格和注释；</span><br><span class=\"line\">· 进行一些宏替换</span><br><span class=\"line\">· 包含另外一段代码</span><br><span class=\"line\">· 通过一些条件的判断，动态决定是否编译某段代码</span><br><span class=\"line\">预处理指令</span><br><span class=\"line\">#define     //定义宏</span><br><span class=\"line\">#undef      //取消宏的定义</span><br><span class=\"line\">#if         //判断</span><br><span class=\"line\">#else       </span><br><span class=\"line\">#elif</span><br><span class=\"line\">#endif</span><br><span class=\"line\">#error      //输出错误信息</span><br><span class=\"line\">#include    //包含文件</span><br></pre></td></tr></table></figure>\n<h1 id=\"宏指令\"><a href=\"#宏指令\" class=\"headerlink\" title=\"宏指令\"></a><strong>宏指令</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· 一般的，定义宏的时候可以为其指定替换的文本</span><br><span class=\"line\">· 也可以把宏定义成某个表达式</span><br><span class=\"line\">· rand()函数可以返回一个0~RAND_MAX之间的随机整数，R</span><br><span class=\"line\">AND_MAX是由标准库函数定义的宏。如果需要取指定范围的</span><br><span class=\"line\">随机数可以用到RAND_MAX,如</span><br><span class=\"line\">int i = rand * 10 / RAND_MAX;   //0~10之间的数</span><br><span class=\"line\">· 宏可以包含参数，这样的宏也可以叫做宏函数，如：</span><br><span class=\"line\">#define S(x) x * x</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;9的平方是:&quot;     &lt;&lt; S(9) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 宏函数具有一个很明显的优点，那就是避免了C++的强类</span><br><span class=\"line\">型检测，如</span><br><span class=\"line\">#define S(a,b) a+b</span><br><span class=\"line\">int main() &#123;</span><br><span class=\"line\">\tstring s1 = &quot;Hello&quot;;</span><br><span class=\"line\">\tstring s2 = &quot;World&quot;;</span><br><span class=\"line\">\tcout &lt;&lt; S(s1, s2) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· 宏与常量很相似，所以不能引用和指向宏定义的常量</span><br><span class=\"line\">· 宏函数也是会有副作用的，如</span><br><span class=\"line\">#define S(x) ((x) * (x))</span><br><span class=\"line\">int i = 100;</span><br><span class=\"line\">cout &lt;&lt; &quot;S(101);&quot; &lt;&lt; S(i++) &lt;&lt; endl;</span><br><span class=\"line\">输出如下: </span><br><span class=\"line\">S(101): 10000</span><br><span class=\"line\">结果并不是我们期待的101*101，避免副作用的方法，那就</span><br><span class=\"line\">是正确运用宏，把宏看成一种预编译时期的文本替换，而</span><br><span class=\"line\">这，也正是宏原本的含义。</span><br><span class=\"line\"></span><br><span class=\"line\">· #操作符</span><br><span class=\"line\">如果宏定义中出现了‘#’，预处理器会将#后面的参数括成</span><br><span class=\"line\">一个字符串进行替换，如</span><br><span class=\"line\">#define S(i) cout &lt;&lt; &quot;S(&quot;#i&quot;)&quot; &lt;&lt; ((i) * (i)) &lt;&lt; endl;</span><br><span class=\"line\">S(90);//等同于cout &lt;&lt; &quot;S(&quot;90&quot;)&quot; &lt;&lt; ((90) * (90)) &lt;&lt; endl;</span><br><span class=\"line\">· #操作符</span><br><span class=\"line\">“#”用于将两侧的参数合并成一个。如</span><br><span class=\"line\">#define RGB(rr,gg,bb) 0x#rr#gg#bb</span><br><span class=\"line\">int red = RGB(FF,00,00);</span><br><span class=\"line\">//会被替换成</span><br><span class=\"line\">int red = 0xFF0000;</span><br><span class=\"line\">· 取消宏</span><br><span class=\"line\">“#undef”用于取消指定名字的宏，然后修改宏的值</span><br><span class=\"line\">吐槽一下：个人不知道为什么不能直接删除然后修改</span><br><span class=\"line\">· C++预定义宏</span><br><span class=\"line\">_LINE_      //整数，代表代号所在行号  </span><br><span class=\"line\">_FILE_      //字符串，代表当前代码所在的文件路径</span><br><span class=\"line\">_DATe_      //字符串代表当前文件的编译日期</span><br><span class=\"line\">_TIME_      //字符串代表当前文件的编译时间</span><br><span class=\"line\">_STDC_      //代表是否为标准C</span><br><span class=\"line\">_cplusplus_ //当前当前的C++版本</span><br><span class=\"line\">· 可以使用这些宏实现特定的功能</span><br><span class=\"line\">bool ok = false;</span><br><span class=\"line\">if(!ok)&#123;</span><br><span class=\"line\">    cout &lt;&lt; &quot;发生错误:&quot; &lt;&lt; _FILE_ &lt;&lt; &quot;(&quot; &lt;&lt; _LINK_ &lt;&lt; &quot;)&quot; &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; &quot;该软件最后发布时间：&quot; &lt;&lt; _DATE_ &lt;&lt; &quot; &quot; &lt;&lt; _TIME_ &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"条件编译指令\"><a href=\"#条件编译指令\" class=\"headerlink\" title=\"条件编译指令\"></a><strong>条件编译指令</strong></h1><ul>\n<li>预处理通过某些条件的判断有选择的进行处理  </li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· #if···#endif(条件编译的结尾) </span><br><span class=\"line\">· #else 和 #elif  </span><br><span class=\"line\">与if语句相似</span><br><span class=\"line\">分别与if语句中的else和else if相似</span><br><span class=\"line\">#define IS 9</span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">#if IS &lt; 10</span><br><span class=\"line\">    cout &lt;&lt; &quot;TEST&quot; &lt;&lt; endl;</span><br><span class=\"line\">#elif Is &lt; 5</span><br><span class=\"line\">    cout &lt;&lt; &quot;TEST2&quot; &lt;&lt; endl;</span><br><span class=\"line\">#else </span><br><span class=\"line\">    cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">· #if define 和 #if !define</span><br><span class=\"line\">前者用于检测指定的宏是否定义</span><br><span class=\"line\">#if define IS</span><br><span class=\"line\">    cout &lt;&lt; &quot;已定义&quot; &lt;&lt; endl;</span><br><span class=\"line\">#else </span><br><span class=\"line\">    cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）</span><br><span class=\"line\">还可以使用&quot;!&quot;操作符，指定某个宏没有被定义的情形，</span><br><span class=\"line\">也就是#if !define.(个人感觉等同于#undef)</span><br><span class=\"line\">#if !define IS</span><br><span class=\"line\">    cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">· #ifdef 和 #ifndef</span><br><span class=\"line\">前者等价于#if define,后者等价于#if !define：相当于缩写</span><br></pre></td></tr></table></figure>\n<h1 id=\"文件包含指令\"><a href=\"#文件包含指令\" class=\"headerlink\" title=\"文件包含指令\"></a><strong>文件包含指令</strong></h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">· #include</span><br><span class=\"line\">用于包含一个源文件</span><br><span class=\"line\">文件名用&lt;#时，它指示预处理器从预设的标准路径中搜索</span><br><span class=\"line\">指定的头文件。预设路径一般是编译器自带的include目</span><br><span class=\"line\">录，当前也可以自己添加其他的目录</span><br><span class=\"line\">文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。</span><br><span class=\"line\">在一些编译器中，还可以使用相对路径查找头文件</span><br><span class=\"line\">· C标准库头文件</span><br><span class=\"line\">&lt;cassert#   //assert宏的定义   </span><br><span class=\"line\">&lt;cctype#    //字符操作函数的操作</span><br><span class=\"line\">&lt;cerrno#    //错误码的定义</span><br><span class=\"line\">&lt;cmath#     //数学函数库</span><br><span class=\"line\">&lt;setjmp#    //错误处理库</span><br><span class=\"line\">&lt;cstdarg#   //可变参数处理宏的定义</span><br><span class=\"line\">&lt;stdio#     //标准输入输出的声明</span><br><span class=\"line\">&lt;stdlib#    //数字函数、内存管理函数、系统函数、随</span><br><span class=\"line\">              机函数等的声明</span><br><span class=\"line\">&lt;cstring#   //C类型的字符串的操作函数的声明</span><br><span class=\"line\">&lt;ctime#     //日期、时间操作函数的声明</span><br><span class=\"line\">· C++标准库的头文件</span><br><span class=\"line\">&lt;string#        //字符串</span><br><span class=\"line\">&lt;iostream#      //流操作</span><br><span class=\"line\">&lt;fstream#       //文件流</span><br><span class=\"line\">&lt;complex#       //复数</span><br><span class=\"line\">&lt;stdexcept#     //标准异常</span><br><span class=\"line\">STL             //标准模板库</span><br><span class=\"line\">· 合理的使用头文件</span><br><span class=\"line\">考虑如下情况：</span><br><span class=\"line\">a.h 包含 point.h    b.h 包含 point.h</span><br><span class=\"line\">c.h 包含 a.h 和 b.h</span><br><span class=\"line\">这种情况下，当编译器处理c.h时，重复定义就出现了</span><br><span class=\"line\">解决办法是，类似如下的办法，重新设计point.h的内容</span><br><span class=\"line\">#ifndef _HEADER_POINt_H_</span><br><span class=\"line\">#define _HEADER_POINt_H_</span><br><span class=\"line\">头文件内容</span><br><span class=\"line\">#endif</span><br><span class=\"line\">以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通</span><br><span class=\"line\">过它来 判断当前文件是否已经被包含。这样一来，即使po</span><br><span class=\"line\">in.h被包含多次，由#ifndef...#endif定义的point.h文件</span><br><span class=\"line\">的内容也不会被包含多次</span><br><span class=\"line\">· #error</span><br><span class=\"line\">当编译器遇到#error指令时，会停止下来，并在编译窗口</span><br><span class=\"line\">输出#error后面的信息</span><br><span class=\"line\">· #line</span><br><span class=\"line\">用于改变当前行的行号和文件名</span><br><span class=\"line\">· #pragma</span><br><span class=\"line\">属于自定义指令，每个编译器可以自己定义自己的功能</span><br></pre></td></tr></table></figure>\n<h1 id=\"位域\"><a href=\"#位域\" class=\"headerlink\" title=\"位域\"></a><strong>位域</strong></h1><ul>\n<li>定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省<br>内存。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Time&#123;</span><br><span class=\"line\">  unsigned hour : 5;    //5 bits,0~31</span><br><span class=\"line\">  unsigned minute : 6;    //6 bits,0~63</span><br><span class=\"line\">  unsigned second : 6;    //6 bits,0~63</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">cout &lt;&lt; sizeof(Time) &lt;&lt;endl;</span><br><span class=\"line\">输出结果：</span><br><span class=\"line\">4</span><br></pre></td></tr></table></figure>\n<h1 id=\"数据类型修饰符\"><a href=\"#数据类型修饰符\" class=\"headerlink\" title=\"数据类型修饰符\"></a><strong>数据类型修饰符</strong></h1><ul>\n<li>const<br>  中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量，<br>  它具有自己的内存地址，不过它不可以被修改。</li>\n</ul>\n<pre><code>int i = 100;\nint m = 200;\nint* ip0 = &amp;i;  //非const\nint* const ip1 = &amp;i;    //const 修饰int*\nint const * ip2 = &amp;i;   //const 修饰int\nconst int* ip3 = &amp;i;    //const 修饰int\nconst int* const ip4 = &amp;i;  //const 同时修饰ip4和*ip4\n\nip0 = &amp;m;\n*ip0 = 101;\n\n//ip1 = &amp;m;\n*ip1 = 101;\n\nip2 = &amp;m;\n//*ip2 = 101;\n\nip3 = &amp;m;\n//*ip3 = 101;\n\n//ip4 = &amp;m;\n//*ip4 = 101;\n\n注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2\n和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip\n3恰恰相反。它们本身可以被指来指去，但是它们指向的内\n容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。\n\n·常见用法\n取代宏，定义一些不可更改的值\n</code></pre><ul>\n<li>volatile<br>不多见，一般情况下，只有底层才会有到，有兴趣可以百度。  </li>\n</ul>\n<hr>"},{"title":"Linux基本知识","date":"2019-06-05T08:27:11.000Z","_content":"记录初学Linux所学习的知识\n<!--more-->\n\n# 特点  \n1. 命令区分`大小写`  \n2. 使用`Tab`来补全命令,按两下显示可补全的命令  \n3. `上下键`可以查看历史命令  \n4. `Ctrl + L`可以清屏  \n5. 使用`分号`隔开语句可以实现多条命令  \n6. `\\`可以断开长命令，增强可读性  \n7. 命令后加一个`&`可使命令后台运行  \n\n# Linux文件系统目录结构  \n\n|目录|说明|  \n|:-:|:---|  \n|/       |根目录  \n|/bin    |存放必要的命令的目录  \n|/dev    |任何硬件与接口设备以文件的形式放在这个目录下  \n|/etc    |存放系统配置文件的目录  \n|/home   |系统默认的普通用户家目录 \n|/lib    |存放必要运行库的目录  \n|/mnt    |各项设备的文件系统挂载点  \n|/proc   |存放存储进程和系统信息的目录  \n|/root   |系统管理员的家目录  \n|/sbin   |存放系统管理员的目录  \n|/tmp    |临时文件的存放位置，可供所有用户执行写入操作的特有权限  \n|/usr    |UNIX software resource的缩写，是操作系统软件资源所默认放置的目录\n\n- 绝对命令与相对命令  \n绝对命令是从`/`开始的，也就是根目录;而相对路径是从当前目录开始  \n\n# Linux基本命令  \n大部分的命令可以参考我的[另一篇文章](https://178me.github.io/2019/06/02/shell-note1/#more)，下面补充一些命令：  \n\n1. rmdir  \n删除空目录  \nrmdir 参数选项 目录名称  \n\n2. ln\n为文件创建链接，链接分为硬链接和符号链接两种，默认的链接类型为硬链接\nln 参数选项 源文件或目录 目标文件或目录  \n  \n|参数|作用|\n|:-:|:-:|\n|-s|建立符号链接|\n\n\n3. gzip/gunzip  \n压缩/解压缩文件，文件压缩类命令还有bzip2、bunzip2等  \ngizp/gunzip 参数选项 文件  \n  \n|参数|作用|\n|:-:|:-:|\n|-r|递归压缩|\n\n4. whereis  \n寻找命令的可执行文件所在的位置  \nwhereis 参数 命令名称  \n\n5. ss  \n导出socket的统计数据，它显示与netstat命令类似的信息，但能显示比其他工具更详情的TCP状态信息\nss 参数\n\n# 输入/输出重定向和管道命令符的使用\n\n## 输入/输出重定向  \n\n|符号|作用|\n|:-:|:-:|\n|command < file|将file文件作为command命令的标准输入|\n|command > file|将command命令的结果输出到file文件中，若有则覆盖，反之新建|\n|command >> file|将command命令的结果输出到file文件中，若有则追加，反之则新建|\n|command 2> file|将command命令结果的错误信息输出到file文件中，若有则覆盖，反之新建|\n|command &> file|将command命令结果的所有信息输出到file文件中，若有则覆盖，反之新建|\n\n## 管道命令符 \n\n将前一个命令的标准输出作为后一个命令的标准输入  \n命令1 | 命令2 \n\n\n\n\n","source":"_posts/Linux基本知识.md","raw":"---\ntitle: Linux基本知识\ndate: 2019-06-05 16:27:11\ntags: note \ncategories: Linux\n---\n记录初学Linux所学习的知识\n<!--more-->\n\n# 特点  \n1. 命令区分`大小写`  \n2. 使用`Tab`来补全命令,按两下显示可补全的命令  \n3. `上下键`可以查看历史命令  \n4. `Ctrl + L`可以清屏  \n5. 使用`分号`隔开语句可以实现多条命令  \n6. `\\`可以断开长命令，增强可读性  \n7. 命令后加一个`&`可使命令后台运行  \n\n# Linux文件系统目录结构  \n\n|目录|说明|  \n|:-:|:---|  \n|/       |根目录  \n|/bin    |存放必要的命令的目录  \n|/dev    |任何硬件与接口设备以文件的形式放在这个目录下  \n|/etc    |存放系统配置文件的目录  \n|/home   |系统默认的普通用户家目录 \n|/lib    |存放必要运行库的目录  \n|/mnt    |各项设备的文件系统挂载点  \n|/proc   |存放存储进程和系统信息的目录  \n|/root   |系统管理员的家目录  \n|/sbin   |存放系统管理员的目录  \n|/tmp    |临时文件的存放位置，可供所有用户执行写入操作的特有权限  \n|/usr    |UNIX software resource的缩写，是操作系统软件资源所默认放置的目录\n\n- 绝对命令与相对命令  \n绝对命令是从`/`开始的，也就是根目录;而相对路径是从当前目录开始  \n\n# Linux基本命令  \n大部分的命令可以参考我的[另一篇文章](https://178me.github.io/2019/06/02/shell-note1/#more)，下面补充一些命令：  \n\n1. rmdir  \n删除空目录  \nrmdir 参数选项 目录名称  \n\n2. ln\n为文件创建链接，链接分为硬链接和符号链接两种，默认的链接类型为硬链接\nln 参数选项 源文件或目录 目标文件或目录  \n  \n|参数|作用|\n|:-:|:-:|\n|-s|建立符号链接|\n\n\n3. gzip/gunzip  \n压缩/解压缩文件，文件压缩类命令还有bzip2、bunzip2等  \ngizp/gunzip 参数选项 文件  \n  \n|参数|作用|\n|:-:|:-:|\n|-r|递归压缩|\n\n4. whereis  \n寻找命令的可执行文件所在的位置  \nwhereis 参数 命令名称  \n\n5. ss  \n导出socket的统计数据，它显示与netstat命令类似的信息，但能显示比其他工具更详情的TCP状态信息\nss 参数\n\n# 输入/输出重定向和管道命令符的使用\n\n## 输入/输出重定向  \n\n|符号|作用|\n|:-:|:-:|\n|command < file|将file文件作为command命令的标准输入|\n|command > file|将command命令的结果输出到file文件中，若有则覆盖，反之新建|\n|command >> file|将command命令的结果输出到file文件中，若有则追加，反之则新建|\n|command 2> file|将command命令结果的错误信息输出到file文件中，若有则覆盖，反之新建|\n|command &> file|将command命令结果的所有信息输出到file文件中，若有则覆盖，反之新建|\n\n## 管道命令符 \n\n将前一个命令的标准输出作为后一个命令的标准输入  \n命令1 | 命令2 \n\n\n\n\n","slug":"Linux基本知识","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akptr000b7qsg7ah6b0jh","content":"<p>记录初学Linux所学习的知识<br><a id=\"more\"></a></p>\n<h1 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h1><ol>\n<li>命令区分<code>大小写</code>  </li>\n<li>使用<code>Tab</code>来补全命令,按两下显示可补全的命令  </li>\n<li><code>上下键</code>可以查看历史命令  </li>\n<li><code>Ctrl + L</code>可以清屏  </li>\n<li>使用<code>分号</code>隔开语句可以实现多条命令  </li>\n<li><code>\\</code>可以断开长命令，增强可读性  </li>\n<li>命令后加一个<code>&amp;</code>可使命令后台运行  </li>\n</ol>\n<h1 id=\"Linux文件系统目录结构\"><a href=\"#Linux文件系统目录结构\" class=\"headerlink\" title=\"Linux文件系统目录结构\"></a>Linux文件系统目录结构</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">目录</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/</td>\n<td style=\"text-align:left\">根目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/bin</td>\n<td style=\"text-align:left\">存放必要的命令的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/dev</td>\n<td style=\"text-align:left\">任何硬件与接口设备以文件的形式放在这个目录下  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/etc</td>\n<td style=\"text-align:left\">存放系统配置文件的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/home</td>\n<td style=\"text-align:left\">系统默认的普通用户家目录 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/lib</td>\n<td style=\"text-align:left\">存放必要运行库的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/mnt</td>\n<td style=\"text-align:left\">各项设备的文件系统挂载点  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/proc</td>\n<td style=\"text-align:left\">存放存储进程和系统信息的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/root</td>\n<td style=\"text-align:left\">系统管理员的家目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/sbin</td>\n<td style=\"text-align:left\">存放系统管理员的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/tmp</td>\n<td style=\"text-align:left\">临时文件的存放位置，可供所有用户执行写入操作的特有权限  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/usr</td>\n<td style=\"text-align:left\">UNIX software resource的缩写，是操作系统软件资源所默认放置的目录</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>绝对命令与相对命令<br>绝对命令是从<code>/</code>开始的，也就是根目录;而相对路径是从当前目录开始  </li>\n</ul>\n<h1 id=\"Linux基本命令\"><a href=\"#Linux基本命令\" class=\"headerlink\" title=\"Linux基本命令\"></a>Linux基本命令</h1><p>大部分的命令可以参考我的<a href=\"https://178me.github.io/2019/06/02/shell-note1/#more\" target=\"_blank\" rel=\"noopener\">另一篇文章</a>，下面补充一些命令：  </p>\n<ol>\n<li><p>rmdir<br>删除空目录<br>rmdir 参数选项 目录名称  </p>\n</li>\n<li><p>ln<br>为文件创建链接，链接分为硬链接和符号链接两种，默认的链接类型为硬链接<br>ln 参数选项 源文件或目录 目标文件或目录  </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">建立符号链接</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>gzip/gunzip<br>压缩/解压缩文件，文件压缩类命令还有bzip2、bunzip2等<br>gizp/gunzip 参数选项 文件  </li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归压缩</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li><p>whereis<br>寻找命令的可执行文件所在的位置<br>whereis 参数 命令名称  </p>\n</li>\n<li><p>ss<br>导出socket的统计数据，它显示与netstat命令类似的信息，但能显示比其他工具更详情的TCP状态信息<br>ss 参数</p>\n</li>\n</ol>\n<h1 id=\"输入-输出重定向和管道命令符的使用\"><a href=\"#输入-输出重定向和管道命令符的使用\" class=\"headerlink\" title=\"输入/输出重定向和管道命令符的使用\"></a>输入/输出重定向和管道命令符的使用</h1><h2 id=\"输入-输出重定向\"><a href=\"#输入-输出重定向\" class=\"headerlink\" title=\"输入/输出重定向\"></a>输入/输出重定向</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">command &lt; file</td>\n<td style=\"text-align:center\">将file文件作为command命令的标准输入</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command &gt; file</td>\n<td style=\"text-align:center\">将command命令的结果输出到file文件中，若有则覆盖，反之新建</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command &gt;&gt; file</td>\n<td style=\"text-align:center\">将command命令的结果输出到file文件中，若有则追加，反之则新建</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command 2&gt; file</td>\n<td style=\"text-align:center\">将command命令结果的错误信息输出到file文件中，若有则覆盖，反之新建</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command &amp;&gt; file</td>\n<td style=\"text-align:center\">将command命令结果的所有信息输出到file文件中，若有则覆盖，反之新建</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"管道命令符\"><a href=\"#管道命令符\" class=\"headerlink\" title=\"管道命令符\"></a>管道命令符</h2><p>将前一个命令的标准输出作为后一个命令的标准输入<br>命令1 | 命令2 </p>\n","site":{"data":{}},"excerpt":"<p>记录初学Linux所学习的知识<br></p>","more":"<p></p>\n<h1 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h1><ol>\n<li>命令区分<code>大小写</code>  </li>\n<li>使用<code>Tab</code>来补全命令,按两下显示可补全的命令  </li>\n<li><code>上下键</code>可以查看历史命令  </li>\n<li><code>Ctrl + L</code>可以清屏  </li>\n<li>使用<code>分号</code>隔开语句可以实现多条命令  </li>\n<li><code>\\</code>可以断开长命令，增强可读性  </li>\n<li>命令后加一个<code>&amp;</code>可使命令后台运行  </li>\n</ol>\n<h1 id=\"Linux文件系统目录结构\"><a href=\"#Linux文件系统目录结构\" class=\"headerlink\" title=\"Linux文件系统目录结构\"></a>Linux文件系统目录结构</h1><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">目录</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">/</td>\n<td style=\"text-align:left\">根目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/bin</td>\n<td style=\"text-align:left\">存放必要的命令的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/dev</td>\n<td style=\"text-align:left\">任何硬件与接口设备以文件的形式放在这个目录下  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/etc</td>\n<td style=\"text-align:left\">存放系统配置文件的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/home</td>\n<td style=\"text-align:left\">系统默认的普通用户家目录 </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/lib</td>\n<td style=\"text-align:left\">存放必要运行库的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/mnt</td>\n<td style=\"text-align:left\">各项设备的文件系统挂载点  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/proc</td>\n<td style=\"text-align:left\">存放存储进程和系统信息的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/root</td>\n<td style=\"text-align:left\">系统管理员的家目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/sbin</td>\n<td style=\"text-align:left\">存放系统管理员的目录  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/tmp</td>\n<td style=\"text-align:left\">临时文件的存放位置，可供所有用户执行写入操作的特有权限  </td>\n</tr>\n<tr>\n<td style=\"text-align:center\">/usr</td>\n<td style=\"text-align:left\">UNIX software resource的缩写，是操作系统软件资源所默认放置的目录</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>绝对命令与相对命令<br>绝对命令是从<code>/</code>开始的，也就是根目录;而相对路径是从当前目录开始  </li>\n</ul>\n<h1 id=\"Linux基本命令\"><a href=\"#Linux基本命令\" class=\"headerlink\" title=\"Linux基本命令\"></a>Linux基本命令</h1><p>大部分的命令可以参考我的<a href=\"https://178me.github.io/2019/06/02/shell-note1/#more\" target=\"_blank\" rel=\"noopener\">另一篇文章</a>，下面补充一些命令：  </p>\n<ol>\n<li><p>rmdir<br>删除空目录<br>rmdir 参数选项 目录名称  </p>\n</li>\n<li><p>ln<br>为文件创建链接，链接分为硬链接和符号链接两种，默认的链接类型为硬链接<br>ln 参数选项 源文件或目录 目标文件或目录  </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">建立符号链接</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>gzip/gunzip<br>压缩/解压缩文件，文件压缩类命令还有bzip2、bunzip2等<br>gizp/gunzip 参数选项 文件  </li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归压缩</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li><p>whereis<br>寻找命令的可执行文件所在的位置<br>whereis 参数 命令名称  </p>\n</li>\n<li><p>ss<br>导出socket的统计数据，它显示与netstat命令类似的信息，但能显示比其他工具更详情的TCP状态信息<br>ss 参数</p>\n</li>\n</ol>\n<h1 id=\"输入-输出重定向和管道命令符的使用\"><a href=\"#输入-输出重定向和管道命令符的使用\" class=\"headerlink\" title=\"输入/输出重定向和管道命令符的使用\"></a>输入/输出重定向和管道命令符的使用</h1><h2 id=\"输入-输出重定向\"><a href=\"#输入-输出重定向\" class=\"headerlink\" title=\"输入/输出重定向\"></a>输入/输出重定向</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">符号</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">command &lt; file</td>\n<td style=\"text-align:center\">将file文件作为command命令的标准输入</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command &gt; file</td>\n<td style=\"text-align:center\">将command命令的结果输出到file文件中，若有则覆盖，反之新建</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command &gt;&gt; file</td>\n<td style=\"text-align:center\">将command命令的结果输出到file文件中，若有则追加，反之则新建</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command 2&gt; file</td>\n<td style=\"text-align:center\">将command命令结果的错误信息输出到file文件中，若有则覆盖，反之新建</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">command &amp;&gt; file</td>\n<td style=\"text-align:center\">将command命令结果的所有信息输出到file文件中，若有则覆盖，反之新建</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"管道命令符\"><a href=\"#管道命令符\" class=\"headerlink\" title=\"管道命令符\"></a>管道命令符</h2><p>将前一个命令的标准输出作为后一个命令的标准输入<br>命令1 | 命令2 </p>"},{"title":"《Linxu_命令行》笔记","date":"2019-07-05T05:30:47.000Z","_content":"忽略我\n<!--more-->\n# 常见的错误信息  \n\n1. Command not found --- 没有发现命令   \n\n2. Access denied --- 拒绝访问  \n\n3. Write protect error --- 写保护错误  \n\n4. Drive not ready --- 驱动器未准备好  \n\n5. General error --- 通常错误  \n\n6.  ","source":"_posts/Linxu-命令行.md","raw":"---\ntitle: 《Linxu_命令行》笔记\ndate: 2019-07-05 13:30:47\ntags: note\ncategories: Linux\n---\n忽略我\n<!--more-->\n# 常见的错误信息  \n\n1. Command not found --- 没有发现命令   \n\n2. Access denied --- 拒绝访问  \n\n3. Write protect error --- 写保护错误  \n\n4. Drive not ready --- 驱动器未准备好  \n\n5. General error --- 通常错误  \n\n6.  ","slug":"Linxu-命令行","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akptt000e7qsgrinfo2gf","content":"<p>忽略我<br><a id=\"more\"></a></p>\n<h1 id=\"常见的错误信息\"><a href=\"#常见的错误信息\" class=\"headerlink\" title=\"常见的错误信息\"></a>常见的错误信息</h1><ol>\n<li><p>Command not found — 没有发现命令   </p>\n</li>\n<li><p>Access denied — 拒绝访问  </p>\n</li>\n<li><p>Write protect error — 写保护错误  </p>\n</li>\n<li><p>Drive not ready — 驱动器未准备好  </p>\n</li>\n<li><p>General error — 通常错误  </p>\n</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>忽略我<br></p>","more":"<p></p>\n<h1 id=\"常见的错误信息\"><a href=\"#常见的错误信息\" class=\"headerlink\" title=\"常见的错误信息\"></a>常见的错误信息</h1><ol>\n<li><p>Command not found — 没有发现命令   </p>\n</li>\n<li><p>Access denied — 拒绝访问  </p>\n</li>\n<li><p>Write protect error — 写保护错误  </p>\n</li>\n<li><p>Drive not ready — 驱动器未准备好  </p>\n</li>\n<li><p>General error — 通常错误  </p>\n</li>\n<li></li>\n</ol>"},{"title":"Linux基本知识2","date":"2019-06-08T06:09:52.000Z","_content":"继续\n<!--more-->\n\n# 用户与组\n\n## 用户分类  \n系统管理员(root)、系统用户(不可登录)、普通用户（可登录）。  \n## 建立帐号  \n系统会为用户帐号分配至少两个ID，一个是用户ID(UID)，一个是组ID(GID),管理员的两\n个ID都为0，非管理员为1000～65535 。  \n\n- 用户帐号及其相关信息均存放在/etc/passwd配置文件中，密码信息存放在/etc/shadow配置文件中  \n\n|**/etc/passwd文件结构意义**|\n|:-:|\n\n|用户名称|用户密码|UID|GID|用户说明信息|用户家目录|用户的shell|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|root|x|0|0|root|/root|/bin/bash|\n\n# 添加、修改与删除用户的命令\n\n## useradd  \n添加新的用户帐号命令  \nuseradd 参数选项 用户名  \n\n|参数|作用|\n|:-:|:-:|\n|-d|制定用户家目录|\n|-M|不创建家目录|\n|-e|指定账户过期的时间，格式为MM/DD/YY or YYYY-MM-DD|\n|-g|指定账户的主组群（存在的）|\n|-G|指定账户的附属组，多组用逗号分隔|\n|-n|不创建和用户帐号同名的私有用户组|\n|-s|指定账户登录时使用的shell解释器|\n|-u|指定用户的默认UID|\n\n\n## passwd  \n设置用户密码  \npasswd 参数选项 用户账户名  \n\n|参数|作用|\n|:-:|:-:|\n|-l|锁定用户，禁止其登录|\n|-u|解除锁定，允许用户登录|\n|-S|显示用户的密码是否被锁定，以及密码所采用的加密算法名称|\n|-d|清空账户密码，将不能登录系统，除非重新设置密码|\n|-stdin|允许通过标准输入修改密码|\n\n## usermod  \n修改用户属性  \nusermod 参数选项 用户账户名\n\n|参数|作用|\n|:-:|:-:|\n|-m,-d|重新指定用户的家目录并自动把旧的数据转移过去|\n|-e|修改账户过期的时间|\n|-g|修改主组群|\n|-G|修改附属组|\n|-l|修改用户名称|\n|-L|锁定用户|\n|-U|解锁用户|\n|-s|修改用户登录时使用的shell解释器|\n|-u|修改用户的UID|\n\n## userdel  \n删除用户  \nuserdel -r 用户账户名  \n\n# 添加、修改和删除用户组的命令   \n## groupadd  \n增加一个新的用户组  \ngroupadd 参数选项 用户组名  \n\n|参数|作用|\n|:-:|:-:|\n|-g|指定GID|\n\n## groupmod   \n修改用户组名信息  \ngroupmod 参数选项  用户组名  \n \n|参数|作用|\n|:-:|:-:|\n|-g|修改GID|\n|-n|修改组名|\n\n## groupdel  \n删除用户组名  \ngroupdel 用户组名\n\n# 文件权限管理  \n\n## 文件详细信息，共分七列，所含信息的含义如下:\n\n1. 文件类型权限包含文件所属类型和用户对该文件的权限，共有11位或者10位，最后一位`.`与selinux和acl有关   \n\n- 第一位用来描述文件类型，如下表所示:    \n\n|第一位|描述|\n|:-:|:-:|\n|-|普通文件|\n|d|目录文件|\n|l|软链接文件|\n|b|块设备|\n|c|窜行端口设备，如键盘、鼠标等|\n|s|套接字文件，用于进程间通信\n\n\n- 后边的九位，没三位为一组，均是可读\"r\" 可写\"w\" 可执行\"x\" 参数的组合，前三，中三，后三分\n    别代表所属用户(u)的权限，所属组(g)的权限和其他所有用户(o)的权限\n- 文件权限的数字法，基于字符的rwx的权限计算而来，r(4)、w(2)、x(1)\n2. 链接占用的节点数;普通文件的节点数和链接数有关，目录与目录下的所有目录及文件有关  \n3. 文件所属用户   \n4. 文件所属组  \n5. 文件大小，kb为单位  \n6. 最后一次修改日期\n7. 文件名  \n\n## 文件权限的更改  \n\n1. chown  \n更改文件的所属用户和所属组  \nchown 参数 账户名 || :组名  文件名  \n文件夹需要加-R  \n\n2. chmod  \n改变用户对文件的读写权限  \nchmod 参数 ijk 文件名  \n\n|参数|作用|\n|:-:|:-:|\n|ijk|文件权限的数组法来修改权限|\n|-R|当文件是文件夹时需要|\n|a|全部权限，以下参数的用法，例如：chmod u+w test|\n|u|用户权限|\n|g|组权限|\n|o|其他组群权限|\n\n\n3. umask \n设置需要减去的权限  \numask ijk  \n\n\n|参数|作用|\n|:-:|:-:|\n|ijk|文件权限的数字法|\n|无参数|查看预设值|\n\n# 文件特殊权限  \n\n## SUID  \n在一个可执行文件加上s权限，任何人在执行该命令时会临时具有所属用户的权限  \nchmod u+s 可执行文件  \n1. SUID仅对命令有效  \n2. 执行者要有x的权限  \n3. 仅在执行时有效  \n4. 执行者将具有所属用户的权限  \n\n## SGID   \nSGID针对命令是获得命令所属组的权限，针对目录的话，那么目录下创建的文件自动会继承目录所属组\nchmod g+s 文件 || 目录  \n\n## SBIT  \n如果对一个目录加上SBIT权限，那么仅root用户和该目录下的文件拥有人才能删除该文件  \nchmod o+t 文件 || 目录  \n\n- 如果采用数字方式，在三位数字前再加上一位代表特殊权限，4代表SUID，2代表SGID，1代表SBIT  \n\n# 文件隐藏属性与访问控制列表  \n## chattr  \n设置文件的隐藏权限  \nchattr 参数 文件  \n\n|参数|作用|\n|:-:|:-|\n|+i，-i|+可以让文件不能被删除，重命名，不能写入，添加数据，不能创建硬链接;-恢复|\n|+a,-a|+让文件添加数据，不能删除，修改数据|\n\n## lsattr  \n显示文件的隐藏权限  \nlsattr 参数 文件  \n\n# 访问控制列表  \n## setfacl  \n管理设置文件/目录的ACL规则  \nsetfacl 参数 文件名  \n\n|参数|作用|\n|:-:|:-:|\n|-R|对目录文件使用|\n|-m|普通文件|\n|-b|删除文件的ACL|  \n\n## getfacl  \n显示文件的ACL信息  \ngetfacl  文件名  \n\n# su与sudo命令  \n## su  \n切换用户  \nsu 用户名  \n\n## su -  \n切换用户且重新读取环境变量  \nsu - 用户名  \n\n## sudo  \n以管理员身份运行命令  \nsudo 命令  \n\n# vim  \n输入命令vimtutor自行学习  \n\n# Gcc和G++  \n## 编译和运行  \n```\ngcc/g++ -c 源代码文件名             //编译\ngcc/g++ -o 可执行文件名  源代码文件     //生成可执行文件  \n./可执行文件名      //执行文件  \n```\n","source":"_posts/Linux基本知识2.md","raw":"---\ntitle: Linux基本知识2\ndate: 2019-06-08 14:09:52\ntags: note\ncategories: Linux\n---\n继续\n<!--more-->\n\n# 用户与组\n\n## 用户分类  \n系统管理员(root)、系统用户(不可登录)、普通用户（可登录）。  \n## 建立帐号  \n系统会为用户帐号分配至少两个ID，一个是用户ID(UID)，一个是组ID(GID),管理员的两\n个ID都为0，非管理员为1000～65535 。  \n\n- 用户帐号及其相关信息均存放在/etc/passwd配置文件中，密码信息存放在/etc/shadow配置文件中  \n\n|**/etc/passwd文件结构意义**|\n|:-:|\n\n|用户名称|用户密码|UID|GID|用户说明信息|用户家目录|用户的shell|\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n|root|x|0|0|root|/root|/bin/bash|\n\n# 添加、修改与删除用户的命令\n\n## useradd  \n添加新的用户帐号命令  \nuseradd 参数选项 用户名  \n\n|参数|作用|\n|:-:|:-:|\n|-d|制定用户家目录|\n|-M|不创建家目录|\n|-e|指定账户过期的时间，格式为MM/DD/YY or YYYY-MM-DD|\n|-g|指定账户的主组群（存在的）|\n|-G|指定账户的附属组，多组用逗号分隔|\n|-n|不创建和用户帐号同名的私有用户组|\n|-s|指定账户登录时使用的shell解释器|\n|-u|指定用户的默认UID|\n\n\n## passwd  \n设置用户密码  \npasswd 参数选项 用户账户名  \n\n|参数|作用|\n|:-:|:-:|\n|-l|锁定用户，禁止其登录|\n|-u|解除锁定，允许用户登录|\n|-S|显示用户的密码是否被锁定，以及密码所采用的加密算法名称|\n|-d|清空账户密码，将不能登录系统，除非重新设置密码|\n|-stdin|允许通过标准输入修改密码|\n\n## usermod  \n修改用户属性  \nusermod 参数选项 用户账户名\n\n|参数|作用|\n|:-:|:-:|\n|-m,-d|重新指定用户的家目录并自动把旧的数据转移过去|\n|-e|修改账户过期的时间|\n|-g|修改主组群|\n|-G|修改附属组|\n|-l|修改用户名称|\n|-L|锁定用户|\n|-U|解锁用户|\n|-s|修改用户登录时使用的shell解释器|\n|-u|修改用户的UID|\n\n## userdel  \n删除用户  \nuserdel -r 用户账户名  \n\n# 添加、修改和删除用户组的命令   \n## groupadd  \n增加一个新的用户组  \ngroupadd 参数选项 用户组名  \n\n|参数|作用|\n|:-:|:-:|\n|-g|指定GID|\n\n## groupmod   \n修改用户组名信息  \ngroupmod 参数选项  用户组名  \n \n|参数|作用|\n|:-:|:-:|\n|-g|修改GID|\n|-n|修改组名|\n\n## groupdel  \n删除用户组名  \ngroupdel 用户组名\n\n# 文件权限管理  \n\n## 文件详细信息，共分七列，所含信息的含义如下:\n\n1. 文件类型权限包含文件所属类型和用户对该文件的权限，共有11位或者10位，最后一位`.`与selinux和acl有关   \n\n- 第一位用来描述文件类型，如下表所示:    \n\n|第一位|描述|\n|:-:|:-:|\n|-|普通文件|\n|d|目录文件|\n|l|软链接文件|\n|b|块设备|\n|c|窜行端口设备，如键盘、鼠标等|\n|s|套接字文件，用于进程间通信\n\n\n- 后边的九位，没三位为一组，均是可读\"r\" 可写\"w\" 可执行\"x\" 参数的组合，前三，中三，后三分\n    别代表所属用户(u)的权限，所属组(g)的权限和其他所有用户(o)的权限\n- 文件权限的数字法，基于字符的rwx的权限计算而来，r(4)、w(2)、x(1)\n2. 链接占用的节点数;普通文件的节点数和链接数有关，目录与目录下的所有目录及文件有关  \n3. 文件所属用户   \n4. 文件所属组  \n5. 文件大小，kb为单位  \n6. 最后一次修改日期\n7. 文件名  \n\n## 文件权限的更改  \n\n1. chown  \n更改文件的所属用户和所属组  \nchown 参数 账户名 || :组名  文件名  \n文件夹需要加-R  \n\n2. chmod  \n改变用户对文件的读写权限  \nchmod 参数 ijk 文件名  \n\n|参数|作用|\n|:-:|:-:|\n|ijk|文件权限的数组法来修改权限|\n|-R|当文件是文件夹时需要|\n|a|全部权限，以下参数的用法，例如：chmod u+w test|\n|u|用户权限|\n|g|组权限|\n|o|其他组群权限|\n\n\n3. umask \n设置需要减去的权限  \numask ijk  \n\n\n|参数|作用|\n|:-:|:-:|\n|ijk|文件权限的数字法|\n|无参数|查看预设值|\n\n# 文件特殊权限  \n\n## SUID  \n在一个可执行文件加上s权限，任何人在执行该命令时会临时具有所属用户的权限  \nchmod u+s 可执行文件  \n1. SUID仅对命令有效  \n2. 执行者要有x的权限  \n3. 仅在执行时有效  \n4. 执行者将具有所属用户的权限  \n\n## SGID   \nSGID针对命令是获得命令所属组的权限，针对目录的话，那么目录下创建的文件自动会继承目录所属组\nchmod g+s 文件 || 目录  \n\n## SBIT  \n如果对一个目录加上SBIT权限，那么仅root用户和该目录下的文件拥有人才能删除该文件  \nchmod o+t 文件 || 目录  \n\n- 如果采用数字方式，在三位数字前再加上一位代表特殊权限，4代表SUID，2代表SGID，1代表SBIT  \n\n# 文件隐藏属性与访问控制列表  \n## chattr  \n设置文件的隐藏权限  \nchattr 参数 文件  \n\n|参数|作用|\n|:-:|:-|\n|+i，-i|+可以让文件不能被删除，重命名，不能写入，添加数据，不能创建硬链接;-恢复|\n|+a,-a|+让文件添加数据，不能删除，修改数据|\n\n## lsattr  \n显示文件的隐藏权限  \nlsattr 参数 文件  \n\n# 访问控制列表  \n## setfacl  \n管理设置文件/目录的ACL规则  \nsetfacl 参数 文件名  \n\n|参数|作用|\n|:-:|:-:|\n|-R|对目录文件使用|\n|-m|普通文件|\n|-b|删除文件的ACL|  \n\n## getfacl  \n显示文件的ACL信息  \ngetfacl  文件名  \n\n# su与sudo命令  \n## su  \n切换用户  \nsu 用户名  \n\n## su -  \n切换用户且重新读取环境变量  \nsu - 用户名  \n\n## sudo  \n以管理员身份运行命令  \nsudo 命令  \n\n# vim  \n输入命令vimtutor自行学习  \n\n# Gcc和G++  \n## 编译和运行  \n```\ngcc/g++ -c 源代码文件名             //编译\ngcc/g++ -o 可执行文件名  源代码文件     //生成可执行文件  \n./可执行文件名      //执行文件  \n```\n","slug":"Linux基本知识2","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akptx000i7qsg75hwmvg4","content":"<p>继续<br><a id=\"more\"></a></p>\n<h1 id=\"用户与组\"><a href=\"#用户与组\" class=\"headerlink\" title=\"用户与组\"></a>用户与组</h1><h2 id=\"用户分类\"><a href=\"#用户分类\" class=\"headerlink\" title=\"用户分类\"></a>用户分类</h2><p>系统管理员(root)、系统用户(不可登录)、普通用户（可登录）。  </p>\n<h2 id=\"建立帐号\"><a href=\"#建立帐号\" class=\"headerlink\" title=\"建立帐号\"></a>建立帐号</h2><p>系统会为用户帐号分配至少两个ID，一个是用户ID(UID)，一个是组ID(GID),管理员的两<br>个ID都为0，非管理员为1000～65535 。  </p>\n<ul>\n<li>用户帐号及其相关信息均存放在/etc/passwd配置文件中，密码信息存放在/etc/shadow配置文件中  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>/etc/passwd文件结构意义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">用户名称</th>\n<th style=\"text-align:center\">用户密码</th>\n<th style=\"text-align:center\">UID</th>\n<th style=\"text-align:center\">GID</th>\n<th style=\"text-align:center\">用户说明信息</th>\n<th style=\"text-align:center\">用户家目录</th>\n<th style=\"text-align:center\">用户的shell</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">root</td>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">root</td>\n<td style=\"text-align:center\">/root</td>\n<td style=\"text-align:center\">/bin/bash</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"添加、修改与删除用户的命令\"><a href=\"#添加、修改与删除用户的命令\" class=\"headerlink\" title=\"添加、修改与删除用户的命令\"></a>添加、修改与删除用户的命令</h1><h2 id=\"useradd\"><a href=\"#useradd\" class=\"headerlink\" title=\"useradd\"></a>useradd</h2><p>添加新的用户帐号命令<br>useradd 参数选项 用户名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">制定用户家目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-M</td>\n<td style=\"text-align:center\">不创建家目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">指定账户过期的时间，格式为MM/DD/YY or YYYY-MM-DD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">指定账户的主组群（存在的）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-G</td>\n<td style=\"text-align:center\">指定账户的附属组，多组用逗号分隔</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">不创建和用户帐号同名的私有用户组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">指定账户登录时使用的shell解释器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">指定用户的默认UID</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"passwd\"><a href=\"#passwd\" class=\"headerlink\" title=\"passwd\"></a>passwd</h2><p>设置用户密码<br>passwd 参数选项 用户账户名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">锁定用户，禁止其登录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">解除锁定，允许用户登录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-S</td>\n<td style=\"text-align:center\">显示用户的密码是否被锁定，以及密码所采用的加密算法名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">清空账户密码，将不能登录系统，除非重新设置密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-stdin</td>\n<td style=\"text-align:center\">允许通过标准输入修改密码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"usermod\"><a href=\"#usermod\" class=\"headerlink\" title=\"usermod\"></a>usermod</h2><p>修改用户属性<br>usermod 参数选项 用户账户名</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-m,-d</td>\n<td style=\"text-align:center\">重新指定用户的家目录并自动把旧的数据转移过去</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">修改账户过期的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">修改主组群</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-G</td>\n<td style=\"text-align:center\">修改附属组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">修改用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-L</td>\n<td style=\"text-align:center\">锁定用户</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-U</td>\n<td style=\"text-align:center\">解锁用户</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">修改用户登录时使用的shell解释器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">修改用户的UID</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"userdel\"><a href=\"#userdel\" class=\"headerlink\" title=\"userdel\"></a>userdel</h2><p>删除用户<br>userdel -r 用户账户名  </p>\n<h1 id=\"添加、修改和删除用户组的命令\"><a href=\"#添加、修改和删除用户组的命令\" class=\"headerlink\" title=\"添加、修改和删除用户组的命令\"></a>添加、修改和删除用户组的命令</h1><h2 id=\"groupadd\"><a href=\"#groupadd\" class=\"headerlink\" title=\"groupadd\"></a>groupadd</h2><p>增加一个新的用户组<br>groupadd 参数选项 用户组名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">指定GID</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"groupmod\"><a href=\"#groupmod\" class=\"headerlink\" title=\"groupmod\"></a>groupmod</h2><p>修改用户组名信息<br>groupmod 参数选项  用户组名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">修改GID</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">修改组名</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"groupdel\"><a href=\"#groupdel\" class=\"headerlink\" title=\"groupdel\"></a>groupdel</h2><p>删除用户组名<br>groupdel 用户组名</p>\n<h1 id=\"文件权限管理\"><a href=\"#文件权限管理\" class=\"headerlink\" title=\"文件权限管理\"></a>文件权限管理</h1><h2 id=\"文件详细信息，共分七列，所含信息的含义如下\"><a href=\"#文件详细信息，共分七列，所含信息的含义如下\" class=\"headerlink\" title=\"文件详细信息，共分七列，所含信息的含义如下:\"></a>文件详细信息，共分七列，所含信息的含义如下:</h2><ol>\n<li>文件类型权限包含文件所属类型和用户对该文件的权限，共有11位或者10位，最后一位<code>.</code>与selinux和acl有关   </li>\n</ol>\n<ul>\n<li>第一位用来描述文件类型，如下表所示:    </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">第一位</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">普通文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">d</td>\n<td style=\"text-align:center\">目录文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">l</td>\n<td style=\"text-align:center\">软链接文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">b</td>\n<td style=\"text-align:center\">块设备</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">c</td>\n<td style=\"text-align:center\">窜行端口设备，如键盘、鼠标等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:center\">套接字文件，用于进程间通信</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>后边的九位，没三位为一组，均是可读”r” 可写”w” 可执行”x” 参数的组合，前三，中三，后三分<br>  别代表所属用户(u)的权限，所属组(g)的权限和其他所有用户(o)的权限</li>\n<li>文件权限的数字法，基于字符的rwx的权限计算而来，r(4)、w(2)、x(1)</li>\n</ul>\n<ol start=\"2\">\n<li>链接占用的节点数;普通文件的节点数和链接数有关，目录与目录下的所有目录及文件有关  </li>\n<li>文件所属用户   </li>\n<li>文件所属组  </li>\n<li>文件大小，kb为单位  </li>\n<li>最后一次修改日期</li>\n<li>文件名  </li>\n</ol>\n<h2 id=\"文件权限的更改\"><a href=\"#文件权限的更改\" class=\"headerlink\" title=\"文件权限的更改\"></a>文件权限的更改</h2><ol>\n<li><p>chown<br>更改文件的所属用户和所属组<br>chown 参数 账户名 || :组名  文件名<br>文件夹需要加-R  </p>\n</li>\n<li><p>chmod<br>改变用户对文件的读写权限<br>chmod 参数 ijk 文件名  </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ijk</td>\n<td style=\"text-align:center\">文件权限的数组法来修改权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-R</td>\n<td style=\"text-align:center\">当文件是文件夹时需要</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">全部权限，以下参数的用法，例如：chmod u+w test</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:center\">用户权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">g</td>\n<td style=\"text-align:center\">组权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">o</td>\n<td style=\"text-align:center\">其他组群权限</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>umask<br>设置需要减去的权限<br>umask ijk  </li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ijk</td>\n<td style=\"text-align:center\">文件权限的数字法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">无参数</td>\n<td style=\"text-align:center\">查看预设值</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"文件特殊权限\"><a href=\"#文件特殊权限\" class=\"headerlink\" title=\"文件特殊权限\"></a>文件特殊权限</h1><h2 id=\"SUID\"><a href=\"#SUID\" class=\"headerlink\" title=\"SUID\"></a>SUID</h2><p>在一个可执行文件加上s权限，任何人在执行该命令时会临时具有所属用户的权限<br>chmod u+s 可执行文件  </p>\n<ol>\n<li>SUID仅对命令有效  </li>\n<li>执行者要有x的权限  </li>\n<li>仅在执行时有效  </li>\n<li>执行者将具有所属用户的权限  </li>\n</ol>\n<h2 id=\"SGID\"><a href=\"#SGID\" class=\"headerlink\" title=\"SGID\"></a>SGID</h2><p>SGID针对命令是获得命令所属组的权限，针对目录的话，那么目录下创建的文件自动会继承目录所属组<br>chmod g+s 文件 || 目录  </p>\n<h2 id=\"SBIT\"><a href=\"#SBIT\" class=\"headerlink\" title=\"SBIT\"></a>SBIT</h2><p>如果对一个目录加上SBIT权限，那么仅root用户和该目录下的文件拥有人才能删除该文件<br>chmod o+t 文件 || 目录  </p>\n<ul>\n<li>如果采用数字方式，在三位数字前再加上一位代表特殊权限，4代表SUID，2代表SGID，1代表SBIT  </li>\n</ul>\n<h1 id=\"文件隐藏属性与访问控制列表\"><a href=\"#文件隐藏属性与访问控制列表\" class=\"headerlink\" title=\"文件隐藏属性与访问控制列表\"></a>文件隐藏属性与访问控制列表</h1><h2 id=\"chattr\"><a href=\"#chattr\" class=\"headerlink\" title=\"chattr\"></a>chattr</h2><p>设置文件的隐藏权限<br>chattr 参数 文件  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">+i，-i</td>\n<td style=\"text-align:left\">+可以让文件不能被删除，重命名，不能写入，添加数据，不能创建硬链接;-恢复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+a,-a</td>\n<td style=\"text-align:left\">+让文件添加数据，不能删除，修改数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsattr\"><a href=\"#lsattr\" class=\"headerlink\" title=\"lsattr\"></a>lsattr</h2><p>显示文件的隐藏权限<br>lsattr 参数 文件  </p>\n<h1 id=\"访问控制列表\"><a href=\"#访问控制列表\" class=\"headerlink\" title=\"访问控制列表\"></a>访问控制列表</h1><h2 id=\"setfacl\"><a href=\"#setfacl\" class=\"headerlink\" title=\"setfacl\"></a>setfacl</h2><p>管理设置文件/目录的ACL规则<br>setfacl 参数 文件名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-R</td>\n<td style=\"text-align:center\">对目录文件使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-m</td>\n<td style=\"text-align:center\">普通文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:center\">删除文件的ACL</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"getfacl\"><a href=\"#getfacl\" class=\"headerlink\" title=\"getfacl\"></a>getfacl</h2><p>显示文件的ACL信息<br>getfacl  文件名  </p>\n<h1 id=\"su与sudo命令\"><a href=\"#su与sudo命令\" class=\"headerlink\" title=\"su与sudo命令\"></a>su与sudo命令</h1><h2 id=\"su\"><a href=\"#su\" class=\"headerlink\" title=\"su\"></a>su</h2><p>切换用户<br>su 用户名  </p>\n<h2 id=\"su-1\"><a href=\"#su-1\" class=\"headerlink\" title=\"su -\"></a>su -</h2><p>切换用户且重新读取环境变量<br>su - 用户名  </p>\n<h2 id=\"sudo\"><a href=\"#sudo\" class=\"headerlink\" title=\"sudo\"></a>sudo</h2><p>以管理员身份运行命令<br>sudo 命令  </p>\n<h1 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h1><p>输入命令vimtutor自行学习  </p>\n<h1 id=\"Gcc和G\"><a href=\"#Gcc和G\" class=\"headerlink\" title=\"Gcc和G++\"></a>Gcc和G++</h1><h2 id=\"编译和运行\"><a href=\"#编译和运行\" class=\"headerlink\" title=\"编译和运行\"></a>编译和运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc/g++ -c 源代码文件名             //编译</span><br><span class=\"line\">gcc/g++ -o 可执行文件名  源代码文件     //生成可执行文件  </span><br><span class=\"line\">./可执行文件名      //执行文件</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>继续<br></p>","more":"<p></p>\n<h1 id=\"用户与组\"><a href=\"#用户与组\" class=\"headerlink\" title=\"用户与组\"></a>用户与组</h1><h2 id=\"用户分类\"><a href=\"#用户分类\" class=\"headerlink\" title=\"用户分类\"></a>用户分类</h2><p>系统管理员(root)、系统用户(不可登录)、普通用户（可登录）。  </p>\n<h2 id=\"建立帐号\"><a href=\"#建立帐号\" class=\"headerlink\" title=\"建立帐号\"></a>建立帐号</h2><p>系统会为用户帐号分配至少两个ID，一个是用户ID(UID)，一个是组ID(GID),管理员的两<br>个ID都为0，非管理员为1000～65535 。  </p>\n<ul>\n<li>用户帐号及其相关信息均存放在/etc/passwd配置文件中，密码信息存放在/etc/shadow配置文件中  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><strong>/etc/passwd文件结构意义</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">用户名称</th>\n<th style=\"text-align:center\">用户密码</th>\n<th style=\"text-align:center\">UID</th>\n<th style=\"text-align:center\">GID</th>\n<th style=\"text-align:center\">用户说明信息</th>\n<th style=\"text-align:center\">用户家目录</th>\n<th style=\"text-align:center\">用户的shell</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">root</td>\n<td style=\"text-align:center\">x</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">root</td>\n<td style=\"text-align:center\">/root</td>\n<td style=\"text-align:center\">/bin/bash</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"添加、修改与删除用户的命令\"><a href=\"#添加、修改与删除用户的命令\" class=\"headerlink\" title=\"添加、修改与删除用户的命令\"></a>添加、修改与删除用户的命令</h1><h2 id=\"useradd\"><a href=\"#useradd\" class=\"headerlink\" title=\"useradd\"></a>useradd</h2><p>添加新的用户帐号命令<br>useradd 参数选项 用户名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">制定用户家目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-M</td>\n<td style=\"text-align:center\">不创建家目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">指定账户过期的时间，格式为MM/DD/YY or YYYY-MM-DD</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">指定账户的主组群（存在的）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-G</td>\n<td style=\"text-align:center\">指定账户的附属组，多组用逗号分隔</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">不创建和用户帐号同名的私有用户组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">指定账户登录时使用的shell解释器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">指定用户的默认UID</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"passwd\"><a href=\"#passwd\" class=\"headerlink\" title=\"passwd\"></a>passwd</h2><p>设置用户密码<br>passwd 参数选项 用户账户名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">锁定用户，禁止其登录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">解除锁定，允许用户登录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-S</td>\n<td style=\"text-align:center\">显示用户的密码是否被锁定，以及密码所采用的加密算法名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">清空账户密码，将不能登录系统，除非重新设置密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-stdin</td>\n<td style=\"text-align:center\">允许通过标准输入修改密码</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"usermod\"><a href=\"#usermod\" class=\"headerlink\" title=\"usermod\"></a>usermod</h2><p>修改用户属性<br>usermod 参数选项 用户账户名</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-m,-d</td>\n<td style=\"text-align:center\">重新指定用户的家目录并自动把旧的数据转移过去</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">修改账户过期的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">修改主组群</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-G</td>\n<td style=\"text-align:center\">修改附属组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">修改用户名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-L</td>\n<td style=\"text-align:center\">锁定用户</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-U</td>\n<td style=\"text-align:center\">解锁用户</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-s</td>\n<td style=\"text-align:center\">修改用户登录时使用的shell解释器</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">修改用户的UID</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"userdel\"><a href=\"#userdel\" class=\"headerlink\" title=\"userdel\"></a>userdel</h2><p>删除用户<br>userdel -r 用户账户名  </p>\n<h1 id=\"添加、修改和删除用户组的命令\"><a href=\"#添加、修改和删除用户组的命令\" class=\"headerlink\" title=\"添加、修改和删除用户组的命令\"></a>添加、修改和删除用户组的命令</h1><h2 id=\"groupadd\"><a href=\"#groupadd\" class=\"headerlink\" title=\"groupadd\"></a>groupadd</h2><p>增加一个新的用户组<br>groupadd 参数选项 用户组名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">指定GID</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"groupmod\"><a href=\"#groupmod\" class=\"headerlink\" title=\"groupmod\"></a>groupmod</h2><p>修改用户组名信息<br>groupmod 参数选项  用户组名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-g</td>\n<td style=\"text-align:center\">修改GID</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">修改组名</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"groupdel\"><a href=\"#groupdel\" class=\"headerlink\" title=\"groupdel\"></a>groupdel</h2><p>删除用户组名<br>groupdel 用户组名</p>\n<h1 id=\"文件权限管理\"><a href=\"#文件权限管理\" class=\"headerlink\" title=\"文件权限管理\"></a>文件权限管理</h1><h2 id=\"文件详细信息，共分七列，所含信息的含义如下\"><a href=\"#文件详细信息，共分七列，所含信息的含义如下\" class=\"headerlink\" title=\"文件详细信息，共分七列，所含信息的含义如下:\"></a>文件详细信息，共分七列，所含信息的含义如下:</h2><ol>\n<li>文件类型权限包含文件所属类型和用户对该文件的权限，共有11位或者10位，最后一位<code>.</code>与selinux和acl有关   </li>\n</ol>\n<ul>\n<li>第一位用来描述文件类型，如下表所示:    </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">第一位</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">普通文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">d</td>\n<td style=\"text-align:center\">目录文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">l</td>\n<td style=\"text-align:center\">软链接文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">b</td>\n<td style=\"text-align:center\">块设备</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">c</td>\n<td style=\"text-align:center\">窜行端口设备，如键盘、鼠标等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">s</td>\n<td style=\"text-align:center\">套接字文件，用于进程间通信</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>后边的九位，没三位为一组，均是可读”r” 可写”w” 可执行”x” 参数的组合，前三，中三，后三分<br>  别代表所属用户(u)的权限，所属组(g)的权限和其他所有用户(o)的权限</li>\n<li>文件权限的数字法，基于字符的rwx的权限计算而来，r(4)、w(2)、x(1)</li>\n</ul>\n<ol start=\"2\">\n<li>链接占用的节点数;普通文件的节点数和链接数有关，目录与目录下的所有目录及文件有关  </li>\n<li>文件所属用户   </li>\n<li>文件所属组  </li>\n<li>文件大小，kb为单位  </li>\n<li>最后一次修改日期</li>\n<li>文件名  </li>\n</ol>\n<h2 id=\"文件权限的更改\"><a href=\"#文件权限的更改\" class=\"headerlink\" title=\"文件权限的更改\"></a>文件权限的更改</h2><ol>\n<li><p>chown<br>更改文件的所属用户和所属组<br>chown 参数 账户名 || :组名  文件名<br>文件夹需要加-R  </p>\n</li>\n<li><p>chmod<br>改变用户对文件的读写权限<br>chmod 参数 ijk 文件名  </p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ijk</td>\n<td style=\"text-align:center\">文件权限的数组法来修改权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-R</td>\n<td style=\"text-align:center\">当文件是文件夹时需要</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">a</td>\n<td style=\"text-align:center\">全部权限，以下参数的用法，例如：chmod u+w test</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u</td>\n<td style=\"text-align:center\">用户权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">g</td>\n<td style=\"text-align:center\">组权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">o</td>\n<td style=\"text-align:center\">其他组群权限</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"3\">\n<li>umask<br>设置需要减去的权限<br>umask ijk  </li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">ijk</td>\n<td style=\"text-align:center\">文件权限的数字法</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">无参数</td>\n<td style=\"text-align:center\">查看预设值</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"文件特殊权限\"><a href=\"#文件特殊权限\" class=\"headerlink\" title=\"文件特殊权限\"></a>文件特殊权限</h1><h2 id=\"SUID\"><a href=\"#SUID\" class=\"headerlink\" title=\"SUID\"></a>SUID</h2><p>在一个可执行文件加上s权限，任何人在执行该命令时会临时具有所属用户的权限<br>chmod u+s 可执行文件  </p>\n<ol>\n<li>SUID仅对命令有效  </li>\n<li>执行者要有x的权限  </li>\n<li>仅在执行时有效  </li>\n<li>执行者将具有所属用户的权限  </li>\n</ol>\n<h2 id=\"SGID\"><a href=\"#SGID\" class=\"headerlink\" title=\"SGID\"></a>SGID</h2><p>SGID针对命令是获得命令所属组的权限，针对目录的话，那么目录下创建的文件自动会继承目录所属组<br>chmod g+s 文件 || 目录  </p>\n<h2 id=\"SBIT\"><a href=\"#SBIT\" class=\"headerlink\" title=\"SBIT\"></a>SBIT</h2><p>如果对一个目录加上SBIT权限，那么仅root用户和该目录下的文件拥有人才能删除该文件<br>chmod o+t 文件 || 目录  </p>\n<ul>\n<li>如果采用数字方式，在三位数字前再加上一位代表特殊权限，4代表SUID，2代表SGID，1代表SBIT  </li>\n</ul>\n<h1 id=\"文件隐藏属性与访问控制列表\"><a href=\"#文件隐藏属性与访问控制列表\" class=\"headerlink\" title=\"文件隐藏属性与访问控制列表\"></a>文件隐藏属性与访问控制列表</h1><h2 id=\"chattr\"><a href=\"#chattr\" class=\"headerlink\" title=\"chattr\"></a>chattr</h2><p>设置文件的隐藏权限<br>chattr 参数 文件  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:left\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">+i，-i</td>\n<td style=\"text-align:left\">+可以让文件不能被删除，重命名，不能写入，添加数据，不能创建硬链接;-恢复</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">+a,-a</td>\n<td style=\"text-align:left\">+让文件添加数据，不能删除，修改数据</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"lsattr\"><a href=\"#lsattr\" class=\"headerlink\" title=\"lsattr\"></a>lsattr</h2><p>显示文件的隐藏权限<br>lsattr 参数 文件  </p>\n<h1 id=\"访问控制列表\"><a href=\"#访问控制列表\" class=\"headerlink\" title=\"访问控制列表\"></a>访问控制列表</h1><h2 id=\"setfacl\"><a href=\"#setfacl\" class=\"headerlink\" title=\"setfacl\"></a>setfacl</h2><p>管理设置文件/目录的ACL规则<br>setfacl 参数 文件名  </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-R</td>\n<td style=\"text-align:center\">对目录文件使用</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-m</td>\n<td style=\"text-align:center\">普通文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:center\">删除文件的ACL</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"getfacl\"><a href=\"#getfacl\" class=\"headerlink\" title=\"getfacl\"></a>getfacl</h2><p>显示文件的ACL信息<br>getfacl  文件名  </p>\n<h1 id=\"su与sudo命令\"><a href=\"#su与sudo命令\" class=\"headerlink\" title=\"su与sudo命令\"></a>su与sudo命令</h1><h2 id=\"su\"><a href=\"#su\" class=\"headerlink\" title=\"su\"></a>su</h2><p>切换用户<br>su 用户名  </p>\n<h2 id=\"su-1\"><a href=\"#su-1\" class=\"headerlink\" title=\"su -\"></a>su -</h2><p>切换用户且重新读取环境变量<br>su - 用户名  </p>\n<h2 id=\"sudo\"><a href=\"#sudo\" class=\"headerlink\" title=\"sudo\"></a>sudo</h2><p>以管理员身份运行命令<br>sudo 命令  </p>\n<h1 id=\"vim\"><a href=\"#vim\" class=\"headerlink\" title=\"vim\"></a>vim</h1><p>输入命令vimtutor自行学习  </p>\n<h1 id=\"Gcc和G\"><a href=\"#Gcc和G\" class=\"headerlink\" title=\"Gcc和G++\"></a>Gcc和G++</h1><h2 id=\"编译和运行\"><a href=\"#编译和运行\" class=\"headerlink\" title=\"编译和运行\"></a>编译和运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc/g++ -c 源代码文件名             //编译</span><br><span class=\"line\">gcc/g++ -o 可执行文件名  源代码文件     //生成可执行文件  </span><br><span class=\"line\">./可执行文件名      //执行文件</span><br></pre></td></tr></table></figure>"},{"title":"我的第一篇博客","date":"2019-05-06T06:46:51.000Z","_content":"\n学了点git\n<!--more-->\n\n# Git\n\n# **为什么要使用Git**\n\n![GIT功能](MY_first_Blog\\功能.png)\n\n- 协同修改\n\n- 数据备份\n\n- 版本管理\n\n- 权限管理\n\n- 历史纪录 \n\n- 分支管理\n\n# Git提交代码五步曲\n\n1. 初始化本地库  \n`git init`\n2. 设置签名  \n\n```\n//系统用户级别\ngit config --global user.name 名称\ngit config --global user.email 邮箱  \n//项目级别\ngit config user.name 名称\ngit config user.email 邮箱 \n \n```\n\n3. 添加文件到暂存区\n```\ngit add 文件名      //提交单个文件\ngit add -A         //提交所有文件\n```\n4. 提交到本地库  \n`git commit -m 描述`\n5. 上传到远程仓库  \n`git push`\n\n# 对读者的话  \nGit是一个很好的代码托管中心，可以把你的代码放到服务器存放，还可以进行版本控制;大家有兴趣可\n以去自行找视频学习。\n\n\n\n\n\n\n","source":"_posts/MY_first_Blog.md","raw":"---\ntitle: 我的第一篇博客\ndate: 2019-05-06 14:46:51\ntags:\n---\n\n学了点git\n<!--more-->\n\n# Git\n\n# **为什么要使用Git**\n\n![GIT功能](MY_first_Blog\\功能.png)\n\n- 协同修改\n\n- 数据备份\n\n- 版本管理\n\n- 权限管理\n\n- 历史纪录 \n\n- 分支管理\n\n# Git提交代码五步曲\n\n1. 初始化本地库  \n`git init`\n2. 设置签名  \n\n```\n//系统用户级别\ngit config --global user.name 名称\ngit config --global user.email 邮箱  \n//项目级别\ngit config user.name 名称\ngit config user.email 邮箱 \n \n```\n\n3. 添加文件到暂存区\n```\ngit add 文件名      //提交单个文件\ngit add -A         //提交所有文件\n```\n4. 提交到本地库  \n`git commit -m 描述`\n5. 上传到远程仓库  \n`git push`\n\n# 对读者的话  \nGit是一个很好的代码托管中心，可以把你的代码放到服务器存放，还可以进行版本控制;大家有兴趣可\n以去自行找视频学习。\n\n\n\n\n\n\n","slug":"MY_first_Blog","published":1,"updated":"2019-10-26T14:46:34.460Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpty000l7qsg05xc2lj7","content":"<p>学了点git<br><a id=\"more\"></a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h1 id=\"为什么要使用Git\"><a href=\"#为什么要使用Git\" class=\"headerlink\" title=\"为什么要使用Git\"></a><strong>为什么要使用Git</strong></h1><p><img src=\"/2019/05/06/MY_first_Blog/功能.png\" alt=\"GIT功能\"></p>\n<ul>\n<li><p>协同修改</p>\n</li>\n<li><p>数据备份</p>\n</li>\n<li><p>版本管理</p>\n</li>\n<li><p>权限管理</p>\n</li>\n<li><p>历史纪录 </p>\n</li>\n<li><p>分支管理</p>\n</li>\n</ul>\n<h1 id=\"Git提交代码五步曲\"><a href=\"#Git提交代码五步曲\" class=\"headerlink\" title=\"Git提交代码五步曲\"></a>Git提交代码五步曲</h1><ol>\n<li>初始化本地库<br><code>git init</code></li>\n<li>设置签名  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//系统用户级别</span><br><span class=\"line\">git config --global user.name 名称</span><br><span class=\"line\">git config --global user.email 邮箱  </span><br><span class=\"line\">//项目级别</span><br><span class=\"line\">git config user.name 名称</span><br><span class=\"line\">git config user.email 邮箱</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>添加文件到暂存区</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add 文件名      //提交单个文件</span><br><span class=\"line\">git add -A         //提交所有文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提交到本地库<br><code>git commit -m 描述</code></p>\n</li>\n<li>上传到远程仓库<br><code>git push</code></li>\n</ol>\n<h1 id=\"对读者的话\"><a href=\"#对读者的话\" class=\"headerlink\" title=\"对读者的话\"></a>对读者的话</h1><p>Git是一个很好的代码托管中心，可以把你的代码放到服务器存放，还可以进行版本控制;大家有兴趣可<br>以去自行找视频学习。</p>\n","site":{"data":{}},"excerpt":"<p>学了点git<br></p>","more":"<p></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h1 id=\"为什么要使用Git\"><a href=\"#为什么要使用Git\" class=\"headerlink\" title=\"为什么要使用Git\"></a><strong>为什么要使用Git</strong></h1><p><img src=\"/2019/05/06/MY_first_Blog/功能.png\" alt=\"GIT功能\"></p>\n<ul>\n<li><p>协同修改</p>\n</li>\n<li><p>数据备份</p>\n</li>\n<li><p>版本管理</p>\n</li>\n<li><p>权限管理</p>\n</li>\n<li><p>历史纪录 </p>\n</li>\n<li><p>分支管理</p>\n</li>\n</ul>\n<h1 id=\"Git提交代码五步曲\"><a href=\"#Git提交代码五步曲\" class=\"headerlink\" title=\"Git提交代码五步曲\"></a>Git提交代码五步曲</h1><ol>\n<li>初始化本地库<br><code>git init</code></li>\n<li>设置签名  </li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//系统用户级别</span><br><span class=\"line\">git config --global user.name 名称</span><br><span class=\"line\">git config --global user.email 邮箱  </span><br><span class=\"line\">//项目级别</span><br><span class=\"line\">git config user.name 名称</span><br><span class=\"line\">git config user.email 邮箱</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li><p>添加文件到暂存区</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git add 文件名      //提交单个文件</span><br><span class=\"line\">git add -A         //提交所有文件</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>提交到本地库<br><code>git commit -m 描述</code></p>\n</li>\n<li>上传到远程仓库<br><code>git push</code></li>\n</ol>\n<h1 id=\"对读者的话\"><a href=\"#对读者的话\" class=\"headerlink\" title=\"对读者的话\"></a>对读者的话</h1><p>Git是一个很好的代码托管中心，可以把你的代码放到服务器存放，还可以进行版本控制;大家有兴趣可<br>以去自行找视频学习。</p>"},{"title":"My_Computer","date":"2019-10-26T15:07:00.000Z","_content":"写给没记性又爱折腾的自己\n\n<!--more-->\n\n## 电脑环境\nmanjaro i3\n\n## 安装步骤  \n1. 下载镜像文件\n2. 制作启动盘  \n3. 完成安装程序\n\n### 安装完之后需要做的事  \n\n1. 配置pacman的软件源  \n修改/etc/pacma.conf文件添加源，详情百度  \npacman-mirrors China  //自动设置中国镜像源  \n\n2. 中文字体  \n    sudo pacman -S wqy-     //可以安装文泉译所有字体\n    将本地语言改为中文，修改/etc/locale.gen，找到zh.CN.China.utf-8,去掉注释，然后locale-gen,如果还不行的话就修改locale.conf文件，具体百度。  \n\n3. 输入法  \n    pacman -S fcitx fcitx-qt5 fcitx-sogoupinyin       //这里我使用fcitx的搜狗\n\n\n4. 浏览器  \n    pacman -S google-chrome  \n    可以直接使用我配置里的google扩展插件进行离线安装，就可以访问谷歌的一些服务  \n    这下我就可以在终端下输入中文字体，也可以欢快的百度了，搞定了这一步就完成了大部分。\n\n5. 现在需要生成一个密钥以便git下载文件  \n    - 在家目录下生成一个.ssh文件  \n    - 然后使用`ssh-keygen -t rsa -C \"你的邮箱\"`生成公钥\n    - 在git上添加密钥\n\n6. 从github下把我的配置文件下载过来\n    - 博客  \n        克隆完之后需要下载hexo等工具使用\n        1. git config --global user.email \"你的邮箱\"\n        2. git config --global user.name \"你的名字\"\n        3. sudo pacman -S nodejs npm\n        4. npm config set registry https://registry.npm.taobao.org\n        5. npm install -g hexo-cli\n        6. npm install hexo-deployer-git --save  \n        在使用hexo d之前检查博客目录下.deployer这个文件，有就删除，不然会报错，然后就可以正常使用了  \n    - 配置文件  \n        克隆下来放到相对应的位置就可以了，具体看情况  \n\n### 常用软件  \n1. 有很多基本的东西你们可以通过[wiki](https://wiki.archlinux.org/index.php/General_recommendations_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 知道\n\n2. 查找程序,还可以装很多小插件，国产崛起  \nyay -S utools\n\n3. 壁纸难以管理，那就用它吧  \nsudo pacman -S variety  \n\n4. 好看的虚拟终端加上半透明效果  \nsudo pacman -S alacritty compton\n\n5. 你需要一个梯子！\nsudo pacman -S electron-ssr  \n下载好就从剪贴板导入ssr，开启就好了，export https_proxy=127.0.0.1:12333这个是https的其他的同理，改下端口号就行了\n\n6. 一个好的外国聊天软件，当然也有国内的\nsudo pacman -S telegram-desktop  \n进入之后设置自定义代理，登录搜索zh就会出来中文包，下载更换即可实现中文。\n\n7. 不嗨歌是没有灵魂的！完美的网易云音乐  \nsudo pacman -S netease-cloud-music  \nyay -S qcef\n顺带提一下，可以修改opt/netease/netease-cloud-music下的netease-cloud-music.bash,在exec上面加上一行内容即可：export XDG_CURRENT_DESKTOP=DDE\n\n### 系统功能设置\n1. 触摸板驱动  \n查看Archwiki吧，搜索触摸板就可以了\n\n2. 蓝牙  \n蓝牙工具可以使用两个工具，blueman和blueberry\n两者选一即可，如果单纯相连蓝牙耳机比如我，那就用blueberry吧\n\n3. 笔记本盖上不休屏  \n将/etc/systemd/logind.conf中的语句改成`HandleLidSwitch=lock`  \n\n4. 音量调节  \n推荐pulseaudio-ctl这个包，man一下就会用了，非常简单  \nsudo pamcan -S pulseaudio-ctl  \n\n5. 亮度调节  \n一般来说，i3不能直接调亮度，笔记本热键可能也没用，对于intel显卡来说，可以用这个包来调节  \nsudo pacman -S xorg-xbacklight  \n用法非常简单，使用man xbacklight就可以知道了  \n还有一种是在状态栏调节，使用xfce4-power-manager打开电源管理，显示系统托盘就可以使用啦，如果没有的话，那你查查wiki怎么下吧！\n\n\n### 扩展  \n1. man的中文帮助手册  \n在arch下一条命令解决  \npacman -S man-pages-zh_cn man-pages-zh_tw\n另外其他系统参考[这里](https://www.jianshu.com/p/36b811403a6e)\n\n2. vim中文帮助  \ngit clone https://github.com/178me/My_Arch.git  \n只需要把doc文件夹放进。~/.vim就可以了，其他就可以删除\n\n3. 修改键位  \n这里提到一下防止忘记，使用xmodmap命令修改。详情百度  \n\n4. 添加网络模块的支持, 请看 Network Manager.要在 Network manager 里面保存 Wifi 密码，需要安装 GNOME Keyring。\n\n5. 笔记本的一些硬件支持详情 [包括指纹等资料](https://wiki.archlinux.org/index.php/Laptop_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n\n6. 修改默认编辑器  \necho export EDITOR=/usr/bin/vim >> ~/.bashrc\n\n7. 修改键盘布局  \nsetxkbmap us\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/My-Computer.md","raw":"---\ntitle: My_Computer\ndate: 2019-10-26 23:07:00\ntags:\ncategories:\n---\n写给没记性又爱折腾的自己\n\n<!--more-->\n\n## 电脑环境\nmanjaro i3\n\n## 安装步骤  \n1. 下载镜像文件\n2. 制作启动盘  \n3. 完成安装程序\n\n### 安装完之后需要做的事  \n\n1. 配置pacman的软件源  \n修改/etc/pacma.conf文件添加源，详情百度  \npacman-mirrors China  //自动设置中国镜像源  \n\n2. 中文字体  \n    sudo pacman -S wqy-     //可以安装文泉译所有字体\n    将本地语言改为中文，修改/etc/locale.gen，找到zh.CN.China.utf-8,去掉注释，然后locale-gen,如果还不行的话就修改locale.conf文件，具体百度。  \n\n3. 输入法  \n    pacman -S fcitx fcitx-qt5 fcitx-sogoupinyin       //这里我使用fcitx的搜狗\n\n\n4. 浏览器  \n    pacman -S google-chrome  \n    可以直接使用我配置里的google扩展插件进行离线安装，就可以访问谷歌的一些服务  \n    这下我就可以在终端下输入中文字体，也可以欢快的百度了，搞定了这一步就完成了大部分。\n\n5. 现在需要生成一个密钥以便git下载文件  \n    - 在家目录下生成一个.ssh文件  \n    - 然后使用`ssh-keygen -t rsa -C \"你的邮箱\"`生成公钥\n    - 在git上添加密钥\n\n6. 从github下把我的配置文件下载过来\n    - 博客  \n        克隆完之后需要下载hexo等工具使用\n        1. git config --global user.email \"你的邮箱\"\n        2. git config --global user.name \"你的名字\"\n        3. sudo pacman -S nodejs npm\n        4. npm config set registry https://registry.npm.taobao.org\n        5. npm install -g hexo-cli\n        6. npm install hexo-deployer-git --save  \n        在使用hexo d之前检查博客目录下.deployer这个文件，有就删除，不然会报错，然后就可以正常使用了  \n    - 配置文件  \n        克隆下来放到相对应的位置就可以了，具体看情况  \n\n### 常用软件  \n1. 有很多基本的东西你们可以通过[wiki](https://wiki.archlinux.org/index.php/General_recommendations_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87) 知道\n\n2. 查找程序,还可以装很多小插件，国产崛起  \nyay -S utools\n\n3. 壁纸难以管理，那就用它吧  \nsudo pacman -S variety  \n\n4. 好看的虚拟终端加上半透明效果  \nsudo pacman -S alacritty compton\n\n5. 你需要一个梯子！\nsudo pacman -S electron-ssr  \n下载好就从剪贴板导入ssr，开启就好了，export https_proxy=127.0.0.1:12333这个是https的其他的同理，改下端口号就行了\n\n6. 一个好的外国聊天软件，当然也有国内的\nsudo pacman -S telegram-desktop  \n进入之后设置自定义代理，登录搜索zh就会出来中文包，下载更换即可实现中文。\n\n7. 不嗨歌是没有灵魂的！完美的网易云音乐  \nsudo pacman -S netease-cloud-music  \nyay -S qcef\n顺带提一下，可以修改opt/netease/netease-cloud-music下的netease-cloud-music.bash,在exec上面加上一行内容即可：export XDG_CURRENT_DESKTOP=DDE\n\n### 系统功能设置\n1. 触摸板驱动  \n查看Archwiki吧，搜索触摸板就可以了\n\n2. 蓝牙  \n蓝牙工具可以使用两个工具，blueman和blueberry\n两者选一即可，如果单纯相连蓝牙耳机比如我，那就用blueberry吧\n\n3. 笔记本盖上不休屏  \n将/etc/systemd/logind.conf中的语句改成`HandleLidSwitch=lock`  \n\n4. 音量调节  \n推荐pulseaudio-ctl这个包，man一下就会用了，非常简单  \nsudo pamcan -S pulseaudio-ctl  \n\n5. 亮度调节  \n一般来说，i3不能直接调亮度，笔记本热键可能也没用，对于intel显卡来说，可以用这个包来调节  \nsudo pacman -S xorg-xbacklight  \n用法非常简单，使用man xbacklight就可以知道了  \n还有一种是在状态栏调节，使用xfce4-power-manager打开电源管理，显示系统托盘就可以使用啦，如果没有的话，那你查查wiki怎么下吧！\n\n\n### 扩展  \n1. man的中文帮助手册  \n在arch下一条命令解决  \npacman -S man-pages-zh_cn man-pages-zh_tw\n另外其他系统参考[这里](https://www.jianshu.com/p/36b811403a6e)\n\n2. vim中文帮助  \ngit clone https://github.com/178me/My_Arch.git  \n只需要把doc文件夹放进。~/.vim就可以了，其他就可以删除\n\n3. 修改键位  \n这里提到一下防止忘记，使用xmodmap命令修改。详情百度  \n\n4. 添加网络模块的支持, 请看 Network Manager.要在 Network manager 里面保存 Wifi 密码，需要安装 GNOME Keyring。\n\n5. 笔记本的一些硬件支持详情 [包括指纹等资料](https://wiki.archlinux.org/index.php/Laptop_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))\n\n6. 修改默认编辑器  \necho export EDITOR=/usr/bin/vim >> ~/.bashrc\n\n7. 修改键盘布局  \nsetxkbmap us\n\n\n\n\n\n\n\n\n\n\n","slug":"My-Computer","published":1,"updated":"2019-10-28T09:25:41.533Z","_id":"ck29akpu0000p7qsgqva0op6d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>写给没记性又爱折腾的自己</p>\n<a id=\"more\"></a>\n<h2 id=\"电脑环境\"><a href=\"#电脑环境\" class=\"headerlink\" title=\"电脑环境\"></a>电脑环境</h2><p>manjaro i3</p>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><ol>\n<li>下载镜像文件</li>\n<li>制作启动盘  </li>\n<li>完成安装程序</li>\n</ol>\n<h3 id=\"安装完之后需要做的事\"><a href=\"#安装完之后需要做的事\" class=\"headerlink\" title=\"安装完之后需要做的事\"></a>安装完之后需要做的事</h3><ol>\n<li><p>配置pacman的软件源<br>修改/etc/pacma.conf文件添加源，详情百度<br>pacman-mirrors China  //自动设置中国镜像源  </p>\n</li>\n<li><p>中文字体<br> sudo pacman -S wqy-     //可以安装文泉译所有字体<br> 将本地语言改为中文，修改/etc/locale.gen，找到zh.CN.China.utf-8,去掉注释，然后locale-gen,如果还不行的话就修改locale.conf文件，具体百度。  </p>\n</li>\n<li><p>输入法<br> pacman -S fcitx fcitx-qt5 fcitx-sogoupinyin       //这里我使用fcitx的搜狗</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>浏览器<br> pacman -S google-chrome<br> 可以直接使用我配置里的google扩展插件进行离线安装，就可以访问谷歌的一些服务<br> 这下我就可以在终端下输入中文字体，也可以欢快的百度了，搞定了这一步就完成了大部分。</p>\n</li>\n<li><p>现在需要生成一个密钥以便git下载文件  </p>\n<ul>\n<li>在家目录下生成一个.ssh文件  </li>\n<li>然后使用<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>生成公钥</li>\n<li>在git上添加密钥</li>\n</ul>\n</li>\n<li><p>从github下把我的配置文件下载过来</p>\n<ul>\n<li>博客<br>  克隆完之后需要下载hexo等工具使用<ol>\n<li>git config –global user.email “你的邮箱”</li>\n<li>git config –global user.name “你的名字”</li>\n<li>sudo pacman -S nodejs npm</li>\n<li>npm config set registry <a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm install -g hexo-cli</li>\n<li>npm install hexo-deployer-git –save<br>在使用hexo d之前检查博客目录下.deployer这个文件，有就删除，不然会报错，然后就可以正常使用了  </li>\n</ol>\n</li>\n<li>配置文件<br>  克隆下来放到相对应的位置就可以了，具体看情况  </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"常用软件\"><a href=\"#常用软件\" class=\"headerlink\" title=\"常用软件\"></a>常用软件</h3><ol>\n<li><p>有很多基本的东西你们可以通过<a href=\"https://wiki.archlinux.org/index.php/General_recommendations_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">wiki</a> 知道</p>\n</li>\n<li><p>查找程序,还可以装很多小插件，国产崛起<br>yay -S utools</p>\n</li>\n<li><p>壁纸难以管理，那就用它吧<br>sudo pacman -S variety  </p>\n</li>\n<li><p>好看的虚拟终端加上半透明效果<br>sudo pacman -S alacritty compton</p>\n</li>\n<li><p>你需要一个梯子！<br>sudo pacman -S electron-ssr<br>下载好就从剪贴板导入ssr，开启就好了，export https_proxy=127.0.0.1:12333这个是https的其他的同理，改下端口号就行了</p>\n</li>\n<li><p>一个好的外国聊天软件，当然也有国内的<br>sudo pacman -S telegram-desktop<br>进入之后设置自定义代理，登录搜索zh就会出来中文包，下载更换即可实现中文。</p>\n</li>\n<li><p>不嗨歌是没有灵魂的！完美的网易云音乐<br>sudo pacman -S netease-cloud-music<br>yay -S qcef<br>顺带提一下，可以修改opt/netease/netease-cloud-music下的netease-cloud-music.bash,在exec上面加上一行内容即可：export XDG_CURRENT_DESKTOP=DDE</p>\n</li>\n</ol>\n<h3 id=\"系统功能设置\"><a href=\"#系统功能设置\" class=\"headerlink\" title=\"系统功能设置\"></a>系统功能设置</h3><ol>\n<li><p>触摸板驱动<br>查看Archwiki吧，搜索触摸板就可以了</p>\n</li>\n<li><p>蓝牙<br>蓝牙工具可以使用两个工具，blueman和blueberry<br>两者选一即可，如果单纯相连蓝牙耳机比如我，那就用blueberry吧</p>\n</li>\n<li><p>笔记本盖上不休屏<br>将/etc/systemd/logind.conf中的语句改成<code>HandleLidSwitch=lock</code>  </p>\n</li>\n<li><p>音量调节<br>推荐pulseaudio-ctl这个包，man一下就会用了，非常简单<br>sudo pamcan -S pulseaudio-ctl  </p>\n</li>\n<li><p>亮度调节<br>一般来说，i3不能直接调亮度，笔记本热键可能也没用，对于intel显卡来说，可以用这个包来调节<br>sudo pacman -S xorg-xbacklight<br>用法非常简单，使用man xbacklight就可以知道了<br>还有一种是在状态栏调节，使用xfce4-power-manager打开电源管理，显示系统托盘就可以使用啦，如果没有的话，那你查查wiki怎么下吧！</p>\n</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><ol>\n<li><p>man的中文帮助手册<br>在arch下一条命令解决<br>pacman -S man-pages-zh_cn man-pages-zh_tw<br>另外其他系统参考<a href=\"https://www.jianshu.com/p/36b811403a6e\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n<li><p>vim中文帮助<br>git clone <a href=\"https://github.com/178me/My_Arch.git\" target=\"_blank\" rel=\"noopener\">https://github.com/178me/My_Arch.git</a><br>只需要把doc文件夹放进。~/.vim就可以了，其他就可以删除</p>\n</li>\n<li><p>修改键位<br>这里提到一下防止忘记，使用xmodmap命令修改。详情百度  </p>\n</li>\n<li><p>添加网络模块的支持, 请看 Network Manager.要在 Network manager 里面保存 Wifi 密码，需要安装 GNOME Keyring。</p>\n</li>\n<li><p>笔记本的一些硬件支持详情 <a href=\"https://wiki.archlinux.org/index.php/Laptop_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">包括指纹等资料</a>)</p>\n</li>\n<li><p>修改默认编辑器<br>echo export EDITOR=/usr/bin/vim &gt;&gt; ~/.bashrc</p>\n</li>\n<li><p>修改键盘布局<br>setxkbmap us</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>写给没记性又爱折腾的自己</p>","more":"<h2 id=\"电脑环境\"><a href=\"#电脑环境\" class=\"headerlink\" title=\"电脑环境\"></a>电脑环境</h2><p>manjaro i3</p>\n<h2 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h2><ol>\n<li>下载镜像文件</li>\n<li>制作启动盘  </li>\n<li>完成安装程序</li>\n</ol>\n<h3 id=\"安装完之后需要做的事\"><a href=\"#安装完之后需要做的事\" class=\"headerlink\" title=\"安装完之后需要做的事\"></a>安装完之后需要做的事</h3><ol>\n<li><p>配置pacman的软件源<br>修改/etc/pacma.conf文件添加源，详情百度<br>pacman-mirrors China  //自动设置中国镜像源  </p>\n</li>\n<li><p>中文字体<br> sudo pacman -S wqy-     //可以安装文泉译所有字体<br> 将本地语言改为中文，修改/etc/locale.gen，找到zh.CN.China.utf-8,去掉注释，然后locale-gen,如果还不行的话就修改locale.conf文件，具体百度。  </p>\n</li>\n<li><p>输入法<br> pacman -S fcitx fcitx-qt5 fcitx-sogoupinyin       //这里我使用fcitx的搜狗</p>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>浏览器<br> pacman -S google-chrome<br> 可以直接使用我配置里的google扩展插件进行离线安装，就可以访问谷歌的一些服务<br> 这下我就可以在终端下输入中文字体，也可以欢快的百度了，搞定了这一步就完成了大部分。</p>\n</li>\n<li><p>现在需要生成一个密钥以便git下载文件  </p>\n<ul>\n<li>在家目录下生成一个.ssh文件  </li>\n<li>然后使用<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code>生成公钥</li>\n<li>在git上添加密钥</li>\n</ul>\n</li>\n<li><p>从github下把我的配置文件下载过来</p>\n<ul>\n<li>博客<br>  克隆完之后需要下载hexo等工具使用<ol>\n<li>git config –global user.email “你的邮箱”</li>\n<li>git config –global user.name “你的名字”</li>\n<li>sudo pacman -S nodejs npm</li>\n<li>npm config set registry <a href=\"https://registry.npm.taobao.org\" target=\"_blank\" rel=\"noopener\">https://registry.npm.taobao.org</a></li>\n<li>npm install -g hexo-cli</li>\n<li>npm install hexo-deployer-git –save<br>在使用hexo d之前检查博客目录下.deployer这个文件，有就删除，不然会报错，然后就可以正常使用了  </li>\n</ol>\n</li>\n<li>配置文件<br>  克隆下来放到相对应的位置就可以了，具体看情况  </li>\n</ul>\n</li>\n</ol>\n<h3 id=\"常用软件\"><a href=\"#常用软件\" class=\"headerlink\" title=\"常用软件\"></a>常用软件</h3><ol>\n<li><p>有很多基本的东西你们可以通过<a href=\"https://wiki.archlinux.org/index.php/General_recommendations_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">wiki</a> 知道</p>\n</li>\n<li><p>查找程序,还可以装很多小插件，国产崛起<br>yay -S utools</p>\n</li>\n<li><p>壁纸难以管理，那就用它吧<br>sudo pacman -S variety  </p>\n</li>\n<li><p>好看的虚拟终端加上半透明效果<br>sudo pacman -S alacritty compton</p>\n</li>\n<li><p>你需要一个梯子！<br>sudo pacman -S electron-ssr<br>下载好就从剪贴板导入ssr，开启就好了，export https_proxy=127.0.0.1:12333这个是https的其他的同理，改下端口号就行了</p>\n</li>\n<li><p>一个好的外国聊天软件，当然也有国内的<br>sudo pacman -S telegram-desktop<br>进入之后设置自定义代理，登录搜索zh就会出来中文包，下载更换即可实现中文。</p>\n</li>\n<li><p>不嗨歌是没有灵魂的！完美的网易云音乐<br>sudo pacman -S netease-cloud-music<br>yay -S qcef<br>顺带提一下，可以修改opt/netease/netease-cloud-music下的netease-cloud-music.bash,在exec上面加上一行内容即可：export XDG_CURRENT_DESKTOP=DDE</p>\n</li>\n</ol>\n<h3 id=\"系统功能设置\"><a href=\"#系统功能设置\" class=\"headerlink\" title=\"系统功能设置\"></a>系统功能设置</h3><ol>\n<li><p>触摸板驱动<br>查看Archwiki吧，搜索触摸板就可以了</p>\n</li>\n<li><p>蓝牙<br>蓝牙工具可以使用两个工具，blueman和blueberry<br>两者选一即可，如果单纯相连蓝牙耳机比如我，那就用blueberry吧</p>\n</li>\n<li><p>笔记本盖上不休屏<br>将/etc/systemd/logind.conf中的语句改成<code>HandleLidSwitch=lock</code>  </p>\n</li>\n<li><p>音量调节<br>推荐pulseaudio-ctl这个包，man一下就会用了，非常简单<br>sudo pamcan -S pulseaudio-ctl  </p>\n</li>\n<li><p>亮度调节<br>一般来说，i3不能直接调亮度，笔记本热键可能也没用，对于intel显卡来说，可以用这个包来调节<br>sudo pacman -S xorg-xbacklight<br>用法非常简单，使用man xbacklight就可以知道了<br>还有一种是在状态栏调节，使用xfce4-power-manager打开电源管理，显示系统托盘就可以使用啦，如果没有的话，那你查查wiki怎么下吧！</p>\n</li>\n</ol>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><ol>\n<li><p>man的中文帮助手册<br>在arch下一条命令解决<br>pacman -S man-pages-zh_cn man-pages-zh_tw<br>另外其他系统参考<a href=\"https://www.jianshu.com/p/36b811403a6e\" target=\"_blank\" rel=\"noopener\">这里</a></p>\n</li>\n<li><p>vim中文帮助<br>git clone <a href=\"https://github.com/178me/My_Arch.git\" target=\"_blank\" rel=\"noopener\">https://github.com/178me/My_Arch.git</a><br>只需要把doc文件夹放进。~/.vim就可以了，其他就可以删除</p>\n</li>\n<li><p>修改键位<br>这里提到一下防止忘记，使用xmodmap命令修改。详情百度  </p>\n</li>\n<li><p>添加网络模块的支持, 请看 Network Manager.要在 Network manager 里面保存 Wifi 密码，需要安装 GNOME Keyring。</p>\n</li>\n<li><p>笔记本的一些硬件支持详情 <a href=\"https://wiki.archlinux.org/index.php/Laptop_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\" target=\"_blank\" rel=\"noopener\">包括指纹等资料</a>)</p>\n</li>\n<li><p>修改默认编辑器<br>echo export EDITOR=/usr/bin/vim &gt;&gt; ~/.bashrc</p>\n</li>\n<li><p>修改键盘布局<br>setxkbmap us</p>\n</li>\n</ol>"},{"title":"《ctime》的常用函数","date":"2019-07-23T12:11:36.000Z","_content":"在写小程序时接触到的一个C标准函数库\n<!--more-->\n\n# 简介\n\n表示时间的数据类型\n\n![常用函数简介](ctime-的常用函数/Ctime.png)\n\n# tm 结构  \n\n```\n//需要包含<ctime>头文件\nstruct tm{\n    int tm_sec;     //秒\n    int tm_min;     //分\n    int tm_hour;    //时\n    int tm_mday;    //每个月的第几天\n    int tm_mon;     //月份\n    int tm_year;    //1900年到现在的年份\n    int tm_wday;    //表示星期几，周日开始\n    int tm_yday;    //一年中的第几天\n    int tm_isdst;   //夏令时标识\n};\n\n```\n\n# time_t  \n\n实质上就是long数据类型的别名，另外clock_t也是一样。\n\n# time  \n\n得到从1970年1月1日 0：00到现在的秒数\n\n函数原型: time_t time(time_t *timer)\n\n# asctime() \n\n将tm结构的日期时间返回成一个字符串。字符串格式：星期,月,日,小时：分：秒,年\n\n函数原型: char* asctime(struct tm * ptr)  \n\n# ctime  \n\n将time_t类型时间戳返回成一个字符串。格式与上面相同\n\n函数原型: char *ctime(const time_t *time)\n\n# strftime()  \n\n将tm结构转换为自定义格式的字符串。\n\n![时间格式转换符](ctime-的常用函数/time格式符.png)\n\n函数原型：size_t strftime(char* s, size_t n, const char* format, const struct tm* tptr)\n\n# localtime()  \n\n用本地时区来表示时间  \n\n函数原型：struct tm* localtime(const time_t* timer)\n\n# gmtime()  \n\n标准的UTC时间，也就是世界时钟  \n\n函数原型：struct tm* gmtime(const time_t* timer)  \n\n# mktime()  \n\n将tm结构转换为time_t类型  \n\n函数原型：time_t mktime(struct tm* ptm)  \n\n\n\n","source":"_posts/ctime-的常用函数.md","raw":"---\ntitle: 《ctime》的常用函数\ndate: 2019-07-23 20:11:36\ntags: note \ncategories: C++\n---\n在写小程序时接触到的一个C标准函数库\n<!--more-->\n\n# 简介\n\n表示时间的数据类型\n\n![常用函数简介](ctime-的常用函数/Ctime.png)\n\n# tm 结构  \n\n```\n//需要包含<ctime>头文件\nstruct tm{\n    int tm_sec;     //秒\n    int tm_min;     //分\n    int tm_hour;    //时\n    int tm_mday;    //每个月的第几天\n    int tm_mon;     //月份\n    int tm_year;    //1900年到现在的年份\n    int tm_wday;    //表示星期几，周日开始\n    int tm_yday;    //一年中的第几天\n    int tm_isdst;   //夏令时标识\n};\n\n```\n\n# time_t  \n\n实质上就是long数据类型的别名，另外clock_t也是一样。\n\n# time  \n\n得到从1970年1月1日 0：00到现在的秒数\n\n函数原型: time_t time(time_t *timer)\n\n# asctime() \n\n将tm结构的日期时间返回成一个字符串。字符串格式：星期,月,日,小时：分：秒,年\n\n函数原型: char* asctime(struct tm * ptr)  \n\n# ctime  \n\n将time_t类型时间戳返回成一个字符串。格式与上面相同\n\n函数原型: char *ctime(const time_t *time)\n\n# strftime()  \n\n将tm结构转换为自定义格式的字符串。\n\n![时间格式转换符](ctime-的常用函数/time格式符.png)\n\n函数原型：size_t strftime(char* s, size_t n, const char* format, const struct tm* tptr)\n\n# localtime()  \n\n用本地时区来表示时间  \n\n函数原型：struct tm* localtime(const time_t* timer)\n\n# gmtime()  \n\n标准的UTC时间，也就是世界时钟  \n\n函数原型：struct tm* gmtime(const time_t* timer)  \n\n# mktime()  \n\n将tm结构转换为time_t类型  \n\n函数原型：time_t mktime(struct tm* ptm)  \n\n\n\n","slug":"ctime-的常用函数","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpu2000r7qsgblfp2pnh","content":"<p>在写小程序时接触到的一个C标准函数库<br><a id=\"more\"></a></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>表示时间的数据类型</p>\n<p><img src=\"/2019/07/23/ctime-的常用函数/Ctime.png\" alt=\"常用函数简介\"></p>\n<h1 id=\"tm-结构\"><a href=\"#tm-结构\" class=\"headerlink\" title=\"tm 结构\"></a>tm 结构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//需要包含&lt;ctime&gt;头文件</span><br><span class=\"line\">struct tm&#123;</span><br><span class=\"line\">    int tm_sec;     //秒</span><br><span class=\"line\">    int tm_min;     //分</span><br><span class=\"line\">    int tm_hour;    //时</span><br><span class=\"line\">    int tm_mday;    //每个月的第几天</span><br><span class=\"line\">    int tm_mon;     //月份</span><br><span class=\"line\">    int tm_year;    //1900年到现在的年份</span><br><span class=\"line\">    int tm_wday;    //表示星期几，周日开始</span><br><span class=\"line\">    int tm_yday;    //一年中的第几天</span><br><span class=\"line\">    int tm_isdst;   //夏令时标识</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"time-t\"><a href=\"#time-t\" class=\"headerlink\" title=\"time_t\"></a>time_t</h1><p>实质上就是long数据类型的别名，另外clock_t也是一样。</p>\n<h1 id=\"time\"><a href=\"#time\" class=\"headerlink\" title=\"time\"></a>time</h1><p>得到从1970年1月1日 0：00到现在的秒数</p>\n<p>函数原型: time_t time(time_t *timer)</p>\n<h1 id=\"asctime\"><a href=\"#asctime\" class=\"headerlink\" title=\"asctime()\"></a>asctime()</h1><p>将tm结构的日期时间返回成一个字符串。字符串格式：星期,月,日,小时：分：秒,年</p>\n<p>函数原型: char<em> asctime(struct tm </em> ptr)  </p>\n<h1 id=\"ctime\"><a href=\"#ctime\" class=\"headerlink\" title=\"ctime\"></a>ctime</h1><p>将time_t类型时间戳返回成一个字符串。格式与上面相同</p>\n<p>函数原型: char <em>ctime(const time_t </em>time)</p>\n<h1 id=\"strftime\"><a href=\"#strftime\" class=\"headerlink\" title=\"strftime()\"></a>strftime()</h1><p>将tm结构转换为自定义格式的字符串。</p>\n<p><img src=\"/2019/07/23/ctime-的常用函数/time格式符.png\" alt=\"时间格式转换符\"></p>\n<p>函数原型：size_t strftime(char<em> s, size_t n, const char</em> format, const struct tm* tptr)</p>\n<h1 id=\"localtime\"><a href=\"#localtime\" class=\"headerlink\" title=\"localtime()\"></a>localtime()</h1><p>用本地时区来表示时间  </p>\n<p>函数原型：struct tm<em> localtime(const time_t</em> timer)</p>\n<h1 id=\"gmtime\"><a href=\"#gmtime\" class=\"headerlink\" title=\"gmtime()\"></a>gmtime()</h1><p>标准的UTC时间，也就是世界时钟  </p>\n<p>函数原型：struct tm<em> gmtime(const time_t</em> timer)  </p>\n<h1 id=\"mktime\"><a href=\"#mktime\" class=\"headerlink\" title=\"mktime()\"></a>mktime()</h1><p>将tm结构转换为time_t类型  </p>\n<p>函数原型：time_t mktime(struct tm* ptm)  </p>\n","site":{"data":{}},"excerpt":"<p>在写小程序时接触到的一个C标准函数库<br></p>","more":"<p></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>表示时间的数据类型</p>\n<p><img src=\"/2019/07/23/ctime-的常用函数/Ctime.png\" alt=\"常用函数简介\"></p>\n<h1 id=\"tm-结构\"><a href=\"#tm-结构\" class=\"headerlink\" title=\"tm 结构\"></a>tm 结构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//需要包含&lt;ctime&gt;头文件</span><br><span class=\"line\">struct tm&#123;</span><br><span class=\"line\">    int tm_sec;     //秒</span><br><span class=\"line\">    int tm_min;     //分</span><br><span class=\"line\">    int tm_hour;    //时</span><br><span class=\"line\">    int tm_mday;    //每个月的第几天</span><br><span class=\"line\">    int tm_mon;     //月份</span><br><span class=\"line\">    int tm_year;    //1900年到现在的年份</span><br><span class=\"line\">    int tm_wday;    //表示星期几，周日开始</span><br><span class=\"line\">    int tm_yday;    //一年中的第几天</span><br><span class=\"line\">    int tm_isdst;   //夏令时标识</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h1 id=\"time-t\"><a href=\"#time-t\" class=\"headerlink\" title=\"time_t\"></a>time_t</h1><p>实质上就是long数据类型的别名，另外clock_t也是一样。</p>\n<h1 id=\"time\"><a href=\"#time\" class=\"headerlink\" title=\"time\"></a>time</h1><p>得到从1970年1月1日 0：00到现在的秒数</p>\n<p>函数原型: time_t time(time_t *timer)</p>\n<h1 id=\"asctime\"><a href=\"#asctime\" class=\"headerlink\" title=\"asctime()\"></a>asctime()</h1><p>将tm结构的日期时间返回成一个字符串。字符串格式：星期,月,日,小时：分：秒,年</p>\n<p>函数原型: char<em> asctime(struct tm </em> ptr)  </p>\n<h1 id=\"ctime\"><a href=\"#ctime\" class=\"headerlink\" title=\"ctime\"></a>ctime</h1><p>将time_t类型时间戳返回成一个字符串。格式与上面相同</p>\n<p>函数原型: char <em>ctime(const time_t </em>time)</p>\n<h1 id=\"strftime\"><a href=\"#strftime\" class=\"headerlink\" title=\"strftime()\"></a>strftime()</h1><p>将tm结构转换为自定义格式的字符串。</p>\n<p><img src=\"/2019/07/23/ctime-的常用函数/time格式符.png\" alt=\"时间格式转换符\"></p>\n<p>函数原型：size_t strftime(char<em> s, size_t n, const char</em> format, const struct tm* tptr)</p>\n<h1 id=\"localtime\"><a href=\"#localtime\" class=\"headerlink\" title=\"localtime()\"></a>localtime()</h1><p>用本地时区来表示时间  </p>\n<p>函数原型：struct tm<em> localtime(const time_t</em> timer)</p>\n<h1 id=\"gmtime\"><a href=\"#gmtime\" class=\"headerlink\" title=\"gmtime()\"></a>gmtime()</h1><p>标准的UTC时间，也就是世界时钟  </p>\n<p>函数原型：struct tm<em> gmtime(const time_t</em> timer)  </p>\n<h1 id=\"mktime\"><a href=\"#mktime\" class=\"headerlink\" title=\"mktime()\"></a>mktime()</h1><p>将tm结构转换为time_t类型  </p>\n<p>函数原型：time_t mktime(struct tm* ptm)  </p>"},{"title":"Qt_信号槽_对象树_Lambda","date":"2019-08-03T10:08:16.000Z","_content":"\n专门讲述信号槽、对象树的概念以及使用Lambda表达式\n\n<!--more-->\n\n# 信号与槽  \n\n信号和槽是qt中很重要的一个机制，信号即发送者发送信号，槽即接收者处理信号所做的操作  \n\n这里即引出名词： 发送者、信号、接收者、槽函数  \n\n例如：发送者可以是一个按钮，点击它就是一个信号，这个信号连接着接收者，接受者对信号作出处理\n\n在这里我们用connect方法来连接这些参数即`connect(sender,signal,receiver,method)`;\n\n当遇到函数重载是我们可以使用函数指针来解决问题\n\n我们还可以自定义信号还有槽函数  \n\n自定义信号只需要函数声明即可，不需要具体实现。而槽函数就需要声明并且要有实现的代码。\n\n信号和槽的函数的返回值都是void，但可以重载。\n\n信号的参数个数可以大于槽的参数个数，但是参数要一一对应，也就是对应的参数类型必须要一样，反之则不行。\n\n## 扩展\n\n信号可以连接信号\n\n一个信号连接多个槽函数   槽函数的执行顺序是随机的\n\n槽函数可以使用Lambda表达式\n\n信号连接之后可以用disconnect断开\n\n# 对象树   \n\n在Qt中，存在对象树的概念，他的功能是在一定程度上简化内存的释放。 \n\n在基于QObject的类中或者继承了QObject类的子类，都会自动回收内存。所以说我们new出来的对象指定好父类，他就会自动回收。\n\n例如： 以new的方式创建一个按钮，将它放在Widget的对象中，那么这个按钮他将会在这个Widget释放前自动释放掉。\n\n# Lambda表达式  \n\n在C++11中，Lambda表达式用于定义并创建匿名的函数对象，相当于一个匿名函数。  \n\nLambda表达式声明： [函数对象参数](操作符重载函数参数){函数体}\n\n[]是识别一个lambda表达式的开始。\n\n参数为`空`时，没有调用外面的任何局部变量\n\n参数为`=`时，可以以值传递的方式调用Lambda表达式所在作用域的局部变量\n\n参数为`&`时，可以以引用传递的方式调用Lambda表达式所在作用域的局部变量\n\n参数为`this`时，可以调用Lambda表达式所在类的成员变量\n\n也可以单独取一个或多个变量使用，使用`&`则为引用传递，否则为值传递\n\n()这个是放函数参数的地方，同普通的函数参数一样，不过只能使用值传递和引用传递  \n\n{} 函数体  \n\n返回值类型使用`->类型名`写在函数体的前面，例如：[]()->int{return 1};\n\n可修改标识符mutable 可以修改值传递拷贝出来的变量，改变不了本体 例如: []()mutable{};  \n\n在我这里的学习中，要调用Lambda表达式还需要在函数体后加上() ,例如：[](){}();\n\nLambda表达式的作用就是在连接信号的时候可以代替槽函数的位置。 例如： cconnect(sender,signal,receiver,[](){ //这这里可以写更多的操作，更直观 })\n\n\n\n","source":"_posts/Qt-信号槽-对象树-Lambda.md","raw":"---\ntitle: Qt_信号槽_对象树_Lambda\ndate: 2019-08-03 18:08:16\ntags:\ncategories:\n---\n\n专门讲述信号槽、对象树的概念以及使用Lambda表达式\n\n<!--more-->\n\n# 信号与槽  \n\n信号和槽是qt中很重要的一个机制，信号即发送者发送信号，槽即接收者处理信号所做的操作  \n\n这里即引出名词： 发送者、信号、接收者、槽函数  \n\n例如：发送者可以是一个按钮，点击它就是一个信号，这个信号连接着接收者，接受者对信号作出处理\n\n在这里我们用connect方法来连接这些参数即`connect(sender,signal,receiver,method)`;\n\n当遇到函数重载是我们可以使用函数指针来解决问题\n\n我们还可以自定义信号还有槽函数  \n\n自定义信号只需要函数声明即可，不需要具体实现。而槽函数就需要声明并且要有实现的代码。\n\n信号和槽的函数的返回值都是void，但可以重载。\n\n信号的参数个数可以大于槽的参数个数，但是参数要一一对应，也就是对应的参数类型必须要一样，反之则不行。\n\n## 扩展\n\n信号可以连接信号\n\n一个信号连接多个槽函数   槽函数的执行顺序是随机的\n\n槽函数可以使用Lambda表达式\n\n信号连接之后可以用disconnect断开\n\n# 对象树   \n\n在Qt中，存在对象树的概念，他的功能是在一定程度上简化内存的释放。 \n\n在基于QObject的类中或者继承了QObject类的子类，都会自动回收内存。所以说我们new出来的对象指定好父类，他就会自动回收。\n\n例如： 以new的方式创建一个按钮，将它放在Widget的对象中，那么这个按钮他将会在这个Widget释放前自动释放掉。\n\n# Lambda表达式  \n\n在C++11中，Lambda表达式用于定义并创建匿名的函数对象，相当于一个匿名函数。  \n\nLambda表达式声明： [函数对象参数](操作符重载函数参数){函数体}\n\n[]是识别一个lambda表达式的开始。\n\n参数为`空`时，没有调用外面的任何局部变量\n\n参数为`=`时，可以以值传递的方式调用Lambda表达式所在作用域的局部变量\n\n参数为`&`时，可以以引用传递的方式调用Lambda表达式所在作用域的局部变量\n\n参数为`this`时，可以调用Lambda表达式所在类的成员变量\n\n也可以单独取一个或多个变量使用，使用`&`则为引用传递，否则为值传递\n\n()这个是放函数参数的地方，同普通的函数参数一样，不过只能使用值传递和引用传递  \n\n{} 函数体  \n\n返回值类型使用`->类型名`写在函数体的前面，例如：[]()->int{return 1};\n\n可修改标识符mutable 可以修改值传递拷贝出来的变量，改变不了本体 例如: []()mutable{};  \n\n在我这里的学习中，要调用Lambda表达式还需要在函数体后加上() ,例如：[](){}();\n\nLambda表达式的作用就是在连接信号的时候可以代替槽函数的位置。 例如： cconnect(sender,signal,receiver,[](){ //这这里可以写更多的操作，更直观 })\n\n\n\n","slug":"Qt-信号槽-对象树-Lambda","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpu4000v7qsggdhtxzxv","content":"<p>专门讲述信号槽、对象树的概念以及使用Lambda表达式</p>\n<a id=\"more\"></a>\n<h1 id=\"信号与槽\"><a href=\"#信号与槽\" class=\"headerlink\" title=\"信号与槽\"></a>信号与槽</h1><p>信号和槽是qt中很重要的一个机制，信号即发送者发送信号，槽即接收者处理信号所做的操作  </p>\n<p>这里即引出名词： 发送者、信号、接收者、槽函数  </p>\n<p>例如：发送者可以是一个按钮，点击它就是一个信号，这个信号连接着接收者，接受者对信号作出处理</p>\n<p>在这里我们用connect方法来连接这些参数即<code>connect(sender,signal,receiver,method)</code>;</p>\n<p>当遇到函数重载是我们可以使用函数指针来解决问题</p>\n<p>我们还可以自定义信号还有槽函数  </p>\n<p>自定义信号只需要函数声明即可，不需要具体实现。而槽函数就需要声明并且要有实现的代码。</p>\n<p>信号和槽的函数的返回值都是void，但可以重载。</p>\n<p>信号的参数个数可以大于槽的参数个数，但是参数要一一对应，也就是对应的参数类型必须要一样，反之则不行。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>信号可以连接信号</p>\n<p>一个信号连接多个槽函数   槽函数的执行顺序是随机的</p>\n<p>槽函数可以使用Lambda表达式</p>\n<p>信号连接之后可以用disconnect断开</p>\n<h1 id=\"对象树\"><a href=\"#对象树\" class=\"headerlink\" title=\"对象树\"></a>对象树</h1><p>在Qt中，存在对象树的概念，他的功能是在一定程度上简化内存的释放。 </p>\n<p>在基于QObject的类中或者继承了QObject类的子类，都会自动回收内存。所以说我们new出来的对象指定好父类，他就会自动回收。</p>\n<p>例如： 以new的方式创建一个按钮，将它放在Widget的对象中，那么这个按钮他将会在这个Widget释放前自动释放掉。</p>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p>在C++11中，Lambda表达式用于定义并创建匿名的函数对象，相当于一个匿名函数。  </p>\n<p>Lambda表达式声明： <a href=\"操作符重载函数参数\">函数对象参数</a>{函数体}</p>\n<p>[]是识别一个lambda表达式的开始。</p>\n<p>参数为<code>空</code>时，没有调用外面的任何局部变量</p>\n<p>参数为<code>=</code>时，可以以值传递的方式调用Lambda表达式所在作用域的局部变量</p>\n<p>参数为<code>&amp;</code>时，可以以引用传递的方式调用Lambda表达式所在作用域的局部变量</p>\n<p>参数为<code>this</code>时，可以调用Lambda表达式所在类的成员变量</p>\n<p>也可以单独取一个或多个变量使用，使用<code>&amp;</code>则为引用传递，否则为值传递</p>\n<p>()这个是放函数参数的地方，同普通的函数参数一样，不过只能使用值传递和引用传递  </p>\n<p>{} 函数体  </p>\n<p>返回值类型使用<code>-&gt;类型名</code>写在函数体的前面，例如：<a href></a>-&gt;int{return 1};</p>\n<p>可修改标识符mutable 可以修改值传递拷贝出来的变量，改变不了本体 例如: <a href></a>mutable{};  </p>\n<p>在我这里的学习中，要调用Lambda表达式还需要在函数体后加上() ,例如：<a href></a>{}();</p>\n<p>Lambda表达式的作用就是在连接信号的时候可以代替槽函数的位置。 例如： cconnect(sender,signal,receiver,<a href></a>{ //这这里可以写更多的操作，更直观 })</p>\n","site":{"data":{}},"excerpt":"<p>专门讲述信号槽、对象树的概念以及使用Lambda表达式</p>","more":"<h1 id=\"信号与槽\"><a href=\"#信号与槽\" class=\"headerlink\" title=\"信号与槽\"></a>信号与槽</h1><p>信号和槽是qt中很重要的一个机制，信号即发送者发送信号，槽即接收者处理信号所做的操作  </p>\n<p>这里即引出名词： 发送者、信号、接收者、槽函数  </p>\n<p>例如：发送者可以是一个按钮，点击它就是一个信号，这个信号连接着接收者，接受者对信号作出处理</p>\n<p>在这里我们用connect方法来连接这些参数即<code>connect(sender,signal,receiver,method)</code>;</p>\n<p>当遇到函数重载是我们可以使用函数指针来解决问题</p>\n<p>我们还可以自定义信号还有槽函数  </p>\n<p>自定义信号只需要函数声明即可，不需要具体实现。而槽函数就需要声明并且要有实现的代码。</p>\n<p>信号和槽的函数的返回值都是void，但可以重载。</p>\n<p>信号的参数个数可以大于槽的参数个数，但是参数要一一对应，也就是对应的参数类型必须要一样，反之则不行。</p>\n<h2 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h2><p>信号可以连接信号</p>\n<p>一个信号连接多个槽函数   槽函数的执行顺序是随机的</p>\n<p>槽函数可以使用Lambda表达式</p>\n<p>信号连接之后可以用disconnect断开</p>\n<h1 id=\"对象树\"><a href=\"#对象树\" class=\"headerlink\" title=\"对象树\"></a>对象树</h1><p>在Qt中，存在对象树的概念，他的功能是在一定程度上简化内存的释放。 </p>\n<p>在基于QObject的类中或者继承了QObject类的子类，都会自动回收内存。所以说我们new出来的对象指定好父类，他就会自动回收。</p>\n<p>例如： 以new的方式创建一个按钮，将它放在Widget的对象中，那么这个按钮他将会在这个Widget释放前自动释放掉。</p>\n<h1 id=\"Lambda表达式\"><a href=\"#Lambda表达式\" class=\"headerlink\" title=\"Lambda表达式\"></a>Lambda表达式</h1><p>在C++11中，Lambda表达式用于定义并创建匿名的函数对象，相当于一个匿名函数。  </p>\n<p>Lambda表达式声明： <a href=\"操作符重载函数参数\">函数对象参数</a>{函数体}</p>\n<p>[]是识别一个lambda表达式的开始。</p>\n<p>参数为<code>空</code>时，没有调用外面的任何局部变量</p>\n<p>参数为<code>=</code>时，可以以值传递的方式调用Lambda表达式所在作用域的局部变量</p>\n<p>参数为<code>&amp;</code>时，可以以引用传递的方式调用Lambda表达式所在作用域的局部变量</p>\n<p>参数为<code>this</code>时，可以调用Lambda表达式所在类的成员变量</p>\n<p>也可以单独取一个或多个变量使用，使用<code>&amp;</code>则为引用传递，否则为值传递</p>\n<p>()这个是放函数参数的地方，同普通的函数参数一样，不过只能使用值传递和引用传递  </p>\n<p>{} 函数体  </p>\n<p>返回值类型使用<code>-&gt;类型名</code>写在函数体的前面，例如：<a href></a>-&gt;int{return 1};</p>\n<p>可修改标识符mutable 可以修改值传递拷贝出来的变量，改变不了本体 例如: <a href></a>mutable{};  </p>\n<p>在我这里的学习中，要调用Lambda表达式还需要在函数体后加上() ,例如：<a href></a>{}();</p>\n<p>Lambda表达式的作用就是在连接信号的时候可以代替槽函数的位置。 例如： cconnect(sender,signal,receiver,<a href></a>{ //这这里可以写更多的操作，更直观 })</p>"},{"title":"Qt_快速入门(一)","date":"2019-08-03T04:59:51.000Z","_content":"本节讲述qt一些基本知识\n\n<!--more-->\n\n# Qt的简介  \n\nQt是一个跨平台的C++开发库，主要用来开发图形用户应用程序。\n\nQt是纯C++开发的，所以建议有C++的基础再来学习。 \n\nQt的优点非常多，比如说跨平台，接口丰富等等。\n\nQt的成功案例：Linux KDE桌面就是用Qt开发的。\n\n# Qt开发环境的选择   \n\n个人使用的是Qt creator。\n\nmanjaro Linux的下载方法就是一条简单的命令  \n\n`sudo pacman -S qtcreator`  \n\n下载完成之后，可以打开软件修改中文界面（默认是英语）\n\nTools -> Options -> Environment -> Interface 里的Language 修改成Chinese(china)  \n\n不过我的系统在这里有一个小问题，就是选项中没有中文语言，可以用一条命令解决  \n\n`sudo pacman -S qt5-translations`  \n\n之后就可以正常选择了\n\n# Qt的第一个程序  \n\n新建项目 -> 选择Qt Widgets App... ->\nLocation: 可以修改项目名称和路径 ->\nKits: 构建套件，在实际开发可以选择，我们直接下一步就行了 ->\nDetails: 可以选择一些基类和界面文件并设置名称，这里我们选择Qwidget，然后把界面文件勾选掉 -> 汇总: 添加版本控制，点击完成即可。\n\n完成之后会生成一些文件  \n\npro文件 、main.cpp文件和 你创建的类的头文件和实现文件\n\n.pro文件：这个文件可以说是配置文件，可以添加一些模块  \n\nmain.cpp会自动生成一些代码，直接运行就可以弹出一个窗口\n\n```\n#include \"widget.h\"\n//包含我们自己新建的类的头文件\n#include <QApplication>\n//包含一个应用程序类的头文件\n\nint main(int argc, char *argv[])\n//main程序入口  argc命令行变量的数量   argv命令行变量的数组\n{\n    QApplication a(argc, argv);\n    //实例化应用程序对象，在Qt中，有且只有一个\n    Widget w;\n    //实例化一个窗口对象\n    w.show(); \n    //调用方法显示窗口\n    return a.exec();\n    //防止窗口一闪而过，进入消息循环\n}\n```\n","source":"_posts/Qt-快速入门-一.md","raw":"---\ntitle: Qt_快速入门(一)\ndate: 2019-08-03 12:59:51\ntags:\ncategories:\n---\n本节讲述qt一些基本知识\n\n<!--more-->\n\n# Qt的简介  \n\nQt是一个跨平台的C++开发库，主要用来开发图形用户应用程序。\n\nQt是纯C++开发的，所以建议有C++的基础再来学习。 \n\nQt的优点非常多，比如说跨平台，接口丰富等等。\n\nQt的成功案例：Linux KDE桌面就是用Qt开发的。\n\n# Qt开发环境的选择   \n\n个人使用的是Qt creator。\n\nmanjaro Linux的下载方法就是一条简单的命令  \n\n`sudo pacman -S qtcreator`  \n\n下载完成之后，可以打开软件修改中文界面（默认是英语）\n\nTools -> Options -> Environment -> Interface 里的Language 修改成Chinese(china)  \n\n不过我的系统在这里有一个小问题，就是选项中没有中文语言，可以用一条命令解决  \n\n`sudo pacman -S qt5-translations`  \n\n之后就可以正常选择了\n\n# Qt的第一个程序  \n\n新建项目 -> 选择Qt Widgets App... ->\nLocation: 可以修改项目名称和路径 ->\nKits: 构建套件，在实际开发可以选择，我们直接下一步就行了 ->\nDetails: 可以选择一些基类和界面文件并设置名称，这里我们选择Qwidget，然后把界面文件勾选掉 -> 汇总: 添加版本控制，点击完成即可。\n\n完成之后会生成一些文件  \n\npro文件 、main.cpp文件和 你创建的类的头文件和实现文件\n\n.pro文件：这个文件可以说是配置文件，可以添加一些模块  \n\nmain.cpp会自动生成一些代码，直接运行就可以弹出一个窗口\n\n```\n#include \"widget.h\"\n//包含我们自己新建的类的头文件\n#include <QApplication>\n//包含一个应用程序类的头文件\n\nint main(int argc, char *argv[])\n//main程序入口  argc命令行变量的数量   argv命令行变量的数组\n{\n    QApplication a(argc, argv);\n    //实例化应用程序对象，在Qt中，有且只有一个\n    Widget w;\n    //实例化一个窗口对象\n    w.show(); \n    //调用方法显示窗口\n    return a.exec();\n    //防止窗口一闪而过，进入消息循环\n}\n```\n","slug":"Qt-快速入门-一","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpu5000x7qsg80nqml3l","content":"<p>本节讲述qt一些基本知识</p>\n<a id=\"more\"></a>\n<h1 id=\"Qt的简介\"><a href=\"#Qt的简介\" class=\"headerlink\" title=\"Qt的简介\"></a>Qt的简介</h1><p>Qt是一个跨平台的C++开发库，主要用来开发图形用户应用程序。</p>\n<p>Qt是纯C++开发的，所以建议有C++的基础再来学习。 </p>\n<p>Qt的优点非常多，比如说跨平台，接口丰富等等。</p>\n<p>Qt的成功案例：Linux KDE桌面就是用Qt开发的。</p>\n<h1 id=\"Qt开发环境的选择\"><a href=\"#Qt开发环境的选择\" class=\"headerlink\" title=\"Qt开发环境的选择\"></a>Qt开发环境的选择</h1><p>个人使用的是Qt creator。</p>\n<p>manjaro Linux的下载方法就是一条简单的命令  </p>\n<p><code>sudo pacman -S qtcreator</code>  </p>\n<p>下载完成之后，可以打开软件修改中文界面（默认是英语）</p>\n<p>Tools -&gt; Options -&gt; Environment -&gt; Interface 里的Language 修改成Chinese(china)  </p>\n<p>不过我的系统在这里有一个小问题，就是选项中没有中文语言，可以用一条命令解决  </p>\n<p><code>sudo pacman -S qt5-translations</code>  </p>\n<p>之后就可以正常选择了</p>\n<h1 id=\"Qt的第一个程序\"><a href=\"#Qt的第一个程序\" class=\"headerlink\" title=\"Qt的第一个程序\"></a>Qt的第一个程序</h1><p>新建项目 -&gt; 选择Qt Widgets App… -&gt;<br>Location: 可以修改项目名称和路径 -&gt;<br>Kits: 构建套件，在实际开发可以选择，我们直接下一步就行了 -&gt;<br>Details: 可以选择一些基类和界面文件并设置名称，这里我们选择Qwidget，然后把界面文件勾选掉 -&gt; 汇总: 添加版本控制，点击完成即可。</p>\n<p>完成之后会生成一些文件  </p>\n<p>pro文件 、main.cpp文件和 你创建的类的头文件和实现文件</p>\n<p>.pro文件：这个文件可以说是配置文件，可以添加一些模块  </p>\n<p>main.cpp会自动生成一些代码，直接运行就可以弹出一个窗口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;widget.h&quot;</span><br><span class=\"line\">//包含我们自己新建的类的头文件</span><br><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\">//包含一个应用程序类的头文件</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">//main程序入口  argc命令行变量的数量   argv命令行变量的数组</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QApplication a(argc, argv);</span><br><span class=\"line\">    //实例化应用程序对象，在Qt中，有且只有一个</span><br><span class=\"line\">    Widget w;</span><br><span class=\"line\">    //实例化一个窗口对象</span><br><span class=\"line\">    w.show(); </span><br><span class=\"line\">    //调用方法显示窗口</span><br><span class=\"line\">    return a.exec();</span><br><span class=\"line\">    //防止窗口一闪而过，进入消息循环</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本节讲述qt一些基本知识</p>","more":"<h1 id=\"Qt的简介\"><a href=\"#Qt的简介\" class=\"headerlink\" title=\"Qt的简介\"></a>Qt的简介</h1><p>Qt是一个跨平台的C++开发库，主要用来开发图形用户应用程序。</p>\n<p>Qt是纯C++开发的，所以建议有C++的基础再来学习。 </p>\n<p>Qt的优点非常多，比如说跨平台，接口丰富等等。</p>\n<p>Qt的成功案例：Linux KDE桌面就是用Qt开发的。</p>\n<h1 id=\"Qt开发环境的选择\"><a href=\"#Qt开发环境的选择\" class=\"headerlink\" title=\"Qt开发环境的选择\"></a>Qt开发环境的选择</h1><p>个人使用的是Qt creator。</p>\n<p>manjaro Linux的下载方法就是一条简单的命令  </p>\n<p><code>sudo pacman -S qtcreator</code>  </p>\n<p>下载完成之后，可以打开软件修改中文界面（默认是英语）</p>\n<p>Tools -&gt; Options -&gt; Environment -&gt; Interface 里的Language 修改成Chinese(china)  </p>\n<p>不过我的系统在这里有一个小问题，就是选项中没有中文语言，可以用一条命令解决  </p>\n<p><code>sudo pacman -S qt5-translations</code>  </p>\n<p>之后就可以正常选择了</p>\n<h1 id=\"Qt的第一个程序\"><a href=\"#Qt的第一个程序\" class=\"headerlink\" title=\"Qt的第一个程序\"></a>Qt的第一个程序</h1><p>新建项目 -&gt; 选择Qt Widgets App… -&gt;<br>Location: 可以修改项目名称和路径 -&gt;<br>Kits: 构建套件，在实际开发可以选择，我们直接下一步就行了 -&gt;<br>Details: 可以选择一些基类和界面文件并设置名称，这里我们选择Qwidget，然后把界面文件勾选掉 -&gt; 汇总: 添加版本控制，点击完成即可。</p>\n<p>完成之后会生成一些文件  </p>\n<p>pro文件 、main.cpp文件和 你创建的类的头文件和实现文件</p>\n<p>.pro文件：这个文件可以说是配置文件，可以添加一些模块  </p>\n<p>main.cpp会自动生成一些代码，直接运行就可以弹出一个窗口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;widget.h&quot;</span><br><span class=\"line\">//包含我们自己新建的类的头文件</span><br><span class=\"line\">#include &lt;QApplication&gt;</span><br><span class=\"line\">//包含一个应用程序类的头文件</span><br><span class=\"line\"></span><br><span class=\"line\">int main(int argc, char *argv[])</span><br><span class=\"line\">//main程序入口  argc命令行变量的数量   argv命令行变量的数组</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    QApplication a(argc, argv);</span><br><span class=\"line\">    //实例化应用程序对象，在Qt中，有且只有一个</span><br><span class=\"line\">    Widget w;</span><br><span class=\"line\">    //实例化一个窗口对象</span><br><span class=\"line\">    w.show(); </span><br><span class=\"line\">    //调用方法显示窗口</span><br><span class=\"line\">    return a.exec();</span><br><span class=\"line\">    //防止窗口一闪而过，进入消息循环</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Qt_快速入门(二)","date":"2019-08-03T06:32:06.000Z","_content":"本节讲述Qt中的一些窗口控件如何使用代码创建\n\n<!--more-->\n\n# 菜单栏  \n\n头文件： `#include <QMenuBar>`  \n\n创建方法： `QMenuBar * MenuBar = menuBar()`  \n\n这种方法创建的菜单栏需要使用setMenuBar方法设置到窗口中,菜单栏只能有一个  \n\n# 状态栏  \n\n头文件：`#include <QStatusBar>`  \n\n创建方法： `QStatusBar * status = new QStatusBar(this)`  \n\n状态栏也只能\n\n# 工具栏  \n\n头文件： `#include <QToolBar>`  \n\n创建方法： `QToolBar * toolbar = new QToolBar(this)`  \n\n# 标签  \n\n头文件： `#include <QLabel>`  \n\n创建方法： ` QLabel * label = new QLabel(this)`  \n\n# 按钮  \n\n头文件: `#include <QPushButton>`  \n\n创建方法: `QPushButton * btn = new QPushButton(\"test\",this)`  \n\n按钮要使用new的方式创建在堆区中，否则就会一闪而过。这里使用了两个参数构造函数，第一个是按钮\n的名称，第二个是要依赖的窗口，因为代码是在Qwidget类中写的，所以直接使用this。\n\n# 浮动窗口  \n\n头文件：`#include <QDockWidget>`  \n\n创建方法： `QDockWidget * dock = new QDockWidget(\"浮动窗口\",this)`  \n\n# 文本编辑器  \n\n头文件： `#include <QTextEdit>`  \n\n创建方法： `QTextEdit * edit = new QTextEdit(this)`  \n\n\n","source":"_posts/Qt-快速入门-二.md","raw":"---\ntitle: Qt_快速入门(二)\ndate: 2019-08-03 14:32:06\ntags:\ncategories:\n---\n本节讲述Qt中的一些窗口控件如何使用代码创建\n\n<!--more-->\n\n# 菜单栏  \n\n头文件： `#include <QMenuBar>`  \n\n创建方法： `QMenuBar * MenuBar = menuBar()`  \n\n这种方法创建的菜单栏需要使用setMenuBar方法设置到窗口中,菜单栏只能有一个  \n\n# 状态栏  \n\n头文件：`#include <QStatusBar>`  \n\n创建方法： `QStatusBar * status = new QStatusBar(this)`  \n\n状态栏也只能\n\n# 工具栏  \n\n头文件： `#include <QToolBar>`  \n\n创建方法： `QToolBar * toolbar = new QToolBar(this)`  \n\n# 标签  \n\n头文件： `#include <QLabel>`  \n\n创建方法： ` QLabel * label = new QLabel(this)`  \n\n# 按钮  \n\n头文件: `#include <QPushButton>`  \n\n创建方法: `QPushButton * btn = new QPushButton(\"test\",this)`  \n\n按钮要使用new的方式创建在堆区中，否则就会一闪而过。这里使用了两个参数构造函数，第一个是按钮\n的名称，第二个是要依赖的窗口，因为代码是在Qwidget类中写的，所以直接使用this。\n\n# 浮动窗口  \n\n头文件：`#include <QDockWidget>`  \n\n创建方法： `QDockWidget * dock = new QDockWidget(\"浮动窗口\",this)`  \n\n# 文本编辑器  \n\n头文件： `#include <QTextEdit>`  \n\n创建方法： `QTextEdit * edit = new QTextEdit(this)`  \n\n\n","slug":"Qt-快速入门-二","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpu700107qsg5d5y6jc6","content":"<p>本节讲述Qt中的一些窗口控件如何使用代码创建</p>\n<a id=\"more\"></a>\n<h1 id=\"菜单栏\"><a href=\"#菜单栏\" class=\"headerlink\" title=\"菜单栏\"></a>菜单栏</h1><p>头文件： <code>#include &lt;QMenuBar&gt;</code>  </p>\n<p>创建方法： <code>QMenuBar * MenuBar = menuBar()</code>  </p>\n<p>这种方法创建的菜单栏需要使用setMenuBar方法设置到窗口中,菜单栏只能有一个  </p>\n<h1 id=\"状态栏\"><a href=\"#状态栏\" class=\"headerlink\" title=\"状态栏\"></a>状态栏</h1><p>头文件：<code>#include &lt;QStatusBar&gt;</code>  </p>\n<p>创建方法： <code>QStatusBar * status = new QStatusBar(this)</code>  </p>\n<p>状态栏也只能</p>\n<h1 id=\"工具栏\"><a href=\"#工具栏\" class=\"headerlink\" title=\"工具栏\"></a>工具栏</h1><p>头文件： <code>#include &lt;QToolBar&gt;</code>  </p>\n<p>创建方法： <code>QToolBar * toolbar = new QToolBar(this)</code>  </p>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p>头文件： <code>#include &lt;QLabel&gt;</code>  </p>\n<p>创建方法： <code>QLabel * label = new QLabel(this)</code>  </p>\n<h1 id=\"按钮\"><a href=\"#按钮\" class=\"headerlink\" title=\"按钮\"></a>按钮</h1><p>头文件: <code>#include &lt;QPushButton&gt;</code>  </p>\n<p>创建方法: <code>QPushButton * btn = new QPushButton(&quot;test&quot;,this)</code>  </p>\n<p>按钮要使用new的方式创建在堆区中，否则就会一闪而过。这里使用了两个参数构造函数，第一个是按钮<br>的名称，第二个是要依赖的窗口，因为代码是在Qwidget类中写的，所以直接使用this。</p>\n<h1 id=\"浮动窗口\"><a href=\"#浮动窗口\" class=\"headerlink\" title=\"浮动窗口\"></a>浮动窗口</h1><p>头文件：<code>#include &lt;QDockWidget&gt;</code>  </p>\n<p>创建方法： <code>QDockWidget * dock = new QDockWidget(&quot;浮动窗口&quot;,this)</code>  </p>\n<h1 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h1><p>头文件： <code>#include &lt;QTextEdit&gt;</code>  </p>\n<p>创建方法： <code>QTextEdit * edit = new QTextEdit(this)</code>  </p>\n","site":{"data":{}},"excerpt":"<p>本节讲述Qt中的一些窗口控件如何使用代码创建</p>","more":"<h1 id=\"菜单栏\"><a href=\"#菜单栏\" class=\"headerlink\" title=\"菜单栏\"></a>菜单栏</h1><p>头文件： <code>#include &lt;QMenuBar&gt;</code>  </p>\n<p>创建方法： <code>QMenuBar * MenuBar = menuBar()</code>  </p>\n<p>这种方法创建的菜单栏需要使用setMenuBar方法设置到窗口中,菜单栏只能有一个  </p>\n<h1 id=\"状态栏\"><a href=\"#状态栏\" class=\"headerlink\" title=\"状态栏\"></a>状态栏</h1><p>头文件：<code>#include &lt;QStatusBar&gt;</code>  </p>\n<p>创建方法： <code>QStatusBar * status = new QStatusBar(this)</code>  </p>\n<p>状态栏也只能</p>\n<h1 id=\"工具栏\"><a href=\"#工具栏\" class=\"headerlink\" title=\"工具栏\"></a>工具栏</h1><p>头文件： <code>#include &lt;QToolBar&gt;</code>  </p>\n<p>创建方法： <code>QToolBar * toolbar = new QToolBar(this)</code>  </p>\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><p>头文件： <code>#include &lt;QLabel&gt;</code>  </p>\n<p>创建方法： <code>QLabel * label = new QLabel(this)</code>  </p>\n<h1 id=\"按钮\"><a href=\"#按钮\" class=\"headerlink\" title=\"按钮\"></a>按钮</h1><p>头文件: <code>#include &lt;QPushButton&gt;</code>  </p>\n<p>创建方法: <code>QPushButton * btn = new QPushButton(&quot;test&quot;,this)</code>  </p>\n<p>按钮要使用new的方式创建在堆区中，否则就会一闪而过。这里使用了两个参数构造函数，第一个是按钮<br>的名称，第二个是要依赖的窗口，因为代码是在Qwidget类中写的，所以直接使用this。</p>\n<h1 id=\"浮动窗口\"><a href=\"#浮动窗口\" class=\"headerlink\" title=\"浮动窗口\"></a>浮动窗口</h1><p>头文件：<code>#include &lt;QDockWidget&gt;</code>  </p>\n<p>创建方法： <code>QDockWidget * dock = new QDockWidget(&quot;浮动窗口&quot;,this)</code>  </p>\n<h1 id=\"文本编辑器\"><a href=\"#文本编辑器\" class=\"headerlink\" title=\"文本编辑器\"></a>文本编辑器</h1><p>头文件： <code>#include &lt;QTextEdit&gt;</code>  </p>\n<p>创建方法： <code>QTextEdit * edit = new QTextEdit(this)</code>  </p>"},{"layout":"n","title":"shell快捷键大全","date":"2019-05-09T14:48:26.000Z","_content":"\n常用快捷键\n<!--more-->\n\n# 移动光标快捷键\n\n1. ctrl+f 向右移动一个字符\n2. ctrl+b 向左移动一个字符\n3. ctrl+a 移动到当前行首home\n4. ctrl+e 移动到当前行尾end\n5. ctrl+l 清屏，并在屏幕最上面开始一个新行\n6. alt+f 向右移动一个单词\n7. alt+b 向左移动一个单词  \n\n# 编辑命令行快捷键\n1. ctrl+d 删除当前的字符（Del）\n2. ctrl+t 交换当前字符和左一个字符的位置\n3. alt+t 交换当前单词d和左一个单词的位置\n4. alt+u 把当前单词变成大写\n5. alt+l 把当前单词变成小写(在manjaro等同于ls命令)\n6. alt+c 把当前位置字母变大写的字母并跳到词尾\n\n#  剪切、粘贴快捷键\n\n1. alt d：删除从光标到当前单词结尾的部分\n2. ctrl+k 剪切文本直到行的末尾\n3. ctrl+u 剪切文本直到行的起始\n4. ctrl+w 剪切光标前的单词，删除最后输入的单词\n5. ctrl+y 粘贴刚才所删除的字符\n6. ctrl+c 删除整行，终端进程\n7. ctrl+d 退出shell，\n8. ctrl+h 删除左边字符   ","source":"_posts/shell快捷键大全.md","raw":"---\nlayout: 'n'\ntitle: shell快捷键大全\ndate: 2019-05-09 22:48:26\ntags: note  \ncategories: Linux  \n---\n\n常用快捷键\n<!--more-->\n\n# 移动光标快捷键\n\n1. ctrl+f 向右移动一个字符\n2. ctrl+b 向左移动一个字符\n3. ctrl+a 移动到当前行首home\n4. ctrl+e 移动到当前行尾end\n5. ctrl+l 清屏，并在屏幕最上面开始一个新行\n6. alt+f 向右移动一个单词\n7. alt+b 向左移动一个单词  \n\n# 编辑命令行快捷键\n1. ctrl+d 删除当前的字符（Del）\n2. ctrl+t 交换当前字符和左一个字符的位置\n3. alt+t 交换当前单词d和左一个单词的位置\n4. alt+u 把当前单词变成大写\n5. alt+l 把当前单词变成小写(在manjaro等同于ls命令)\n6. alt+c 把当前位置字母变大写的字母并跳到词尾\n\n#  剪切、粘贴快捷键\n\n1. alt d：删除从光标到当前单词结尾的部分\n2. ctrl+k 剪切文本直到行的末尾\n3. ctrl+u 剪切文本直到行的起始\n4. ctrl+w 剪切光标前的单词，删除最后输入的单词\n5. ctrl+y 粘贴刚才所删除的字符\n6. ctrl+c 删除整行，终端进程\n7. ctrl+d 退出shell，\n8. ctrl+h 删除左边字符   ","slug":"shell快捷键大全","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"photos":[],"link":"","_id":"ck29akpu800127qsgv9mmn5s2","content":"<p>常用快捷键<br><a id=\"more\"></a></p>\n<h1 id=\"移动光标快捷键\"><a href=\"#移动光标快捷键\" class=\"headerlink\" title=\"移动光标快捷键\"></a>移动光标快捷键</h1><ol>\n<li>ctrl+f 向右移动一个字符</li>\n<li>ctrl+b 向左移动一个字符</li>\n<li>ctrl+a 移动到当前行首home</li>\n<li>ctrl+e 移动到当前行尾end</li>\n<li>ctrl+l 清屏，并在屏幕最上面开始一个新行</li>\n<li>alt+f 向右移动一个单词</li>\n<li>alt+b 向左移动一个单词  </li>\n</ol>\n<h1 id=\"编辑命令行快捷键\"><a href=\"#编辑命令行快捷键\" class=\"headerlink\" title=\"编辑命令行快捷键\"></a>编辑命令行快捷键</h1><ol>\n<li>ctrl+d 删除当前的字符（Del）</li>\n<li>ctrl+t 交换当前字符和左一个字符的位置</li>\n<li>alt+t 交换当前单词d和左一个单词的位置</li>\n<li>alt+u 把当前单词变成大写</li>\n<li>alt+l 把当前单词变成小写(在manjaro等同于ls命令)</li>\n<li>alt+c 把当前位置字母变大写的字母并跳到词尾</li>\n</ol>\n<h1 id=\"剪切、粘贴快捷键\"><a href=\"#剪切、粘贴快捷键\" class=\"headerlink\" title=\"剪切、粘贴快捷键\"></a>剪切、粘贴快捷键</h1><ol>\n<li>alt d：删除从光标到当前单词结尾的部分</li>\n<li>ctrl+k 剪切文本直到行的末尾</li>\n<li>ctrl+u 剪切文本直到行的起始</li>\n<li>ctrl+w 剪切光标前的单词，删除最后输入的单词</li>\n<li>ctrl+y 粘贴刚才所删除的字符</li>\n<li>ctrl+c 删除整行，终端进程</li>\n<li>ctrl+d 退出shell，</li>\n<li>ctrl+h 删除左边字符   </li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>常用快捷键<br></p>","more":"<p></p>\n<h1 id=\"移动光标快捷键\"><a href=\"#移动光标快捷键\" class=\"headerlink\" title=\"移动光标快捷键\"></a>移动光标快捷键</h1><ol>\n<li>ctrl+f 向右移动一个字符</li>\n<li>ctrl+b 向左移动一个字符</li>\n<li>ctrl+a 移动到当前行首home</li>\n<li>ctrl+e 移动到当前行尾end</li>\n<li>ctrl+l 清屏，并在屏幕最上面开始一个新行</li>\n<li>alt+f 向右移动一个单词</li>\n<li>alt+b 向左移动一个单词  </li>\n</ol>\n<h1 id=\"编辑命令行快捷键\"><a href=\"#编辑命令行快捷键\" class=\"headerlink\" title=\"编辑命令行快捷键\"></a>编辑命令行快捷键</h1><ol>\n<li>ctrl+d 删除当前的字符（Del）</li>\n<li>ctrl+t 交换当前字符和左一个字符的位置</li>\n<li>alt+t 交换当前单词d和左一个单词的位置</li>\n<li>alt+u 把当前单词变成大写</li>\n<li>alt+l 把当前单词变成小写(在manjaro等同于ls命令)</li>\n<li>alt+c 把当前位置字母变大写的字母并跳到词尾</li>\n</ol>\n<h1 id=\"剪切、粘贴快捷键\"><a href=\"#剪切、粘贴快捷键\" class=\"headerlink\" title=\"剪切、粘贴快捷键\"></a>剪切、粘贴快捷键</h1><ol>\n<li>alt d：删除从光标到当前单词结尾的部分</li>\n<li>ctrl+k 剪切文本直到行的末尾</li>\n<li>ctrl+u 剪切文本直到行的起始</li>\n<li>ctrl+w 剪切光标前的单词，删除最后输入的单词</li>\n<li>ctrl+y 粘贴刚才所删除的字符</li>\n<li>ctrl+c 删除整行，终端进程</li>\n<li>ctrl+d 退出shell，</li>\n<li>ctrl+h 删除左边字符   </li>\n</ol>"},{"title":"shell常用命令","date":"2019-06-02T13:17:37.000Z","_content":"大部分命令都可以通过man的方法获取\n<!--more-->\n# 常用系统工作命令  \n- **echo命令**  \n输出字符串或变量提取后的值\necho 字符串 || $变量\n\n|参数|作用|\n|:-:|:-:|\n|-n|不换行输出内容|\n|-e|解析转义字符|\n|\\n|换行|\n|\\t|制表符|\n|\\r|回车|\n\n\n- **date**  \n显示及设置系统的时间或日期\ndate 参数  \n\n|参数|作用|\n|:-:|:-:|\n|%t|制表位|\n|%Y|年|\n|%m|月|\n|%d|日|\n|%H|0～23小时|\n|%I|0～12小时|\n|%M|分钟|\n|%S|秒|\n|%F|日期全格式|\n|%j|今年的第几天|\n\n\n- **reboot**  \n重启系统，使用管理权限  \nsudo reboot : 管理员权限重启系统   \n\n- **poweroff**  \n关闭系统，使用管理员权限  \nsudo poweroff : 管理员权限关闭系统  \n\n- **wget**  \n 在终端中下载网络文件，格式为  \nwget 参数 下载地址   \n\n|参数|作用|\n|:-:|:-:|\n|-b | 后台下载模式|  \n|-p | 下载到制定目录|  \n|-t | 最大尝试次数  |\n|-c | 断电续传|\n|-p | 下载页面内所有资源，包括图片，视频等  |\n|-r | 递归下载  |\n\n\n- **ps**  \n查看系统中的进程状态，格式为  \nps 参数  \n\n|参数|作用|\n|:-:|:-:|\n|-a | 显示所有进程|  \n|-u | 用户以及其他详细信息|\n|-x | 显示没有控制终端的进程|  \n\n5种常见的进程状态:  \nR 运行  \nS 中断  \nD 不可中断  \nZ 僵死  \nT 停止  \n\n- **top**  \n动态地监控进程活动与系统负载等信息--强化版任务管理器  \n统计信息代表含义：  \n    第一行：系统时间，运行时间,登录终端数，系统负载，（1,5,15分钟的数值，越小越好）  \n    第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的进程数。  \n    第三行：用户资源占用百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的百分比等。  \n    第四行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量  \n    第五行：虚拟内存总量、虚拟内存总量、虚拟内存空闲量、已被提前加载的内存量  \n\n\n\n- **pidof**  \n查询某个指定服务进程的PID值  \npidof 参数 服务名称  \n\n- **kill**  \n 终止某个指定PID的服务进程  \nkill 参数 进程PID  \n\n- **killall**  \n 终止某个指定名称的服务所对应的全部进程  \nkillall 参数 进程名称  \n\n# 系统状态检测命令  \n\n- **ifconfig**  \n 获取网卡配置与网络状态等信息  \nifconfig 网络设备 参数  \n\n- **usame**  \n查看系统内核与系统版本等信息\nuname 参数  \n\n- **uptime**   \nuptime  \n查看系统的负载信息  \n\n- **free**  \n显示当前系统中内存的使用量信息  \nfree 参数  \n\n- **who**  \n查看当前登入主机的用户终端信息  \nwho 参数  \n\n- **last**  \n查看所有系统的登录记录  \nlast 参数  \n\n- **history** \n显示历史执行过的命令  \nhistory 参数  \n\n- **sosreport**  \n收集系统配置及架构信息并输出诊断文档  \n\n# 工作目录切换命令  \n\n- **pwd**  \n显示用户当前所在工作目录  \npwd 选项  \n\n- **cd**  \n切换工作路径  \ncd 目录名称  \n\n|参数|作用|\n|:-:|:-:|\n|cd ~  |  回到home目录|  \n|cd /  |  回到根目录下|  \n|cd .. |  返回上一级目录|    \n\n- **ls**  \n显示目录中的文件信息  \nls 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-a|查看隐藏文件|\n|-l|长格式显示|\n|-d|详细信息|\n\n\n# 文本文件编辑命令\n\n- **cat**  \n查看内容较少的纯文本文件  \ncat 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-n|显示行号|\n\n- **more**  \n查看内容较多的纯文本文件   \nmore 选项 文件\n\n- **head**  \n查看纯文本文档的前N行  \nhead 选项 文本  \n\n- **tail**  \n查看文本的后N行  \ntail 选项 文本  \n\n|参数|作用|\n|:-:|:-:|\n|-n|指定查看多少行|\n\n\n- **tr**  \n替换文本的字符  \ntr 原始字符 替换字符  \n \n- **wc**  \n 统计文本行数、字节数、字数  \n wc 参数 文本  \n\n|参数|作用|\n|:-:|:-:|\n|-l|只显示行数|\n|-w|只显示单词数|\n|-c|只显示字节数|\n\n\n- **stat**  \n查看文件的具体存储信息和时间等信息等  \nstat 文件名称  \n\n- **cut**  \n按列提取文本字符  \ncut 参数 文本  \n\n- **diff**  \n比较多个文本的差异  \ndiff 参数 文件  \n\n\n|参数|作用|\n|:-:|:-:|\n|--brief|判断文件是否相同|\n|-c|描述内容的具体不同|\n\n\n# 文件目录管理命令  \n\n- **touch**  \n创建空白文件或设置文件的时间  \ntouch 参数 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-a|仅修改atime|\n|-m|仅修改mtime|\n|-d|同时修改atime和mtime|\n\n\n- **mkdir**  \n创建空白的目录  \nmkdir 选项 文件  \n\n\n|参数|作用|\n|:-:|:-:|\n|-p|递归创建文件目录|\n\n\n- **cp**  \n复制文件或目录  \ncp 选项 源文件 目标文件  \n\n|参数|作用|\n|:-:|:-:|\n|-p|保留原始文件的属性|\n|-d|若对象为链接文件，则保留该链接文件的属性|\n|-r|递归持续复制|\n|-i|若目标存在则询问是否存在|\n|-a|相当于-pdr的作用|\n\n- **mv**  \n剪切文件或者重命名  \nmv 选项 源文件 目标路径/目标文件名  \n\n- **rm**  \n删除文件或目录  \nrm 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-r|递归删除|\n|-f|强制删除|\n\n- **dd**  \n按照指定大小和个数的数据快来复制文件或转换文件  \ndd 参数  \n\n|参数|作用|\n|:-:|:-:|\n|if|输入的文件名称|\n|of|输出的文件名称|\n|bs|设置每个块的大小|\n|count|设置要复制块的个数|\n\n- **file**  \n查看文件的类型  \nfile 文件名  \n\n# 打包压缩与搜索命令  \n\n- **tar**  \n对文件进行打包压缩或者解压  \ntar 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-c|创建压缩文件|\n|-x|解开压缩文件|\n|-j|用bzip2压缩或解压|\n|-v|显示解压或压缩过程|\n|-f|目标文件名|\n|-p|保留原始的权限与属性|\n|-P|使用绝对路径来压缩|\n|-C|指定解压到的目录|\n|-t|列表查看包内的文件|\n|-z|用gzipv程序进行压缩或解压|\n|-r|追加文件至`.tar`格式文件结尾|\n\n- **grep**  \n在文本中执行关键词搜索，并显示匹配的结果  \ngrep 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-b|将可执行文件当作文本文件来搜索|\n|-c|仅显示找到的行数|\n|-i|忽略大小写|\n|-n|显示行号|\n|-v|反向选择|\n\n- **find**  \n按照指定条件来查找文件  \nfind 查找路径 寻找条件 操作  \n\n|参数|作用|\n|:-:|:-:|\n|-name|匹配名称|\n|-perm|匹配权限|\n|-user|匹配所有者|\n|-group|匹配所有组|\n|-mtime -n +n|匹配修改内容的时间(-n指n天以內，+n指n天以后)|\n|-atime -n +n|匹配访问文件的时间|\n|-ctime -n +n|匹配修改文件权限的时间|\n|-nouser|匹配无所有者的文件|\n|-nogroup|匹配无所有组的文件|\n|-newer f1 !f2|匹配比文件f1新但比f2旧的文件|\n|--type 文件类型|匹配文件类型|\n|-size|匹配文件的大小|\n|-prune|忽略某个目录|\n|-exec ...... {} \\;|后面可跟用于进一步处理搜索结果的命令|\n","source":"_posts/shell-note1.md","raw":"---\ntitle: shell常用命令\ndate: 2019-06-02 21:17:37\ntags: note\ncategories: Linux\n---\n大部分命令都可以通过man的方法获取\n<!--more-->\n# 常用系统工作命令  \n- **echo命令**  \n输出字符串或变量提取后的值\necho 字符串 || $变量\n\n|参数|作用|\n|:-:|:-:|\n|-n|不换行输出内容|\n|-e|解析转义字符|\n|\\n|换行|\n|\\t|制表符|\n|\\r|回车|\n\n\n- **date**  \n显示及设置系统的时间或日期\ndate 参数  \n\n|参数|作用|\n|:-:|:-:|\n|%t|制表位|\n|%Y|年|\n|%m|月|\n|%d|日|\n|%H|0～23小时|\n|%I|0～12小时|\n|%M|分钟|\n|%S|秒|\n|%F|日期全格式|\n|%j|今年的第几天|\n\n\n- **reboot**  \n重启系统，使用管理权限  \nsudo reboot : 管理员权限重启系统   \n\n- **poweroff**  \n关闭系统，使用管理员权限  \nsudo poweroff : 管理员权限关闭系统  \n\n- **wget**  \n 在终端中下载网络文件，格式为  \nwget 参数 下载地址   \n\n|参数|作用|\n|:-:|:-:|\n|-b | 后台下载模式|  \n|-p | 下载到制定目录|  \n|-t | 最大尝试次数  |\n|-c | 断电续传|\n|-p | 下载页面内所有资源，包括图片，视频等  |\n|-r | 递归下载  |\n\n\n- **ps**  \n查看系统中的进程状态，格式为  \nps 参数  \n\n|参数|作用|\n|:-:|:-:|\n|-a | 显示所有进程|  \n|-u | 用户以及其他详细信息|\n|-x | 显示没有控制终端的进程|  \n\n5种常见的进程状态:  \nR 运行  \nS 中断  \nD 不可中断  \nZ 僵死  \nT 停止  \n\n- **top**  \n动态地监控进程活动与系统负载等信息--强化版任务管理器  \n统计信息代表含义：  \n    第一行：系统时间，运行时间,登录终端数，系统负载，（1,5,15分钟的数值，越小越好）  \n    第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的进程数。  \n    第三行：用户资源占用百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的百分比等。  \n    第四行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量  \n    第五行：虚拟内存总量、虚拟内存总量、虚拟内存空闲量、已被提前加载的内存量  \n\n\n\n- **pidof**  \n查询某个指定服务进程的PID值  \npidof 参数 服务名称  \n\n- **kill**  \n 终止某个指定PID的服务进程  \nkill 参数 进程PID  \n\n- **killall**  \n 终止某个指定名称的服务所对应的全部进程  \nkillall 参数 进程名称  \n\n# 系统状态检测命令  \n\n- **ifconfig**  \n 获取网卡配置与网络状态等信息  \nifconfig 网络设备 参数  \n\n- **usame**  \n查看系统内核与系统版本等信息\nuname 参数  \n\n- **uptime**   \nuptime  \n查看系统的负载信息  \n\n- **free**  \n显示当前系统中内存的使用量信息  \nfree 参数  \n\n- **who**  \n查看当前登入主机的用户终端信息  \nwho 参数  \n\n- **last**  \n查看所有系统的登录记录  \nlast 参数  \n\n- **history** \n显示历史执行过的命令  \nhistory 参数  \n\n- **sosreport**  \n收集系统配置及架构信息并输出诊断文档  \n\n# 工作目录切换命令  \n\n- **pwd**  \n显示用户当前所在工作目录  \npwd 选项  \n\n- **cd**  \n切换工作路径  \ncd 目录名称  \n\n|参数|作用|\n|:-:|:-:|\n|cd ~  |  回到home目录|  \n|cd /  |  回到根目录下|  \n|cd .. |  返回上一级目录|    \n\n- **ls**  \n显示目录中的文件信息  \nls 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-a|查看隐藏文件|\n|-l|长格式显示|\n|-d|详细信息|\n\n\n# 文本文件编辑命令\n\n- **cat**  \n查看内容较少的纯文本文件  \ncat 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-n|显示行号|\n\n- **more**  \n查看内容较多的纯文本文件   \nmore 选项 文件\n\n- **head**  \n查看纯文本文档的前N行  \nhead 选项 文本  \n\n- **tail**  \n查看文本的后N行  \ntail 选项 文本  \n\n|参数|作用|\n|:-:|:-:|\n|-n|指定查看多少行|\n\n\n- **tr**  \n替换文本的字符  \ntr 原始字符 替换字符  \n \n- **wc**  \n 统计文本行数、字节数、字数  \n wc 参数 文本  \n\n|参数|作用|\n|:-:|:-:|\n|-l|只显示行数|\n|-w|只显示单词数|\n|-c|只显示字节数|\n\n\n- **stat**  \n查看文件的具体存储信息和时间等信息等  \nstat 文件名称  \n\n- **cut**  \n按列提取文本字符  \ncut 参数 文本  \n\n- **diff**  \n比较多个文本的差异  \ndiff 参数 文件  \n\n\n|参数|作用|\n|:-:|:-:|\n|--brief|判断文件是否相同|\n|-c|描述内容的具体不同|\n\n\n# 文件目录管理命令  \n\n- **touch**  \n创建空白文件或设置文件的时间  \ntouch 参数 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-a|仅修改atime|\n|-m|仅修改mtime|\n|-d|同时修改atime和mtime|\n\n\n- **mkdir**  \n创建空白的目录  \nmkdir 选项 文件  \n\n\n|参数|作用|\n|:-:|:-:|\n|-p|递归创建文件目录|\n\n\n- **cp**  \n复制文件或目录  \ncp 选项 源文件 目标文件  \n\n|参数|作用|\n|:-:|:-:|\n|-p|保留原始文件的属性|\n|-d|若对象为链接文件，则保留该链接文件的属性|\n|-r|递归持续复制|\n|-i|若目标存在则询问是否存在|\n|-a|相当于-pdr的作用|\n\n- **mv**  \n剪切文件或者重命名  \nmv 选项 源文件 目标路径/目标文件名  \n\n- **rm**  \n删除文件或目录  \nrm 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-r|递归删除|\n|-f|强制删除|\n\n- **dd**  \n按照指定大小和个数的数据快来复制文件或转换文件  \ndd 参数  \n\n|参数|作用|\n|:-:|:-:|\n|if|输入的文件名称|\n|of|输出的文件名称|\n|bs|设置每个块的大小|\n|count|设置要复制块的个数|\n\n- **file**  \n查看文件的类型  \nfile 文件名  \n\n# 打包压缩与搜索命令  \n\n- **tar**  \n对文件进行打包压缩或者解压  \ntar 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-c|创建压缩文件|\n|-x|解开压缩文件|\n|-j|用bzip2压缩或解压|\n|-v|显示解压或压缩过程|\n|-f|目标文件名|\n|-p|保留原始的权限与属性|\n|-P|使用绝对路径来压缩|\n|-C|指定解压到的目录|\n|-t|列表查看包内的文件|\n|-z|用gzipv程序进行压缩或解压|\n|-r|追加文件至`.tar`格式文件结尾|\n\n- **grep**  \n在文本中执行关键词搜索，并显示匹配的结果  \ngrep 选项 文件  \n\n|参数|作用|\n|:-:|:-:|\n|-b|将可执行文件当作文本文件来搜索|\n|-c|仅显示找到的行数|\n|-i|忽略大小写|\n|-n|显示行号|\n|-v|反向选择|\n\n- **find**  \n按照指定条件来查找文件  \nfind 查找路径 寻找条件 操作  \n\n|参数|作用|\n|:-:|:-:|\n|-name|匹配名称|\n|-perm|匹配权限|\n|-user|匹配所有者|\n|-group|匹配所有组|\n|-mtime -n +n|匹配修改内容的时间(-n指n天以內，+n指n天以后)|\n|-atime -n +n|匹配访问文件的时间|\n|-ctime -n +n|匹配修改文件权限的时间|\n|-nouser|匹配无所有者的文件|\n|-nogroup|匹配无所有组的文件|\n|-newer f1 !f2|匹配比文件f1新但比f2旧的文件|\n|--type 文件类型|匹配文件类型|\n|-size|匹配文件的大小|\n|-prune|忽略某个目录|\n|-exec ...... {} \\;|后面可跟用于进一步处理搜索结果的命令|\n","slug":"shell-note1","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpu900147qsg4upxzl7l","content":"<p>大部分命令都可以通过man的方法获取<br><a id=\"more\"></a></p>\n<h1 id=\"常用系统工作命令\"><a href=\"#常用系统工作命令\" class=\"headerlink\" title=\"常用系统工作命令\"></a>常用系统工作命令</h1><ul>\n<li><strong>echo命令</strong><br>输出字符串或变量提取后的值<br>echo 字符串 || $变量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">不换行输出内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">解析转义字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:center\">换行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\t</td>\n<td style=\"text-align:center\">制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\r</td>\n<td style=\"text-align:center\">回车</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>date</strong><br>显示及设置系统的时间或日期<br>date 参数  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">%t</td>\n<td style=\"text-align:center\">制表位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%Y</td>\n<td style=\"text-align:center\">年</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%m</td>\n<td style=\"text-align:center\">月</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%d</td>\n<td style=\"text-align:center\">日</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%H</td>\n<td style=\"text-align:center\">0～23小时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%I</td>\n<td style=\"text-align:center\">0～12小时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%M</td>\n<td style=\"text-align:center\">分钟</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%S</td>\n<td style=\"text-align:center\">秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%F</td>\n<td style=\"text-align:center\">日期全格式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%j</td>\n<td style=\"text-align:center\">今年的第几天</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>reboot</strong><br>重启系统，使用管理权限<br>sudo reboot : 管理员权限重启系统   </p>\n</li>\n<li><p><strong>poweroff</strong><br>关闭系统，使用管理员权限<br>sudo poweroff : 管理员权限关闭系统  </p>\n</li>\n<li><p><strong>wget</strong><br>在终端中下载网络文件，格式为<br>wget 参数 下载地址   </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:center\">后台下载模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">下载到制定目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-t</td>\n<td style=\"text-align:center\">最大尝试次数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">断电续传</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">下载页面内所有资源，包括图片，视频等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归下载</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>ps</strong><br>查看系统中的进程状态，格式为<br>ps 参数  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">显示所有进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">用户以及其他详细信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x</td>\n<td style=\"text-align:center\">显示没有控制终端的进程</td>\n</tr>\n</tbody>\n</table>\n<p>5种常见的进程状态:<br>R 运行<br>S 中断<br>D 不可中断<br>Z 僵死<br>T 停止  </p>\n<ul>\n<li><strong>top</strong><br>动态地监控进程活动与系统负载等信息–强化版任务管理器<br>统计信息代表含义：<br>  第一行：系统时间，运行时间,登录终端数，系统负载，（1,5,15分钟的数值，越小越好）<br>  第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的进程数。<br>  第三行：用户资源占用百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的百分比等。<br>  第四行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量<br>  第五行：虚拟内存总量、虚拟内存总量、虚拟内存空闲量、已被提前加载的内存量  </li>\n</ul>\n<ul>\n<li><p><strong>pidof</strong><br>查询某个指定服务进程的PID值<br>pidof 参数 服务名称  </p>\n</li>\n<li><p><strong>kill</strong><br>终止某个指定PID的服务进程<br>kill 参数 进程PID  </p>\n</li>\n<li><p><strong>killall</strong><br>终止某个指定名称的服务所对应的全部进程<br>killall 参数 进程名称  </p>\n</li>\n</ul>\n<h1 id=\"系统状态检测命令\"><a href=\"#系统状态检测命令\" class=\"headerlink\" title=\"系统状态检测命令\"></a>系统状态检测命令</h1><ul>\n<li><p><strong>ifconfig</strong><br>获取网卡配置与网络状态等信息<br>ifconfig 网络设备 参数  </p>\n</li>\n<li><p><strong>usame</strong><br>查看系统内核与系统版本等信息<br>uname 参数  </p>\n</li>\n<li><p><strong>uptime</strong><br>uptime<br>查看系统的负载信息  </p>\n</li>\n<li><p><strong>free</strong><br>显示当前系统中内存的使用量信息<br>free 参数  </p>\n</li>\n<li><p><strong>who</strong><br>查看当前登入主机的用户终端信息<br>who 参数  </p>\n</li>\n<li><p><strong>last</strong><br>查看所有系统的登录记录<br>last 参数  </p>\n</li>\n<li><p><strong>history</strong><br>显示历史执行过的命令<br>history 参数  </p>\n</li>\n<li><p><strong>sosreport</strong><br>收集系统配置及架构信息并输出诊断文档  </p>\n</li>\n</ul>\n<h1 id=\"工作目录切换命令\"><a href=\"#工作目录切换命令\" class=\"headerlink\" title=\"工作目录切换命令\"></a>工作目录切换命令</h1><ul>\n<li><p><strong>pwd</strong><br>显示用户当前所在工作目录<br>pwd 选项  </p>\n</li>\n<li><p><strong>cd</strong><br>切换工作路径<br>cd 目录名称  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cd ~</td>\n<td style=\"text-align:center\">回到home目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cd /</td>\n<td style=\"text-align:center\">回到根目录下</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cd ..</td>\n<td style=\"text-align:center\">返回上一级目录</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>ls</strong><br>显示目录中的文件信息<br>ls 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">查看隐藏文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">长格式显示</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">详细信息</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"文本文件编辑命令\"><a href=\"#文本文件编辑命令\" class=\"headerlink\" title=\"文本文件编辑命令\"></a>文本文件编辑命令</h1><ul>\n<li><strong>cat</strong><br>查看内容较少的纯文本文件<br>cat 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">显示行号</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>more</strong><br>查看内容较多的纯文本文件<br>more 选项 文件</p>\n</li>\n<li><p><strong>head</strong><br>查看纯文本文档的前N行<br>head 选项 文本  </p>\n</li>\n<li><p><strong>tail</strong><br>查看文本的后N行<br>tail 选项 文本  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">指定查看多少行</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>tr</strong><br>替换文本的字符<br>tr 原始字符 替换字符  </p>\n</li>\n<li><p><strong>wc</strong><br>统计文本行数、字节数、字数<br>wc 参数 文本  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">只显示行数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-w</td>\n<td style=\"text-align:center\">只显示单词数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">只显示字节数</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>stat</strong><br>查看文件的具体存储信息和时间等信息等<br>stat 文件名称  </p>\n</li>\n<li><p><strong>cut</strong><br>按列提取文本字符<br>cut 参数 文本  </p>\n</li>\n<li><p><strong>diff</strong><br>比较多个文本的差异<br>diff 参数 文件  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">–brief</td>\n<td style=\"text-align:center\">判断文件是否相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">描述内容的具体不同</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"文件目录管理命令\"><a href=\"#文件目录管理命令\" class=\"headerlink\" title=\"文件目录管理命令\"></a>文件目录管理命令</h1><ul>\n<li><strong>touch</strong><br>创建空白文件或设置文件的时间<br>touch 参数 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">仅修改atime</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-m</td>\n<td style=\"text-align:center\">仅修改mtime</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">同时修改atime和mtime</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>mkdir</strong><br>创建空白的目录<br>mkdir 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">递归创建文件目录</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>cp</strong><br>复制文件或目录<br>cp 选项 源文件 目标文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">保留原始文件的属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">若对象为链接文件，则保留该链接文件的属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归持续复制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-i</td>\n<td style=\"text-align:center\">若目标存在则询问是否存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">相当于-pdr的作用</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>mv</strong><br>剪切文件或者重命名<br>mv 选项 源文件 目标路径/目标文件名  </p>\n</li>\n<li><p><strong>rm</strong><br>删除文件或目录<br>rm 选项 文件  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:center\">强制删除</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>dd</strong><br>按照指定大小和个数的数据快来复制文件或转换文件<br>dd 参数  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">if</td>\n<td style=\"text-align:center\">输入的文件名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">of</td>\n<td style=\"text-align:center\">输出的文件名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bs</td>\n<td style=\"text-align:center\">设置每个块的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:center\">设置要复制块的个数</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>file</strong><br>查看文件的类型<br>file 文件名  </li>\n</ul>\n<h1 id=\"打包压缩与搜索命令\"><a href=\"#打包压缩与搜索命令\" class=\"headerlink\" title=\"打包压缩与搜索命令\"></a>打包压缩与搜索命令</h1><ul>\n<li><strong>tar</strong><br>对文件进行打包压缩或者解压<br>tar 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">创建压缩文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x</td>\n<td style=\"text-align:center\">解开压缩文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-j</td>\n<td style=\"text-align:center\">用bzip2压缩或解压</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-v</td>\n<td style=\"text-align:center\">显示解压或压缩过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:center\">目标文件名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">保留原始的权限与属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-P</td>\n<td style=\"text-align:center\">使用绝对路径来压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-C</td>\n<td style=\"text-align:center\">指定解压到的目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-t</td>\n<td style=\"text-align:center\">列表查看包内的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-z</td>\n<td style=\"text-align:center\">用gzipv程序进行压缩或解压</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">追加文件至<code>.tar</code>格式文件结尾</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>grep</strong><br>在文本中执行关键词搜索，并显示匹配的结果<br>grep 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:center\">将可执行文件当作文本文件来搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">仅显示找到的行数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-i</td>\n<td style=\"text-align:center\">忽略大小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">显示行号</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-v</td>\n<td style=\"text-align:center\">反向选择</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>find</strong><br>按照指定条件来查找文件<br>find 查找路径 寻找条件 操作  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-name</td>\n<td style=\"text-align:center\">匹配名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-perm</td>\n<td style=\"text-align:center\">匹配权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-user</td>\n<td style=\"text-align:center\">匹配所有者</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-group</td>\n<td style=\"text-align:center\">匹配所有组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-mtime -n +n</td>\n<td style=\"text-align:center\">匹配修改内容的时间(-n指n天以內，+n指n天以后)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-atime -n +n</td>\n<td style=\"text-align:center\">匹配访问文件的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-ctime -n +n</td>\n<td style=\"text-align:center\">匹配修改文件权限的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-nouser</td>\n<td style=\"text-align:center\">匹配无所有者的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-nogroup</td>\n<td style=\"text-align:center\">匹配无所有组的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-newer f1 !f2</td>\n<td style=\"text-align:center\">匹配比文件f1新但比f2旧的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">–type 文件类型</td>\n<td style=\"text-align:center\">匹配文件类型</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-size</td>\n<td style=\"text-align:center\">匹配文件的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-prune</td>\n<td style=\"text-align:center\">忽略某个目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-exec …… {} \\;</td>\n<td style=\"text-align:center\">后面可跟用于进一步处理搜索结果的命令</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>大部分命令都可以通过man的方法获取<br></p>","more":"<p></p>\n<h1 id=\"常用系统工作命令\"><a href=\"#常用系统工作命令\" class=\"headerlink\" title=\"常用系统工作命令\"></a>常用系统工作命令</h1><ul>\n<li><strong>echo命令</strong><br>输出字符串或变量提取后的值<br>echo 字符串 || $变量</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">不换行输出内容</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-e</td>\n<td style=\"text-align:center\">解析转义字符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\n</td>\n<td style=\"text-align:center\">换行</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\t</td>\n<td style=\"text-align:center\">制表符</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">\\r</td>\n<td style=\"text-align:center\">回车</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>date</strong><br>显示及设置系统的时间或日期<br>date 参数  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">%t</td>\n<td style=\"text-align:center\">制表位</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%Y</td>\n<td style=\"text-align:center\">年</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%m</td>\n<td style=\"text-align:center\">月</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%d</td>\n<td style=\"text-align:center\">日</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%H</td>\n<td style=\"text-align:center\">0～23小时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%I</td>\n<td style=\"text-align:center\">0～12小时</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%M</td>\n<td style=\"text-align:center\">分钟</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%S</td>\n<td style=\"text-align:center\">秒</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%F</td>\n<td style=\"text-align:center\">日期全格式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">%j</td>\n<td style=\"text-align:center\">今年的第几天</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>reboot</strong><br>重启系统，使用管理权限<br>sudo reboot : 管理员权限重启系统   </p>\n</li>\n<li><p><strong>poweroff</strong><br>关闭系统，使用管理员权限<br>sudo poweroff : 管理员权限关闭系统  </p>\n</li>\n<li><p><strong>wget</strong><br>在终端中下载网络文件，格式为<br>wget 参数 下载地址   </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:center\">后台下载模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">下载到制定目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-t</td>\n<td style=\"text-align:center\">最大尝试次数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">断电续传</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">下载页面内所有资源，包括图片，视频等</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归下载</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>ps</strong><br>查看系统中的进程状态，格式为<br>ps 参数  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">显示所有进程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-u</td>\n<td style=\"text-align:center\">用户以及其他详细信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x</td>\n<td style=\"text-align:center\">显示没有控制终端的进程</td>\n</tr>\n</tbody>\n</table>\n<p>5种常见的进程状态:<br>R 运行<br>S 中断<br>D 不可中断<br>Z 僵死<br>T 停止  </p>\n<ul>\n<li><strong>top</strong><br>动态地监控进程活动与系统负载等信息–强化版任务管理器<br>统计信息代表含义：<br>  第一行：系统时间，运行时间,登录终端数，系统负载，（1,5,15分钟的数值，越小越好）<br>  第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的进程数。<br>  第三行：用户资源占用百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的百分比等。<br>  第四行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量<br>  第五行：虚拟内存总量、虚拟内存总量、虚拟内存空闲量、已被提前加载的内存量  </li>\n</ul>\n<ul>\n<li><p><strong>pidof</strong><br>查询某个指定服务进程的PID值<br>pidof 参数 服务名称  </p>\n</li>\n<li><p><strong>kill</strong><br>终止某个指定PID的服务进程<br>kill 参数 进程PID  </p>\n</li>\n<li><p><strong>killall</strong><br>终止某个指定名称的服务所对应的全部进程<br>killall 参数 进程名称  </p>\n</li>\n</ul>\n<h1 id=\"系统状态检测命令\"><a href=\"#系统状态检测命令\" class=\"headerlink\" title=\"系统状态检测命令\"></a>系统状态检测命令</h1><ul>\n<li><p><strong>ifconfig</strong><br>获取网卡配置与网络状态等信息<br>ifconfig 网络设备 参数  </p>\n</li>\n<li><p><strong>usame</strong><br>查看系统内核与系统版本等信息<br>uname 参数  </p>\n</li>\n<li><p><strong>uptime</strong><br>uptime<br>查看系统的负载信息  </p>\n</li>\n<li><p><strong>free</strong><br>显示当前系统中内存的使用量信息<br>free 参数  </p>\n</li>\n<li><p><strong>who</strong><br>查看当前登入主机的用户终端信息<br>who 参数  </p>\n</li>\n<li><p><strong>last</strong><br>查看所有系统的登录记录<br>last 参数  </p>\n</li>\n<li><p><strong>history</strong><br>显示历史执行过的命令<br>history 参数  </p>\n</li>\n<li><p><strong>sosreport</strong><br>收集系统配置及架构信息并输出诊断文档  </p>\n</li>\n</ul>\n<h1 id=\"工作目录切换命令\"><a href=\"#工作目录切换命令\" class=\"headerlink\" title=\"工作目录切换命令\"></a>工作目录切换命令</h1><ul>\n<li><p><strong>pwd</strong><br>显示用户当前所在工作目录<br>pwd 选项  </p>\n</li>\n<li><p><strong>cd</strong><br>切换工作路径<br>cd 目录名称  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">cd ~</td>\n<td style=\"text-align:center\">回到home目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cd /</td>\n<td style=\"text-align:center\">回到根目录下</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cd ..</td>\n<td style=\"text-align:center\">返回上一级目录</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>ls</strong><br>显示目录中的文件信息<br>ls 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">查看隐藏文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">长格式显示</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">详细信息</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"文本文件编辑命令\"><a href=\"#文本文件编辑命令\" class=\"headerlink\" title=\"文本文件编辑命令\"></a>文本文件编辑命令</h1><ul>\n<li><strong>cat</strong><br>查看内容较少的纯文本文件<br>cat 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">显示行号</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>more</strong><br>查看内容较多的纯文本文件<br>more 选项 文件</p>\n</li>\n<li><p><strong>head</strong><br>查看纯文本文档的前N行<br>head 选项 文本  </p>\n</li>\n<li><p><strong>tail</strong><br>查看文本的后N行<br>tail 选项 文本  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">指定查看多少行</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>tr</strong><br>替换文本的字符<br>tr 原始字符 替换字符  </p>\n</li>\n<li><p><strong>wc</strong><br>统计文本行数、字节数、字数<br>wc 参数 文本  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-l</td>\n<td style=\"text-align:center\">只显示行数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-w</td>\n<td style=\"text-align:center\">只显示单词数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">只显示字节数</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>stat</strong><br>查看文件的具体存储信息和时间等信息等<br>stat 文件名称  </p>\n</li>\n<li><p><strong>cut</strong><br>按列提取文本字符<br>cut 参数 文本  </p>\n</li>\n<li><p><strong>diff</strong><br>比较多个文本的差异<br>diff 参数 文件  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">–brief</td>\n<td style=\"text-align:center\">判断文件是否相同</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">描述内容的具体不同</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"文件目录管理命令\"><a href=\"#文件目录管理命令\" class=\"headerlink\" title=\"文件目录管理命令\"></a>文件目录管理命令</h1><ul>\n<li><strong>touch</strong><br>创建空白文件或设置文件的时间<br>touch 参数 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">仅修改atime</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-m</td>\n<td style=\"text-align:center\">仅修改mtime</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">同时修改atime和mtime</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>mkdir</strong><br>创建空白的目录<br>mkdir 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">递归创建文件目录</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>cp</strong><br>复制文件或目录<br>cp 选项 源文件 目标文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">保留原始文件的属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-d</td>\n<td style=\"text-align:center\">若对象为链接文件，则保留该链接文件的属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归持续复制</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-i</td>\n<td style=\"text-align:center\">若目标存在则询问是否存在</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-a</td>\n<td style=\"text-align:center\">相当于-pdr的作用</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><p><strong>mv</strong><br>剪切文件或者重命名<br>mv 选项 源文件 目标路径/目标文件名  </p>\n</li>\n<li><p><strong>rm</strong><br>删除文件或目录<br>rm 选项 文件  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">递归删除</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:center\">强制删除</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>dd</strong><br>按照指定大小和个数的数据快来复制文件或转换文件<br>dd 参数  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">if</td>\n<td style=\"text-align:center\">输入的文件名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">of</td>\n<td style=\"text-align:center\">输出的文件名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">bs</td>\n<td style=\"text-align:center\">设置每个块的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:center\">设置要复制块的个数</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>file</strong><br>查看文件的类型<br>file 文件名  </li>\n</ul>\n<h1 id=\"打包压缩与搜索命令\"><a href=\"#打包压缩与搜索命令\" class=\"headerlink\" title=\"打包压缩与搜索命令\"></a>打包压缩与搜索命令</h1><ul>\n<li><strong>tar</strong><br>对文件进行打包压缩或者解压<br>tar 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">创建压缩文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-x</td>\n<td style=\"text-align:center\">解开压缩文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-j</td>\n<td style=\"text-align:center\">用bzip2压缩或解压</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-v</td>\n<td style=\"text-align:center\">显示解压或压缩过程</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-f</td>\n<td style=\"text-align:center\">目标文件名</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-p</td>\n<td style=\"text-align:center\">保留原始的权限与属性</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-P</td>\n<td style=\"text-align:center\">使用绝对路径来压缩</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-C</td>\n<td style=\"text-align:center\">指定解压到的目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-t</td>\n<td style=\"text-align:center\">列表查看包内的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-z</td>\n<td style=\"text-align:center\">用gzipv程序进行压缩或解压</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-r</td>\n<td style=\"text-align:center\">追加文件至<code>.tar</code>格式文件结尾</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>grep</strong><br>在文本中执行关键词搜索，并显示匹配的结果<br>grep 选项 文件  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-b</td>\n<td style=\"text-align:center\">将可执行文件当作文本文件来搜索</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-c</td>\n<td style=\"text-align:center\">仅显示找到的行数</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-i</td>\n<td style=\"text-align:center\">忽略大小写</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-n</td>\n<td style=\"text-align:center\">显示行号</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-v</td>\n<td style=\"text-align:center\">反向选择</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>find</strong><br>按照指定条件来查找文件<br>find 查找路径 寻找条件 操作  </li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">参数</th>\n<th style=\"text-align:center\">作用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">-name</td>\n<td style=\"text-align:center\">匹配名称</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-perm</td>\n<td style=\"text-align:center\">匹配权限</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-user</td>\n<td style=\"text-align:center\">匹配所有者</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-group</td>\n<td style=\"text-align:center\">匹配所有组</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-mtime -n +n</td>\n<td style=\"text-align:center\">匹配修改内容的时间(-n指n天以內，+n指n天以后)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-atime -n +n</td>\n<td style=\"text-align:center\">匹配访问文件的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-ctime -n +n</td>\n<td style=\"text-align:center\">匹配修改文件权限的时间</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-nouser</td>\n<td style=\"text-align:center\">匹配无所有者的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-nogroup</td>\n<td style=\"text-align:center\">匹配无所有组的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-newer f1 !f2</td>\n<td style=\"text-align:center\">匹配比文件f1新但比f2旧的文件</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">–type 文件类型</td>\n<td style=\"text-align:center\">匹配文件类型</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-size</td>\n<td style=\"text-align:center\">匹配文件的大小</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-prune</td>\n<td style=\"text-align:center\">忽略某个目录</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">-exec …… {} \\;</td>\n<td style=\"text-align:center\">后面可跟用于进一步处理搜索结果的命令</td>\n</tr>\n</tbody>\n</table>"},{"title":"学习面向对象思想的小结","date":"2019-05-22T08:51:47.000Z","_content":"一些小小小小的感悟吧！ \n<!--more-->\n# 面向对象以前：\n\n在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。\n\n在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！\n\n# 面向对象\n\n面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。\n\n结语：刚踏入的小萌新，多多指教。\n\n","source":"_posts/学习面向对象思想的小结.md","raw":"---\ntitle: 学习面向对象思想的小结\ndate: 2019-05-22 16:51:47\ntags: note\ncategories: C++\n---\n一些小小小小的感悟吧！ \n<!--more-->\n# 面向对象以前：\n\n在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。\n\n在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！\n\n# 面向对象\n\n面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。\n\n结语：刚踏入的小萌新，多多指教。\n\n","slug":"学习面向对象思想的小结","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpub00167qsgl9kv4u0m","content":"<p>一些小小小小的感悟吧！<br><a id=\"more\"></a></p>\n<h1 id=\"面向对象以前：\"><a href=\"#面向对象以前：\" class=\"headerlink\" title=\"面向对象以前：\"></a>面向对象以前：</h1><p>在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。</p>\n<p>在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！</p>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><p>面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。</p>\n<p>结语：刚踏入的小萌新，多多指教。</p>\n","site":{"data":{}},"excerpt":"<p>一些小小小小的感悟吧！<br></p>","more":"<p></p>\n<h1 id=\"面向对象以前：\"><a href=\"#面向对象以前：\" class=\"headerlink\" title=\"面向对象以前：\"></a>面向对象以前：</h1><p>在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。</p>\n<p>在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！</p>\n<h1 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h1><p>面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。</p>\n<p>结语：刚踏入的小萌新，多多指教。</p>"},{"title":"汇编语言基础","date":"2019-09-11T02:01:34.000Z","_content":"<!--more-->","source":"_posts/汇编语言基础.md","raw":"---\ntitle: 汇编语言基础\ndate: 2019-09-11 10:01:34\ntags:\ncategories:\n---\n<!--more-->","slug":"汇编语言基础","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpuc00197qsgkzf30dsq","content":"<a id=\"more\"></a>","site":{"data":{}},"excerpt":"","more":""},{"title":"暑假计划","date":"2019-07-09T09:06:34.000Z","_content":"暑期的一些计划和对之前生活的小结\n<!--more-->\n# 小结  \n\n又有好久没有写博客了，给前一段时间的自己做一个概述和小结，顺便为两个月的暑假定一些目标，时时刻刻给自己提个醒。\n\n我发现自己自从把宿舍搬到跟我一起学习的小伙伴那里，他们就变了一个人似的，一个劲的把我给带坏，图书馆也不带我\n去，代码也不写，尽带我打游戏，玩牌，托坏我的节奏。(其实我自己定力也不够，总喜欢给自己找各种理由)其实吧，也\n不怪他们啦，搬过去的时候也已经是临近期末考试了，大家都想要放松一下。这一段时间就当时宿舍之间的磨合吧！\n\n# 暑期计划  \n\n对于暑假的一些计划是根据认识自身的一些不足的方面制定的，比如说C++项目实践，Linux的更多基本玩机知识等。补充\n一点就是抓紧学习，然后扩展英语词汇量和Qt5的设计方法。\n\n## 计划表格\n\n|计划任务|任务开始时间|\n|:-:|:-:|\n|C++基础|7-10|\n|Linux基础|7-10|\n|英语|7-21|\n|项目实践|8-1|\n|Qt5|8-10|\n|网络原理|8-10|\n\n## 学习方向  \n\n仔细的梳理了一下，发现任务还是挺多的。\n\n对于C++的学习看学学习虽然比较全面，但是太枯燥了，我打算结合视频去实现小项目来加深学习。\n\nLinux是正在使用的系统，要想高效率的开发可以下下功夫，但是需要时间去钻研、玩机，暂时按照需要学习，要用哪方面\n就了解哪一方面。\n\n英语真得花心思去学习一下基本的词汇，在计算机领域有太多英文文档需要去了，如果不想每次都去百度翻译的话，那就把\n翻译这个插件装在自己脑子里吧。\n\n项目实践是很有必要的一个任务，这是一个检验自身能力的一项计划，有很多问题在实际开发中才能遇到，只有把这些坑踩\n了以后的路才会平坦。\n\nQt5是用GUI用户交互设计，想做出好看的界面，还是要努力学习一下的。\n\n网络原理既是本科考试的科目，又是我想学习的黑客技术的必经之路，那学习肯定是不容置疑的啦，只不过现在学习只是为\n了应付考试，暂时没有时间去折腾。\n\n最后学习计划说完了，希望自己能争气，把这些计划如期的完成，还有就是锻炼身体不能落下，如果没有\n健身到130的肌肉我可能都不好意思回到学校了。\n","source":"_posts/暑假计划.md","raw":"---\ntitle: 暑假计划\ndate: 2019-07-09 17:06:34\ntags:\ncategories:\n---\n暑期的一些计划和对之前生活的小结\n<!--more-->\n# 小结  \n\n又有好久没有写博客了，给前一段时间的自己做一个概述和小结，顺便为两个月的暑假定一些目标，时时刻刻给自己提个醒。\n\n我发现自己自从把宿舍搬到跟我一起学习的小伙伴那里，他们就变了一个人似的，一个劲的把我给带坏，图书馆也不带我\n去，代码也不写，尽带我打游戏，玩牌，托坏我的节奏。(其实我自己定力也不够，总喜欢给自己找各种理由)其实吧，也\n不怪他们啦，搬过去的时候也已经是临近期末考试了，大家都想要放松一下。这一段时间就当时宿舍之间的磨合吧！\n\n# 暑期计划  \n\n对于暑假的一些计划是根据认识自身的一些不足的方面制定的，比如说C++项目实践，Linux的更多基本玩机知识等。补充\n一点就是抓紧学习，然后扩展英语词汇量和Qt5的设计方法。\n\n## 计划表格\n\n|计划任务|任务开始时间|\n|:-:|:-:|\n|C++基础|7-10|\n|Linux基础|7-10|\n|英语|7-21|\n|项目实践|8-1|\n|Qt5|8-10|\n|网络原理|8-10|\n\n## 学习方向  \n\n仔细的梳理了一下，发现任务还是挺多的。\n\n对于C++的学习看学学习虽然比较全面，但是太枯燥了，我打算结合视频去实现小项目来加深学习。\n\nLinux是正在使用的系统，要想高效率的开发可以下下功夫，但是需要时间去钻研、玩机，暂时按照需要学习，要用哪方面\n就了解哪一方面。\n\n英语真得花心思去学习一下基本的词汇，在计算机领域有太多英文文档需要去了，如果不想每次都去百度翻译的话，那就把\n翻译这个插件装在自己脑子里吧。\n\n项目实践是很有必要的一个任务，这是一个检验自身能力的一项计划，有很多问题在实际开发中才能遇到，只有把这些坑踩\n了以后的路才会平坦。\n\nQt5是用GUI用户交互设计，想做出好看的界面，还是要努力学习一下的。\n\n网络原理既是本科考试的科目，又是我想学习的黑客技术的必经之路，那学习肯定是不容置疑的啦，只不过现在学习只是为\n了应付考试，暂时没有时间去折腾。\n\n最后学习计划说完了，希望自己能争气，把这些计划如期的完成，还有就是锻炼身体不能落下，如果没有\n健身到130的肌肉我可能都不好意思回到学校了。\n","slug":"暑假计划","published":1,"updated":"2019-10-26T14:46:34.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpue001c7qsg685zmgls","content":"<p>暑期的一些计划和对之前生活的小结<br><a id=\"more\"></a></p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>又有好久没有写博客了，给前一段时间的自己做一个概述和小结，顺便为两个月的暑假定一些目标，时时刻刻给自己提个醒。</p>\n<p>我发现自己自从把宿舍搬到跟我一起学习的小伙伴那里，他们就变了一个人似的，一个劲的把我给带坏，图书馆也不带我<br>去，代码也不写，尽带我打游戏，玩牌，托坏我的节奏。(其实我自己定力也不够，总喜欢给自己找各种理由)其实吧，也<br>不怪他们啦，搬过去的时候也已经是临近期末考试了，大家都想要放松一下。这一段时间就当时宿舍之间的磨合吧！</p>\n<h1 id=\"暑期计划\"><a href=\"#暑期计划\" class=\"headerlink\" title=\"暑期计划\"></a>暑期计划</h1><p>对于暑假的一些计划是根据认识自身的一些不足的方面制定的，比如说C++项目实践，Linux的更多基本玩机知识等。补充<br>一点就是抓紧学习，然后扩展英语词汇量和Qt5的设计方法。</p>\n<h2 id=\"计划表格\"><a href=\"#计划表格\" class=\"headerlink\" title=\"计划表格\"></a>计划表格</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">计划任务</th>\n<th style=\"text-align:center\">任务开始时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">C++基础</td>\n<td style=\"text-align:center\">7-10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Linux基础</td>\n<td style=\"text-align:center\">7-10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">英语</td>\n<td style=\"text-align:center\">7-21</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">项目实践</td>\n<td style=\"text-align:center\">8-1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt5</td>\n<td style=\"text-align:center\">8-10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">网络原理</td>\n<td style=\"text-align:center\">8-10</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"学习方向\"><a href=\"#学习方向\" class=\"headerlink\" title=\"学习方向\"></a>学习方向</h2><p>仔细的梳理了一下，发现任务还是挺多的。</p>\n<p>对于C++的学习看学学习虽然比较全面，但是太枯燥了，我打算结合视频去实现小项目来加深学习。</p>\n<p>Linux是正在使用的系统，要想高效率的开发可以下下功夫，但是需要时间去钻研、玩机，暂时按照需要学习，要用哪方面<br>就了解哪一方面。</p>\n<p>英语真得花心思去学习一下基本的词汇，在计算机领域有太多英文文档需要去了，如果不想每次都去百度翻译的话，那就把<br>翻译这个插件装在自己脑子里吧。</p>\n<p>项目实践是很有必要的一个任务，这是一个检验自身能力的一项计划，有很多问题在实际开发中才能遇到，只有把这些坑踩<br>了以后的路才会平坦。</p>\n<p>Qt5是用GUI用户交互设计，想做出好看的界面，还是要努力学习一下的。</p>\n<p>网络原理既是本科考试的科目，又是我想学习的黑客技术的必经之路，那学习肯定是不容置疑的啦，只不过现在学习只是为<br>了应付考试，暂时没有时间去折腾。</p>\n<p>最后学习计划说完了，希望自己能争气，把这些计划如期的完成，还有就是锻炼身体不能落下，如果没有<br>健身到130的肌肉我可能都不好意思回到学校了。</p>\n","site":{"data":{}},"excerpt":"<p>暑期的一些计划和对之前生活的小结<br></p>","more":"<p></p>\n<h1 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h1><p>又有好久没有写博客了，给前一段时间的自己做一个概述和小结，顺便为两个月的暑假定一些目标，时时刻刻给自己提个醒。</p>\n<p>我发现自己自从把宿舍搬到跟我一起学习的小伙伴那里，他们就变了一个人似的，一个劲的把我给带坏，图书馆也不带我<br>去，代码也不写，尽带我打游戏，玩牌，托坏我的节奏。(其实我自己定力也不够，总喜欢给自己找各种理由)其实吧，也<br>不怪他们啦，搬过去的时候也已经是临近期末考试了，大家都想要放松一下。这一段时间就当时宿舍之间的磨合吧！</p>\n<h1 id=\"暑期计划\"><a href=\"#暑期计划\" class=\"headerlink\" title=\"暑期计划\"></a>暑期计划</h1><p>对于暑假的一些计划是根据认识自身的一些不足的方面制定的，比如说C++项目实践，Linux的更多基本玩机知识等。补充<br>一点就是抓紧学习，然后扩展英语词汇量和Qt5的设计方法。</p>\n<h2 id=\"计划表格\"><a href=\"#计划表格\" class=\"headerlink\" title=\"计划表格\"></a>计划表格</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">计划任务</th>\n<th style=\"text-align:center\">任务开始时间</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">C++基础</td>\n<td style=\"text-align:center\">7-10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Linux基础</td>\n<td style=\"text-align:center\">7-10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">英语</td>\n<td style=\"text-align:center\">7-21</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">项目实践</td>\n<td style=\"text-align:center\">8-1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Qt5</td>\n<td style=\"text-align:center\">8-10</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">网络原理</td>\n<td style=\"text-align:center\">8-10</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"学习方向\"><a href=\"#学习方向\" class=\"headerlink\" title=\"学习方向\"></a>学习方向</h2><p>仔细的梳理了一下，发现任务还是挺多的。</p>\n<p>对于C++的学习看学学习虽然比较全面，但是太枯燥了，我打算结合视频去实现小项目来加深学习。</p>\n<p>Linux是正在使用的系统，要想高效率的开发可以下下功夫，但是需要时间去钻研、玩机，暂时按照需要学习，要用哪方面<br>就了解哪一方面。</p>\n<p>英语真得花心思去学习一下基本的词汇，在计算机领域有太多英文文档需要去了，如果不想每次都去百度翻译的话，那就把<br>翻译这个插件装在自己脑子里吧。</p>\n<p>项目实践是很有必要的一个任务，这是一个检验自身能力的一项计划，有很多问题在实际开发中才能遇到，只有把这些坑踩<br>了以后的路才会平坦。</p>\n<p>Qt5是用GUI用户交互设计，想做出好看的界面，还是要努力学习一下的。</p>\n<p>网络原理既是本科考试的科目，又是我想学习的黑客技术的必经之路，那学习肯定是不容置疑的啦，只不过现在学习只是为<br>了应付考试，暂时没有时间去折腾。</p>\n<p>最后学习计划说完了，希望自己能争气，把这些计划如期的完成，还有就是锻炼身体不能落下，如果没有<br>健身到130的肌肉我可能都不好意思回到学校了。</p>"},{"title":"自学网络原理的第一天","date":"2019-10-06T10:53:53.000Z","_content":"\n有趣的网络原理\n<!--more-->\n第二章：网络应用\n--------\n# 计算机网络应用体系结构 \n先来简单的介绍下有哪些体系结构  \n\n1. 客户/服务器(C/S)结构网络应用  \n(C/S)结构的网络应用最基本，最典型的网络应用。它需要服务器程序先运行，客户程序后运行并主动请求于服务器进行通信。  \n例如www应用，文件传输FTP、电子邮件等。  \n区别于其他的结构体系方法就是它的通信只在客户于服务器之间。\n\n2. 纯P2P结构网络应用结构  \n很明显，这是一个客户对客户的体系结构，P2P应用中的每个对等端都同时具备C/S应用的客户与服务的特征，是一个服务器与客户的结合体。  \n例如Gnurella、BitTorent等  \n在这里，我们已经认识到两种体系结构了，他们各自有优缺点，所以按照取长补短的原则就出现了混合型的体系结构(Ps:好像每次有这种结构啥的都有混合型)\n \n3. 混合结构网络应用  \n它既有中心服务器的存在，又有对等端间的直接通信。是C/S和P2P的结合。\n客户通过C/S方式想服务器注册自己的网络地址，然后就可以在中心服务器找到其他的客户共享资源或分享资源。\n\n# 网络应用通信基本原理  \n- 首先，网络应用的本质就是应用进程之间的通信。  \n- 基本通信方式是C/S通信。  \n- 应用进程之间遵循应用层协议交换应用层报文  \n- 应用层协议定义了语法、语序、语义三要素内容。\n- 按道理说，应该是应用层和应用层之间直接进行传输，但其实是应用层需要通过层间接口将报文发送给传输层，请求端到端传输服务。  \n- 编程接口是套接字，它是网络进程之间进行网络通信时，真正收发报文的通道。  \n- 对于传输层协议，我们需要为其接口的每个套接字编号，用来标识这个套接字，该编号就是端口号。  \n- 比如web服务器的默认端口号是80，是为熟知端口号\n- 每个应用层通过一个或多个套接字于传输层进行接口，因此，我们可以通过进程运行的主机ip地址和套接字绑定的端口号来标识应用进程。  \n\nInternet提供两种传输层协议  \n- 面向连接的可靠字节流传输服务  \n对应传输层的TCP协议，提供面向连接的服务和可靠的数据传送服务。\n- 无连接的不可靠数据报传输服务  \n对应UDP，不提供传输服务保障的轻量级传输层协议，仅提供最小的尽力服务。\n\n但是这两种协议都不提供端到端吞吐量以及时延保障服务。  \n\n# 域名系统  \n用户使用网络应用时，需要通过指定的IP地址和端口号才能访问。这非常不利于记忆，所以人们就发明了域名，用来访问指定的服务器主机。  \n域名系统(DNS)可以将域名映射为IP地址。实现将域名映射成为IP地址的过程，称为域名解析。  \n\n## 层次化域名空间\nDNS为了实现高效的管理和查找，域名的结构由标点序列组成，各标号用点隔开  \n\n1. 国家顶级域名nTLD: cn(中国)，us(美国)  \n2. 通用顶级域名gTLD: com(公司和企业)，net(网络服务机构),org(非盈利性组织),edu(教育机构)，gov(政府部门结构)，mil(军事)，int(国际).  \n3. 基础结构域名: 只有一个，arpa,用于反向域名解析，因此又称反向域名  \n\n## 域名服务器\n\n1. 根域名服务器  \n最重要的域名服务器，在因特网上又13个不同ip地址的根域名服务器。从a开始，比如说a.rootservers.net  \n2. 顶级域名服务器  \n负责管理在该顶级域名服务器注册的所有二级域名  \n3. 权威域名服务器  \n负责一个区的域名服务器，保存该区的所有主机域名到IP地址的映射  \n\n## 域名解析过程\n1. 递归解析  \n2. 迭代解析  \n\n# 万维网应用\nweb应用操作简单，其按需浏览、图形化界面，主要包括web服务器、浏览器、超文件传输协议等。  \n\n## HTTP\nweb的应用层协议，定义浏览器如何向web服务器发送请求以及web服务器如何向浏览器进行反应。  \n\n- HTTP连接  \n1. 并行连接  \n2. 持久连接  \n\n- HTTP报文  \n\n## Cookie\n小型文本文件，为了辨别用户身份、进行会话跟踪而存储本地的消息。  \n\n# Internet电子邮件\n## 电子邮件结构\n- 邮件服务器  \n- 简单邮件传输协议(SMTP)\n- 用户代理\n- 邮件读取协议  \n\n## SMTP\n是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输。\n\n## 电子邮件格式于MIME\n\n## 邮件读取协议\n1. POP3  \n2. IMAP  \n3. HTTP  \n\n# FTP\n文件传送协议，是在互联上的两台不同主机间实现文件互传的网络应用  \n\n# socket网络编程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/自学网络原理的第一天.md","raw":"---\ntitle: 自学网络原理的第一天\ndate: 2019-10-06 18:53:53\ntags:\ncategories:\n---\n\n有趣的网络原理\n<!--more-->\n第二章：网络应用\n--------\n# 计算机网络应用体系结构 \n先来简单的介绍下有哪些体系结构  \n\n1. 客户/服务器(C/S)结构网络应用  \n(C/S)结构的网络应用最基本，最典型的网络应用。它需要服务器程序先运行，客户程序后运行并主动请求于服务器进行通信。  \n例如www应用，文件传输FTP、电子邮件等。  \n区别于其他的结构体系方法就是它的通信只在客户于服务器之间。\n\n2. 纯P2P结构网络应用结构  \n很明显，这是一个客户对客户的体系结构，P2P应用中的每个对等端都同时具备C/S应用的客户与服务的特征，是一个服务器与客户的结合体。  \n例如Gnurella、BitTorent等  \n在这里，我们已经认识到两种体系结构了，他们各自有优缺点，所以按照取长补短的原则就出现了混合型的体系结构(Ps:好像每次有这种结构啥的都有混合型)\n \n3. 混合结构网络应用  \n它既有中心服务器的存在，又有对等端间的直接通信。是C/S和P2P的结合。\n客户通过C/S方式想服务器注册自己的网络地址，然后就可以在中心服务器找到其他的客户共享资源或分享资源。\n\n# 网络应用通信基本原理  \n- 首先，网络应用的本质就是应用进程之间的通信。  \n- 基本通信方式是C/S通信。  \n- 应用进程之间遵循应用层协议交换应用层报文  \n- 应用层协议定义了语法、语序、语义三要素内容。\n- 按道理说，应该是应用层和应用层之间直接进行传输，但其实是应用层需要通过层间接口将报文发送给传输层，请求端到端传输服务。  \n- 编程接口是套接字，它是网络进程之间进行网络通信时，真正收发报文的通道。  \n- 对于传输层协议，我们需要为其接口的每个套接字编号，用来标识这个套接字，该编号就是端口号。  \n- 比如web服务器的默认端口号是80，是为熟知端口号\n- 每个应用层通过一个或多个套接字于传输层进行接口，因此，我们可以通过进程运行的主机ip地址和套接字绑定的端口号来标识应用进程。  \n\nInternet提供两种传输层协议  \n- 面向连接的可靠字节流传输服务  \n对应传输层的TCP协议，提供面向连接的服务和可靠的数据传送服务。\n- 无连接的不可靠数据报传输服务  \n对应UDP，不提供传输服务保障的轻量级传输层协议，仅提供最小的尽力服务。\n\n但是这两种协议都不提供端到端吞吐量以及时延保障服务。  \n\n# 域名系统  \n用户使用网络应用时，需要通过指定的IP地址和端口号才能访问。这非常不利于记忆，所以人们就发明了域名，用来访问指定的服务器主机。  \n域名系统(DNS)可以将域名映射为IP地址。实现将域名映射成为IP地址的过程，称为域名解析。  \n\n## 层次化域名空间\nDNS为了实现高效的管理和查找，域名的结构由标点序列组成，各标号用点隔开  \n\n1. 国家顶级域名nTLD: cn(中国)，us(美国)  \n2. 通用顶级域名gTLD: com(公司和企业)，net(网络服务机构),org(非盈利性组织),edu(教育机构)，gov(政府部门结构)，mil(军事)，int(国际).  \n3. 基础结构域名: 只有一个，arpa,用于反向域名解析，因此又称反向域名  \n\n## 域名服务器\n\n1. 根域名服务器  \n最重要的域名服务器，在因特网上又13个不同ip地址的根域名服务器。从a开始，比如说a.rootservers.net  \n2. 顶级域名服务器  \n负责管理在该顶级域名服务器注册的所有二级域名  \n3. 权威域名服务器  \n负责一个区的域名服务器，保存该区的所有主机域名到IP地址的映射  \n\n## 域名解析过程\n1. 递归解析  \n2. 迭代解析  \n\n# 万维网应用\nweb应用操作简单，其按需浏览、图形化界面，主要包括web服务器、浏览器、超文件传输协议等。  \n\n## HTTP\nweb的应用层协议，定义浏览器如何向web服务器发送请求以及web服务器如何向浏览器进行反应。  \n\n- HTTP连接  \n1. 并行连接  \n2. 持久连接  \n\n- HTTP报文  \n\n## Cookie\n小型文本文件，为了辨别用户身份、进行会话跟踪而存储本地的消息。  \n\n# Internet电子邮件\n## 电子邮件结构\n- 邮件服务器  \n- 简单邮件传输协议(SMTP)\n- 用户代理\n- 邮件读取协议  \n\n## SMTP\n是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输。\n\n## 电子邮件格式于MIME\n\n## 邮件读取协议\n1. POP3  \n2. IMAP  \n3. HTTP  \n\n# FTP\n文件传送协议，是在互联上的两台不同主机间实现文件互传的网络应用  \n\n# socket网络编程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"自学网络原理的第一天","published":1,"updated":"2019-10-26T14:46:34.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpuf001e7qsgc18se0ap","content":"<p>有趣的网络原理<br><a id=\"more\"></a></p>\n<h2 id=\"第二章：网络应用\"><a href=\"#第二章：网络应用\" class=\"headerlink\" title=\"第二章：网络应用\"></a>第二章：网络应用</h2><h1 id=\"计算机网络应用体系结构\"><a href=\"#计算机网络应用体系结构\" class=\"headerlink\" title=\"计算机网络应用体系结构\"></a>计算机网络应用体系结构</h1><p>先来简单的介绍下有哪些体系结构  </p>\n<ol>\n<li><p>客户/服务器(C/S)结构网络应用<br>(C/S)结构的网络应用最基本，最典型的网络应用。它需要服务器程序先运行，客户程序后运行并主动请求于服务器进行通信。<br>例如www应用，文件传输FTP、电子邮件等。<br>区别于其他的结构体系方法就是它的通信只在客户于服务器之间。</p>\n</li>\n<li><p>纯P2P结构网络应用结构<br>很明显，这是一个客户对客户的体系结构，P2P应用中的每个对等端都同时具备C/S应用的客户与服务的特征，是一个服务器与客户的结合体。<br>例如Gnurella、BitTorent等<br>在这里，我们已经认识到两种体系结构了，他们各自有优缺点，所以按照取长补短的原则就出现了混合型的体系结构(Ps:好像每次有这种结构啥的都有混合型)</p>\n</li>\n<li><p>混合结构网络应用<br>它既有中心服务器的存在，又有对等端间的直接通信。是C/S和P2P的结合。<br>客户通过C/S方式想服务器注册自己的网络地址，然后就可以在中心服务器找到其他的客户共享资源或分享资源。</p>\n</li>\n</ol>\n<h1 id=\"网络应用通信基本原理\"><a href=\"#网络应用通信基本原理\" class=\"headerlink\" title=\"网络应用通信基本原理\"></a>网络应用通信基本原理</h1><ul>\n<li>首先，网络应用的本质就是应用进程之间的通信。  </li>\n<li>基本通信方式是C/S通信。  </li>\n<li>应用进程之间遵循应用层协议交换应用层报文  </li>\n<li>应用层协议定义了语法、语序、语义三要素内容。</li>\n<li>按道理说，应该是应用层和应用层之间直接进行传输，但其实是应用层需要通过层间接口将报文发送给传输层，请求端到端传输服务。  </li>\n<li>编程接口是套接字，它是网络进程之间进行网络通信时，真正收发报文的通道。  </li>\n<li>对于传输层协议，我们需要为其接口的每个套接字编号，用来标识这个套接字，该编号就是端口号。  </li>\n<li>比如web服务器的默认端口号是80，是为熟知端口号</li>\n<li>每个应用层通过一个或多个套接字于传输层进行接口，因此，我们可以通过进程运行的主机ip地址和套接字绑定的端口号来标识应用进程。  </li>\n</ul>\n<p>Internet提供两种传输层协议  </p>\n<ul>\n<li>面向连接的可靠字节流传输服务<br>对应传输层的TCP协议，提供面向连接的服务和可靠的数据传送服务。</li>\n<li>无连接的不可靠数据报传输服务<br>对应UDP，不提供传输服务保障的轻量级传输层协议，仅提供最小的尽力服务。</li>\n</ul>\n<p>但是这两种协议都不提供端到端吞吐量以及时延保障服务。  </p>\n<h1 id=\"域名系统\"><a href=\"#域名系统\" class=\"headerlink\" title=\"域名系统\"></a>域名系统</h1><p>用户使用网络应用时，需要通过指定的IP地址和端口号才能访问。这非常不利于记忆，所以人们就发明了域名，用来访问指定的服务器主机。<br>域名系统(DNS)可以将域名映射为IP地址。实现将域名映射成为IP地址的过程，称为域名解析。  </p>\n<h2 id=\"层次化域名空间\"><a href=\"#层次化域名空间\" class=\"headerlink\" title=\"层次化域名空间\"></a>层次化域名空间</h2><p>DNS为了实现高效的管理和查找，域名的结构由标点序列组成，各标号用点隔开  </p>\n<ol>\n<li>国家顶级域名nTLD: cn(中国)，us(美国)  </li>\n<li>通用顶级域名gTLD: com(公司和企业)，net(网络服务机构),org(非盈利性组织),edu(教育机构)，gov(政府部门结构)，mil(军事)，int(国际).  </li>\n<li>基础结构域名: 只有一个，arpa,用于反向域名解析，因此又称反向域名  </li>\n</ol>\n<h2 id=\"域名服务器\"><a href=\"#域名服务器\" class=\"headerlink\" title=\"域名服务器\"></a>域名服务器</h2><ol>\n<li>根域名服务器<br>最重要的域名服务器，在因特网上又13个不同ip地址的根域名服务器。从a开始，比如说a.rootservers.net  </li>\n<li>顶级域名服务器<br>负责管理在该顶级域名服务器注册的所有二级域名  </li>\n<li>权威域名服务器<br>负责一个区的域名服务器，保存该区的所有主机域名到IP地址的映射  </li>\n</ol>\n<h2 id=\"域名解析过程\"><a href=\"#域名解析过程\" class=\"headerlink\" title=\"域名解析过程\"></a>域名解析过程</h2><ol>\n<li>递归解析  </li>\n<li>迭代解析  </li>\n</ol>\n<h1 id=\"万维网应用\"><a href=\"#万维网应用\" class=\"headerlink\" title=\"万维网应用\"></a>万维网应用</h1><p>web应用操作简单，其按需浏览、图形化界面，主要包括web服务器、浏览器、超文件传输协议等。  </p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>web的应用层协议，定义浏览器如何向web服务器发送请求以及web服务器如何向浏览器进行反应。  </p>\n<ul>\n<li>HTTP连接  </li>\n</ul>\n<ol>\n<li>并行连接  </li>\n<li>持久连接  </li>\n</ol>\n<ul>\n<li>HTTP报文  </li>\n</ul>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p>小型文本文件，为了辨别用户身份、进行会话跟踪而存储本地的消息。  </p>\n<h1 id=\"Internet电子邮件\"><a href=\"#Internet电子邮件\" class=\"headerlink\" title=\"Internet电子邮件\"></a>Internet电子邮件</h1><h2 id=\"电子邮件结构\"><a href=\"#电子邮件结构\" class=\"headerlink\" title=\"电子邮件结构\"></a>电子邮件结构</h2><ul>\n<li>邮件服务器  </li>\n<li>简单邮件传输协议(SMTP)</li>\n<li>用户代理</li>\n<li>邮件读取协议  </li>\n</ul>\n<h2 id=\"SMTP\"><a href=\"#SMTP\" class=\"headerlink\" title=\"SMTP\"></a>SMTP</h2><p>是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输。</p>\n<h2 id=\"电子邮件格式于MIME\"><a href=\"#电子邮件格式于MIME\" class=\"headerlink\" title=\"电子邮件格式于MIME\"></a>电子邮件格式于MIME</h2><h2 id=\"邮件读取协议\"><a href=\"#邮件读取协议\" class=\"headerlink\" title=\"邮件读取协议\"></a>邮件读取协议</h2><ol>\n<li>POP3  </li>\n<li>IMAP  </li>\n<li>HTTP  </li>\n</ol>\n<h1 id=\"FTP\"><a href=\"#FTP\" class=\"headerlink\" title=\"FTP\"></a>FTP</h1><p>文件传送协议，是在互联上的两台不同主机间实现文件互传的网络应用  </p>\n<h1 id=\"socket网络编程\"><a href=\"#socket网络编程\" class=\"headerlink\" title=\"socket网络编程\"></a>socket网络编程</h1>","site":{"data":{}},"excerpt":"<p>有趣的网络原理<br></p>","more":"<p></p>\n<h2 id=\"第二章：网络应用\"><a href=\"#第二章：网络应用\" class=\"headerlink\" title=\"第二章：网络应用\"></a>第二章：网络应用</h2><h1 id=\"计算机网络应用体系结构\"><a href=\"#计算机网络应用体系结构\" class=\"headerlink\" title=\"计算机网络应用体系结构\"></a>计算机网络应用体系结构</h1><p>先来简单的介绍下有哪些体系结构  </p>\n<ol>\n<li><p>客户/服务器(C/S)结构网络应用<br>(C/S)结构的网络应用最基本，最典型的网络应用。它需要服务器程序先运行，客户程序后运行并主动请求于服务器进行通信。<br>例如www应用，文件传输FTP、电子邮件等。<br>区别于其他的结构体系方法就是它的通信只在客户于服务器之间。</p>\n</li>\n<li><p>纯P2P结构网络应用结构<br>很明显，这是一个客户对客户的体系结构，P2P应用中的每个对等端都同时具备C/S应用的客户与服务的特征，是一个服务器与客户的结合体。<br>例如Gnurella、BitTorent等<br>在这里，我们已经认识到两种体系结构了，他们各自有优缺点，所以按照取长补短的原则就出现了混合型的体系结构(Ps:好像每次有这种结构啥的都有混合型)</p>\n</li>\n<li><p>混合结构网络应用<br>它既有中心服务器的存在，又有对等端间的直接通信。是C/S和P2P的结合。<br>客户通过C/S方式想服务器注册自己的网络地址，然后就可以在中心服务器找到其他的客户共享资源或分享资源。</p>\n</li>\n</ol>\n<h1 id=\"网络应用通信基本原理\"><a href=\"#网络应用通信基本原理\" class=\"headerlink\" title=\"网络应用通信基本原理\"></a>网络应用通信基本原理</h1><ul>\n<li>首先，网络应用的本质就是应用进程之间的通信。  </li>\n<li>基本通信方式是C/S通信。  </li>\n<li>应用进程之间遵循应用层协议交换应用层报文  </li>\n<li>应用层协议定义了语法、语序、语义三要素内容。</li>\n<li>按道理说，应该是应用层和应用层之间直接进行传输，但其实是应用层需要通过层间接口将报文发送给传输层，请求端到端传输服务。  </li>\n<li>编程接口是套接字，它是网络进程之间进行网络通信时，真正收发报文的通道。  </li>\n<li>对于传输层协议，我们需要为其接口的每个套接字编号，用来标识这个套接字，该编号就是端口号。  </li>\n<li>比如web服务器的默认端口号是80，是为熟知端口号</li>\n<li>每个应用层通过一个或多个套接字于传输层进行接口，因此，我们可以通过进程运行的主机ip地址和套接字绑定的端口号来标识应用进程。  </li>\n</ul>\n<p>Internet提供两种传输层协议  </p>\n<ul>\n<li>面向连接的可靠字节流传输服务<br>对应传输层的TCP协议，提供面向连接的服务和可靠的数据传送服务。</li>\n<li>无连接的不可靠数据报传输服务<br>对应UDP，不提供传输服务保障的轻量级传输层协议，仅提供最小的尽力服务。</li>\n</ul>\n<p>但是这两种协议都不提供端到端吞吐量以及时延保障服务。  </p>\n<h1 id=\"域名系统\"><a href=\"#域名系统\" class=\"headerlink\" title=\"域名系统\"></a>域名系统</h1><p>用户使用网络应用时，需要通过指定的IP地址和端口号才能访问。这非常不利于记忆，所以人们就发明了域名，用来访问指定的服务器主机。<br>域名系统(DNS)可以将域名映射为IP地址。实现将域名映射成为IP地址的过程，称为域名解析。  </p>\n<h2 id=\"层次化域名空间\"><a href=\"#层次化域名空间\" class=\"headerlink\" title=\"层次化域名空间\"></a>层次化域名空间</h2><p>DNS为了实现高效的管理和查找，域名的结构由标点序列组成，各标号用点隔开  </p>\n<ol>\n<li>国家顶级域名nTLD: cn(中国)，us(美国)  </li>\n<li>通用顶级域名gTLD: com(公司和企业)，net(网络服务机构),org(非盈利性组织),edu(教育机构)，gov(政府部门结构)，mil(军事)，int(国际).  </li>\n<li>基础结构域名: 只有一个，arpa,用于反向域名解析，因此又称反向域名  </li>\n</ol>\n<h2 id=\"域名服务器\"><a href=\"#域名服务器\" class=\"headerlink\" title=\"域名服务器\"></a>域名服务器</h2><ol>\n<li>根域名服务器<br>最重要的域名服务器，在因特网上又13个不同ip地址的根域名服务器。从a开始，比如说a.rootservers.net  </li>\n<li>顶级域名服务器<br>负责管理在该顶级域名服务器注册的所有二级域名  </li>\n<li>权威域名服务器<br>负责一个区的域名服务器，保存该区的所有主机域名到IP地址的映射  </li>\n</ol>\n<h2 id=\"域名解析过程\"><a href=\"#域名解析过程\" class=\"headerlink\" title=\"域名解析过程\"></a>域名解析过程</h2><ol>\n<li>递归解析  </li>\n<li>迭代解析  </li>\n</ol>\n<h1 id=\"万维网应用\"><a href=\"#万维网应用\" class=\"headerlink\" title=\"万维网应用\"></a>万维网应用</h1><p>web应用操作简单，其按需浏览、图形化界面，主要包括web服务器、浏览器、超文件传输协议等。  </p>\n<h2 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h2><p>web的应用层协议，定义浏览器如何向web服务器发送请求以及web服务器如何向浏览器进行反应。  </p>\n<ul>\n<li>HTTP连接  </li>\n</ul>\n<ol>\n<li>并行连接  </li>\n<li>持久连接  </li>\n</ol>\n<ul>\n<li>HTTP报文  </li>\n</ul>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p>小型文本文件，为了辨别用户身份、进行会话跟踪而存储本地的消息。  </p>\n<h1 id=\"Internet电子邮件\"><a href=\"#Internet电子邮件\" class=\"headerlink\" title=\"Internet电子邮件\"></a>Internet电子邮件</h1><h2 id=\"电子邮件结构\"><a href=\"#电子邮件结构\" class=\"headerlink\" title=\"电子邮件结构\"></a>电子邮件结构</h2><ul>\n<li>邮件服务器  </li>\n<li>简单邮件传输协议(SMTP)</li>\n<li>用户代理</li>\n<li>邮件读取协议  </li>\n</ul>\n<h2 id=\"SMTP\"><a href=\"#SMTP\" class=\"headerlink\" title=\"SMTP\"></a>SMTP</h2><p>是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输。</p>\n<h2 id=\"电子邮件格式于MIME\"><a href=\"#电子邮件格式于MIME\" class=\"headerlink\" title=\"电子邮件格式于MIME\"></a>电子邮件格式于MIME</h2><h2 id=\"邮件读取协议\"><a href=\"#邮件读取协议\" class=\"headerlink\" title=\"邮件读取协议\"></a>邮件读取协议</h2><ol>\n<li>POP3  </li>\n<li>IMAP  </li>\n<li>HTTP  </li>\n</ol>\n<h1 id=\"FTP\"><a href=\"#FTP\" class=\"headerlink\" title=\"FTP\"></a>FTP</h1><p>文件传送协议，是在互联上的两台不同主机间实现文件互传的网络应用  </p>\n<h1 id=\"socket网络编程\"><a href=\"#socket网络编程\" class=\"headerlink\" title=\"socket网络编程\"></a>socket网络编程</h1>"},{"title":"计算机网络安全原理_笔记","date":"2019-08-19T23:55:20.000Z","_content":"\n11111\n<!--more-->\n\n# 网络基本原理\n\n1. 为什么需要计算机网络?  \n\n因为我们计算机之间需要进行快速、大量的信息交换。因此，在技术范畴来看，计算机网络是计算机技术与通信技术相互融合的产物。\n\n2. 简短、概括性的计算机网络定义  \n\n计算机网络是互连的、自治的计算机的集合。\n\n自治  是指互联的计算机系统是各自独立的\n\n互连  是指利用通信链路链接相互独立的计算机系统。\n\n3. 最大、应用最广泛的计算机网络\n\nInternet是由很多网络互联而构成的全球性网络;\nnternet是由很多网络互联而构成的全球性网络nternet是由很多网络互联而构成的全球性网络\n计算机网络设备通过有线或者无线方式连接服务提供商(ISP)网络，进而接入Internet。\n\n连接到Internet上的计算机设备都被称为主机或者端系统。  \n\nInternet的网络连接：小型家用网络连接本地ISP或者区域ISP网络。然后再与规模更大的国家级网络互连，国家ISP再互连其他国家ISP或者全球性ISP，实现全球所有ISP网络的互连。\n\n4. ISP网络  \n\n由许多有线或者无线通信链路互连分组交换设备构成。\n\n分组交换设备可以实现数据分组的接受与转发，是构成Internet的重要基础，存在多种形式，最典型的是交换机和路由器。\n\n#  网络协议  \n\n计算机网络中的实体在进行数据交换的过程中必须遵守的一些规则或约定。\n\n概括地说，协议约定了实体之间交换的信息类型、信息各部分的含义、信息交换顺序以及收到特定信息或出现异常时应采取的行为。\n\n协议三要素\n\n- 语法：实体之间交换信息的格式与结构  \n\n- 语义：实体之间交换的信息除了需要传输的数据外，通常还包括其他控制信息;语义就是定义了需要发送哪些控制信息，这些控制信息的含义，以及针对不同的控制信息，接受端如何响应。\n\n- 时序：又称为同步，定义了实体之间交换信息的顺序及如何匹配或适应彼此的速度。\n\n# 计算机网络的功能  \n\n通过信息交换，计算机网络可实现资源共享这一核心功能。  \n\n1. 硬件资源共享  \n\n一台主机可以共享另一台主机上的硬件资源，包括CPU、存储资源、打印机、扫描仪I/O设备等 \n\n实例：云计算机和云存储可以提供硬件计算资源和存储资源的共享。\n\n2. 软件资源共享 \n\n网络上的主机可以远程访问、使用服务器计算机上运行的各类大型软件。  \n\nSaaS：通过互联网提供软件服务。\n\n3. 信息资源共享  \n\n即我们在互联网上查看新闻，资料。\n\n计算机网络支持的信息交换就是典型的信息共享。  \n\n# 计算机网络的分类 \n\n## 按覆盖范围分类\n\n1. 个域网(PAN)  \n\n由个人设备通过无线通信技术构成小范围的网络，实现个人设备之间的数据传输。\n\n覆盖范围1-10 m\n\n2. 局域网（LAN）  \n\n通常使用在校园，办公楼等局部区域，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。\n\n覆盖范围1-10 km\n\n3. 城域网(MAN)  \n\n覆盖一个城市的网络。\n\n覆盖范围5-50 km  \n\n4. 广域网(WAN)  \n\n跨越更大的地理空间，可以实现异地局域网或局域网的互连。\n\n覆盖范围几十到几千千米  \n\n## 按拓扑(tuo pu)结构分类\n\n什么是网络拓扑？  \n\n网络中的主机、网络设备间的物理连接关系与布局。\n\n1. 星型拓扑结构  \n\n星型拓扑结构网络中包括一个中央节点网络中的主机通过点对点通信链路与中央节点连接。\n\n中央节点通常是集线器、交换机等设备。\n\n多见于局域网、个域网中\n\n优点：易于监控与管理，故障诊断与隔离容易。\n\n缺点：中央节点是网络的瓶颈，一旦故障，全网瘫痪，网络规模受限于中央节点的端口数量。\n\n2. 总线型拓扑结构  \n\n总线型拓扑结构网络采用一条广播信号作为公共传输介质，称为总线，所有结点均与总线连接\n\n在任一节点发送信息，其他节点都会接收到这些信息的信号。\n\n多见于早期的局域网  \n\n优点：结构简单，易于扩展，所需电缆数量少。\n\n缺点：通信范围受限，故障诊断与隔离比较困难，容易产生冲突。\n\n3. 环形拓扑结构  \n\n利用通信链路将所有节点连接成一个闭合的环。\n\n优点：所需电缆长度短，可以使用光纤，易于避免冲突。\n\n缺点：某节点的故障容易导致全局瘫痪，节点的加入或撤出过程比较麻烦，存在等待时间问题。\n\n4. 网状拓扑结构  \n\n通过多条链路与不同的节点直接连接。\n\n多见于广域网、核心网络。\n\n优点：网络可靠性高，一条或多条链路故障时，网络仍然可联通。   \n\n缺点：网络结构复杂，造价成本高，选路协议复杂。\n\n5. 树形拓扑结构  \n\n总线型或是星型的扩展  \n\n很多局域网采用这种结构  \n\n优点：易于扩展，故障隔离容易。\n\n缺点：对根节点的可靠要求性很高，一旦根节点故障，可能导致网络大范围无法通信。\n\n6. 混合拓扑结构  \n\n两种以上的简单拓扑结构混合连接而成的网络。\n\n绝大多数实际网络都属于混合拓扑结构，比如Internet。\n\n优点：易于扩展，可以构建不同规模的网络，并可根据需要优选网络结构。\n\n缺点：网络结构复杂，管理与维护复杂。\n\n## 按交换方式分类  \n\n什么是数据交换？\n\n网络通过彼此互连的结点间数据转接，实现将数据从发送结点送达目的结点的过程和技术。  \n\n可分为电路交换网络、报文交换网络和分组交换网络。  \n\n## 按网络用户属性分类  \n\n1. 公用网  \n\n由国家或企业出资建设，面向公众提供收费或免费的网络。\n\n比如电信企业、Internet等\n\n2. 私有网  \n\n不向公众开放的网络。\n\n比如军用网络铁路专用网络等。\n\n# 计算机网络结构  \n\n## 网络边缘  \n\n连接到网络上的所有端系统构成了网络边缘。  \n\n普通网络用户就是在网络边缘通过网络应用，实现在网络边缘的端系统之间信息交换，因此，可以说网络边缘为网络用户提供了网络应用服务。\n\n## 接入网络  \n\n接入网络实现网络边缘的端系统与网络核心连接与接入的网络。\n\n1. 电话拨号接入  \n\n利用电话网络，模拟数字电路传送到远端。  \n\n最大带宽通常为56kbit/s\n\n2. 非对称用户线路ADSL  \n\n利用现有的电话网络的用户路线接入网络\n\n基于频分多路复用(FDM)技术实现电话语音通信与数字通信共享一条用户路线。\n\n之所以成为“非对称”，是因为ADSL接入网络中，在用户线路实现上行带宽(上传速度)比下行带宽(下载速度)小。\n\n用户线路长度为3～5km内，典型的上行带宽为512kbit/s～1Mbit/s，下行宽带为1~8Mbit/s  \n\n用户线路长度为1.3km以内，上行达到19.2Mbit/s，下行为55Mbit/s。\n\n3. 混合光纤同轴电缆HFC接入网路\n\n利用有线电视网络实现网络接入的技术\n\n上行带宽30.7Mbit/s，下行带宽为42.8Mbit/s。\n\nHFC接入没有ADSL接入速率快，因为ADSL是独享式接入，HFC是利用同轴电缆共享式接入。\n\n4. 局域网  \n\n企业、学校内建设局域网，连接所有需要接入外部网络的主机，然后通过企业网络或学校网的边缘路由器连接网络核心。  \n\n局域网技术是以太网、Wi-Fi等。\n\n5. 移动接入网络  \n\n利用移动通信网络，实现智能手机、移动终端等设备的网络接入。\n\n## 网络核心  \n\n由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继与转发。\n\n比较典型的分组交换设备是路由器和交换机等。\n\n# 数据交换技术\n\n为了连接更大范围、更多数量的主机，将交换设备互连，构成一个数据中继与转发的中间网络，然后在将主机链接到距离较近的交换设备上，主机之间通过中间网络实现中继和转发。\n\n这个中间网络不需要关心所传的数据内容，而只是为了为这些数据从一个节点到另一个节点直至到达目的提供数据与交换的功能，称之为数据交换网路。\n\n组成交换网路的节点称之为交换节点，交换节点和传输介质的集合为通信子网。\n\n数据交换是实现在大规模网络核心上进行网路传输的技术基础。\n\n## 电路交换  \n\n首先需要中间交换节点为两台主机之间建立一条专用的通信线路，称为电路，然后再利用该电路进行通信，通信结束后在拆除电路。\n\n利用电路交换通信包括建立电路，交换数据，拆除电路三个阶段。\n\n优点是实时性高，时延和时延抖动都较小。\n\n缺点是对于突发性数据传输，通信利用率低，且传输速率单一。\n\n## 报文交换  \n\n发送方把要发送的信息附加上发送/接受主机的地址及其他控制信息，构成一个完整的报文，然后以报文为单位在交换网路的各结点之间以存储-转发的方式传送，直至送达目的主机。  \n\n## 分组交换  \n\n需要将待传输的数据分割成较小的数据快，每个数据块附加上地址、讯号等控制信息构成数据分组，每个分组独立传输到目的地，目的地将收到的分组重新组装，还原为报文。\n\n采用存储-转发交换方式，与报文交换的主要区别在于是否拆分报文。\n\n优点：\n\n1. 交换设备存储容量要求低\n\n2. 交换速度快  \n\n3. 可靠传输速率高  \n\n4. 更加公平  \n\n## 分组长度的确定  \n  \n1. 分组长度与延迟时间  \n\n分组交换网络的存储-转发过程可以抽象为一个排队系统，基于排队论的分析发现，当分组具有相同的长度时，分组在交换过程中的延迟时间较小。\n\n2. 分组长度与误码率  \n\n通信链路的信道误码率是确定分组长度另外一个需要重点考虑的因素。设分组长度为L位，其中h位为分组头长度，数据长度为x位   x+h=L\n\n若信道误码率为\n\n# 计算机性能的主要性能指标  \n\n1. 速率与带宽  \n\n速率指网络单位内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率。\n\n计算机网络以位为传输单位，所以用bit/s表示基本单位。\n\n2. 时延  \n\n数据从网络中的一个结点到达另一个结点的时间。\n\n- 结点处理延迟  \n\n验证是否有差错，如何转发，还有可能修改部分控制信息。  \n\n- 排队时延  \n\n在该分组前有相同链路在进行传输时，分组要在交换节点进行暂时缓存，排队等待输出链路可用。\n\n- 传输时延  \n\n从发送第一位开始，到发送完最后一位的时间。\n\n- 传播时延  \n\n信号从发送端发送出来，经过一定距离的物理链路到达接收端的时间。  \n\n3. 时延带宽积  \n\n一段物理链路的传播时延于链路带宽的乘积  \n\n4. 丢包率  \n\n用于评价和衡量网络性能的指标，在很大程度上可以反映网络的拥塞程度，因为引发网络丢包的主要因素是网络拥塞。  \n\n5. 吞吐量  \n\n表示在单位时间内源主机通过网络向目的主机实际送达的数据量，单位为bit/s或B/s（字节/秒），记为Thr。吞吐量经常用于度量网络的实际数据传送能力，即网络实际可以达到的源主机到目的主机的数据传送速率。\n\n公式图  \n\n![](计算机网络安全原理-笔记/2.jpg)\n![](计算机网络安全原理-笔记/3.jpg)\n![](计算机网络安全原理-笔记/1.jpg)\n\n# 计算机网络体系结构与参考模型  \n\n## 计算机网络体系结构  \n\n计算机网路经常采用的思路是将复杂的网络通信功能划分为协议分别完成，然后将这些协议按照一定的方式组织起来，实现网络通信所有功能。\n\n最典型的是分层划分，核心思路是上一层的功能建立在下一层的功能基础上，并且在每一层均要遵守协议。\n\nIBM公司1974年提出SNA（系统网络体系结构）\n\n## OSI参考模型  \n\n采用分层结构化技术，一共分为7层。  \n\n协议数据单元 == PDU\n\n1. 物理层  \n\n主要功能是在传输介质上实现无结构比特流传输。另一项主要任务就是规定数据终端设备与数据通信设备之间的相关特性，主要包括机械、电气、功能和规程4方面特性。\n\n无结构是指不关心比特流代表的信息，只关心一合适的信号传送到目的地。\n\n2. 数据链路层  \n\n主要功能实现在相邻节点之间数据可靠而有效的传输。  \n\n另外一项重要功能就是寻址，用来确保每一帧都能准确地传送到正确的接受方。\n\n为了能实现有效的差错控制，采用一种以`帧`为单元的数据快传输方式。要采用帧格式传输，就必须有相应的帧同步技术，即“成帧”（帧同步）功能，包括定义帧的格式、类型、成帧的方法等。  \n\n3. 网络层  \n\n网络层解决的核心问题是如何将分组通过交换网络传送之目的地，因此，主要功能是数据转发与路由。\n\n在交换网络中，信息从源结点出发，经过若干中继结点存储转发后，才能到达目的结点称为从源结点到目的结点的路径。\n\n网络层要对进入交换网络的通信量进行控制，避免通信量过大造成交换网络性能下降。\n\n网络层也具备寻址功能，确保分组可以被正确的传输到目的主机。\n\n4. 传输层  \n\n传输层是第一个端到端的层次，也是一个进程-进程的层次，数据的通信实质是发生在两个主机的进程之间。\n\n主要功能包括复用/分解（分区发送和接受主机上的进程）、端到端的可靠数据传输、连接控制、流量控制和拥塞控制机制等。\n\n5. 会话层  \n\n指用户与用户的连接，通过两台计算机建立、管理和终止通信来完成对话。\n\n主要功能包括在建立会话时核实双方身份是否有权参加会话;确定双方支付通信费用;双方在各种选择功能方面取得一致;在会话建立以后，需要对进程间的对话进行管理和控制。\n\n6. 表示层  \n\n主要用于处理应用实体之间的交换数据的语法，其目的是解决格式和数据表示的差别，从而为应用提供一致的数据格式，使字符、格式等有差异的设备之间相互通信。\n\n表示层还可以实现文本压缩/解压缩、数据加密/解密、字符编码的转换等功能。  \n\n7. 应用层  \n\n提供给用户网络服务，包括文件传送、电子邮件、P2P应用等。为用户提供一个使用网络应用的接口。\n\n- 数据单元(PDU)\n\n物理层称为流或比特流，在数据链路称为帧，在网络层称为分组或包、在传输层称为数据段或报文段，在应用层称为报文等。\n\n- 服务访问点  \n\n相邻层间的服务通过其接口上的服务访问点(SAP)进行的，N层SAP就是N+1层可以访问N层的地方。\n\n每个SAP都有唯一的地址号码  \n\n- 服务原语  \n\n相邻层间提供服务都是用一组原语来描述的。\n\n1. 请求：用户实体请求服务做某种工作。\n\n2. 指示：用户实体被告知某件事发生。\n\n3. 响应：用户实体表示对某件事的响应。\n\n4. 证实：用户实体收到关于它的请求的答复。\n\n## 面向连接和无连接的服务  \n\n1. 面向连接  \n\n以电话系统最为典型。第一步：建立连接;第二步：传送数据;第三步：结束之后拆除链路。\n\n2. 面向无连接  \n\n没有建立和拆除链路的过程  \n\n又称数据报服务，要求每一个分组信息带有全称地址、独立选择路径，其到达目的地的顺序也是不定的，到底目的地后，还要重新对分组排序。\n\n## TCP/IP参考模型  \n\n1. 应用层  \n\n将OSI中会话层和表示层的功能合并到了应用层来实现。\n\n用户通过应用层使用Internet提供的各种服务。每一种应用使用相应协议将用户数据按照协议的格式封装，达到对应的控制功能，然后利用下一层协议进行传输。\n\n例如：WWW服务的HTTP、文件传输的FTP、电子邮件的SMTP和POP3等，每一个应用层协议都会用到两个传输层协议之一进行数据传输：面向连接的传输控制协议TCP和无连接用户数据报协议UDP。\n\n2. 传输层  \n\n负责将应用层封装好的这些数据传输到对方主机上对等的应用层程序。  \n\n传输层主要包括面向连接、提供可靠数据流传输的传输控制协议TCP和无连接不提供可靠数据流传输的用户数据报协议UDP。  \n\n3. 网络互联层  \n\n主要解决把数据分组发往目的网络或主机的问题，网络互联层是整个TCP/IP参考模型的核心  \n\n网络互联层还包括互联网控制报文协议的ICMP、互联网多播组管理协议IGMP以及路由协议，如BGP\\OSPE\\RIP。  \n\n4. 网络接口层  \n\n实际上，这一层对应OSI参考模型中的数据链路层和物理层，网络层IP分组在这一层封装到链路层数据帧中，并最终以比特流的形式在物理介质上进行传输。  \n\n## 五层参考模型  \n\n物理层、数据链路层、网络层、传输层、应用层。  \n","source":"_posts/计算机网络安全原理-笔记.md","raw":"---\ntitle: 计算机网络安全原理_笔记\ndate: 2019-08-20 07:55:20\ntags:\ncategories:\n---\n\n11111\n<!--more-->\n\n# 网络基本原理\n\n1. 为什么需要计算机网络?  \n\n因为我们计算机之间需要进行快速、大量的信息交换。因此，在技术范畴来看，计算机网络是计算机技术与通信技术相互融合的产物。\n\n2. 简短、概括性的计算机网络定义  \n\n计算机网络是互连的、自治的计算机的集合。\n\n自治  是指互联的计算机系统是各自独立的\n\n互连  是指利用通信链路链接相互独立的计算机系统。\n\n3. 最大、应用最广泛的计算机网络\n\nInternet是由很多网络互联而构成的全球性网络;\nnternet是由很多网络互联而构成的全球性网络nternet是由很多网络互联而构成的全球性网络\n计算机网络设备通过有线或者无线方式连接服务提供商(ISP)网络，进而接入Internet。\n\n连接到Internet上的计算机设备都被称为主机或者端系统。  \n\nInternet的网络连接：小型家用网络连接本地ISP或者区域ISP网络。然后再与规模更大的国家级网络互连，国家ISP再互连其他国家ISP或者全球性ISP，实现全球所有ISP网络的互连。\n\n4. ISP网络  \n\n由许多有线或者无线通信链路互连分组交换设备构成。\n\n分组交换设备可以实现数据分组的接受与转发，是构成Internet的重要基础，存在多种形式，最典型的是交换机和路由器。\n\n#  网络协议  \n\n计算机网络中的实体在进行数据交换的过程中必须遵守的一些规则或约定。\n\n概括地说，协议约定了实体之间交换的信息类型、信息各部分的含义、信息交换顺序以及收到特定信息或出现异常时应采取的行为。\n\n协议三要素\n\n- 语法：实体之间交换信息的格式与结构  \n\n- 语义：实体之间交换的信息除了需要传输的数据外，通常还包括其他控制信息;语义就是定义了需要发送哪些控制信息，这些控制信息的含义，以及针对不同的控制信息，接受端如何响应。\n\n- 时序：又称为同步，定义了实体之间交换信息的顺序及如何匹配或适应彼此的速度。\n\n# 计算机网络的功能  \n\n通过信息交换，计算机网络可实现资源共享这一核心功能。  \n\n1. 硬件资源共享  \n\n一台主机可以共享另一台主机上的硬件资源，包括CPU、存储资源、打印机、扫描仪I/O设备等 \n\n实例：云计算机和云存储可以提供硬件计算资源和存储资源的共享。\n\n2. 软件资源共享 \n\n网络上的主机可以远程访问、使用服务器计算机上运行的各类大型软件。  \n\nSaaS：通过互联网提供软件服务。\n\n3. 信息资源共享  \n\n即我们在互联网上查看新闻，资料。\n\n计算机网络支持的信息交换就是典型的信息共享。  \n\n# 计算机网络的分类 \n\n## 按覆盖范围分类\n\n1. 个域网(PAN)  \n\n由个人设备通过无线通信技术构成小范围的网络，实现个人设备之间的数据传输。\n\n覆盖范围1-10 m\n\n2. 局域网（LAN）  \n\n通常使用在校园，办公楼等局部区域，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。\n\n覆盖范围1-10 km\n\n3. 城域网(MAN)  \n\n覆盖一个城市的网络。\n\n覆盖范围5-50 km  \n\n4. 广域网(WAN)  \n\n跨越更大的地理空间，可以实现异地局域网或局域网的互连。\n\n覆盖范围几十到几千千米  \n\n## 按拓扑(tuo pu)结构分类\n\n什么是网络拓扑？  \n\n网络中的主机、网络设备间的物理连接关系与布局。\n\n1. 星型拓扑结构  \n\n星型拓扑结构网络中包括一个中央节点网络中的主机通过点对点通信链路与中央节点连接。\n\n中央节点通常是集线器、交换机等设备。\n\n多见于局域网、个域网中\n\n优点：易于监控与管理，故障诊断与隔离容易。\n\n缺点：中央节点是网络的瓶颈，一旦故障，全网瘫痪，网络规模受限于中央节点的端口数量。\n\n2. 总线型拓扑结构  \n\n总线型拓扑结构网络采用一条广播信号作为公共传输介质，称为总线，所有结点均与总线连接\n\n在任一节点发送信息，其他节点都会接收到这些信息的信号。\n\n多见于早期的局域网  \n\n优点：结构简单，易于扩展，所需电缆数量少。\n\n缺点：通信范围受限，故障诊断与隔离比较困难，容易产生冲突。\n\n3. 环形拓扑结构  \n\n利用通信链路将所有节点连接成一个闭合的环。\n\n优点：所需电缆长度短，可以使用光纤，易于避免冲突。\n\n缺点：某节点的故障容易导致全局瘫痪，节点的加入或撤出过程比较麻烦，存在等待时间问题。\n\n4. 网状拓扑结构  \n\n通过多条链路与不同的节点直接连接。\n\n多见于广域网、核心网络。\n\n优点：网络可靠性高，一条或多条链路故障时，网络仍然可联通。   \n\n缺点：网络结构复杂，造价成本高，选路协议复杂。\n\n5. 树形拓扑结构  \n\n总线型或是星型的扩展  \n\n很多局域网采用这种结构  \n\n优点：易于扩展，故障隔离容易。\n\n缺点：对根节点的可靠要求性很高，一旦根节点故障，可能导致网络大范围无法通信。\n\n6. 混合拓扑结构  \n\n两种以上的简单拓扑结构混合连接而成的网络。\n\n绝大多数实际网络都属于混合拓扑结构，比如Internet。\n\n优点：易于扩展，可以构建不同规模的网络，并可根据需要优选网络结构。\n\n缺点：网络结构复杂，管理与维护复杂。\n\n## 按交换方式分类  \n\n什么是数据交换？\n\n网络通过彼此互连的结点间数据转接，实现将数据从发送结点送达目的结点的过程和技术。  \n\n可分为电路交换网络、报文交换网络和分组交换网络。  \n\n## 按网络用户属性分类  \n\n1. 公用网  \n\n由国家或企业出资建设，面向公众提供收费或免费的网络。\n\n比如电信企业、Internet等\n\n2. 私有网  \n\n不向公众开放的网络。\n\n比如军用网络铁路专用网络等。\n\n# 计算机网络结构  \n\n## 网络边缘  \n\n连接到网络上的所有端系统构成了网络边缘。  \n\n普通网络用户就是在网络边缘通过网络应用，实现在网络边缘的端系统之间信息交换，因此，可以说网络边缘为网络用户提供了网络应用服务。\n\n## 接入网络  \n\n接入网络实现网络边缘的端系统与网络核心连接与接入的网络。\n\n1. 电话拨号接入  \n\n利用电话网络，模拟数字电路传送到远端。  \n\n最大带宽通常为56kbit/s\n\n2. 非对称用户线路ADSL  \n\n利用现有的电话网络的用户路线接入网络\n\n基于频分多路复用(FDM)技术实现电话语音通信与数字通信共享一条用户路线。\n\n之所以成为“非对称”，是因为ADSL接入网络中，在用户线路实现上行带宽(上传速度)比下行带宽(下载速度)小。\n\n用户线路长度为3～5km内，典型的上行带宽为512kbit/s～1Mbit/s，下行宽带为1~8Mbit/s  \n\n用户线路长度为1.3km以内，上行达到19.2Mbit/s，下行为55Mbit/s。\n\n3. 混合光纤同轴电缆HFC接入网路\n\n利用有线电视网络实现网络接入的技术\n\n上行带宽30.7Mbit/s，下行带宽为42.8Mbit/s。\n\nHFC接入没有ADSL接入速率快，因为ADSL是独享式接入，HFC是利用同轴电缆共享式接入。\n\n4. 局域网  \n\n企业、学校内建设局域网，连接所有需要接入外部网络的主机，然后通过企业网络或学校网的边缘路由器连接网络核心。  \n\n局域网技术是以太网、Wi-Fi等。\n\n5. 移动接入网络  \n\n利用移动通信网络，实现智能手机、移动终端等设备的网络接入。\n\n## 网络核心  \n\n由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继与转发。\n\n比较典型的分组交换设备是路由器和交换机等。\n\n# 数据交换技术\n\n为了连接更大范围、更多数量的主机，将交换设备互连，构成一个数据中继与转发的中间网络，然后在将主机链接到距离较近的交换设备上，主机之间通过中间网络实现中继和转发。\n\n这个中间网络不需要关心所传的数据内容，而只是为了为这些数据从一个节点到另一个节点直至到达目的提供数据与交换的功能，称之为数据交换网路。\n\n组成交换网路的节点称之为交换节点，交换节点和传输介质的集合为通信子网。\n\n数据交换是实现在大规模网络核心上进行网路传输的技术基础。\n\n## 电路交换  \n\n首先需要中间交换节点为两台主机之间建立一条专用的通信线路，称为电路，然后再利用该电路进行通信，通信结束后在拆除电路。\n\n利用电路交换通信包括建立电路，交换数据，拆除电路三个阶段。\n\n优点是实时性高，时延和时延抖动都较小。\n\n缺点是对于突发性数据传输，通信利用率低，且传输速率单一。\n\n## 报文交换  \n\n发送方把要发送的信息附加上发送/接受主机的地址及其他控制信息，构成一个完整的报文，然后以报文为单位在交换网路的各结点之间以存储-转发的方式传送，直至送达目的主机。  \n\n## 分组交换  \n\n需要将待传输的数据分割成较小的数据快，每个数据块附加上地址、讯号等控制信息构成数据分组，每个分组独立传输到目的地，目的地将收到的分组重新组装，还原为报文。\n\n采用存储-转发交换方式，与报文交换的主要区别在于是否拆分报文。\n\n优点：\n\n1. 交换设备存储容量要求低\n\n2. 交换速度快  \n\n3. 可靠传输速率高  \n\n4. 更加公平  \n\n## 分组长度的确定  \n  \n1. 分组长度与延迟时间  \n\n分组交换网络的存储-转发过程可以抽象为一个排队系统，基于排队论的分析发现，当分组具有相同的长度时，分组在交换过程中的延迟时间较小。\n\n2. 分组长度与误码率  \n\n通信链路的信道误码率是确定分组长度另外一个需要重点考虑的因素。设分组长度为L位，其中h位为分组头长度，数据长度为x位   x+h=L\n\n若信道误码率为\n\n# 计算机性能的主要性能指标  \n\n1. 速率与带宽  \n\n速率指网络单位内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率。\n\n计算机网络以位为传输单位，所以用bit/s表示基本单位。\n\n2. 时延  \n\n数据从网络中的一个结点到达另一个结点的时间。\n\n- 结点处理延迟  \n\n验证是否有差错，如何转发，还有可能修改部分控制信息。  \n\n- 排队时延  \n\n在该分组前有相同链路在进行传输时，分组要在交换节点进行暂时缓存，排队等待输出链路可用。\n\n- 传输时延  \n\n从发送第一位开始，到发送完最后一位的时间。\n\n- 传播时延  \n\n信号从发送端发送出来，经过一定距离的物理链路到达接收端的时间。  \n\n3. 时延带宽积  \n\n一段物理链路的传播时延于链路带宽的乘积  \n\n4. 丢包率  \n\n用于评价和衡量网络性能的指标，在很大程度上可以反映网络的拥塞程度，因为引发网络丢包的主要因素是网络拥塞。  \n\n5. 吞吐量  \n\n表示在单位时间内源主机通过网络向目的主机实际送达的数据量，单位为bit/s或B/s（字节/秒），记为Thr。吞吐量经常用于度量网络的实际数据传送能力，即网络实际可以达到的源主机到目的主机的数据传送速率。\n\n公式图  \n\n![](计算机网络安全原理-笔记/2.jpg)\n![](计算机网络安全原理-笔记/3.jpg)\n![](计算机网络安全原理-笔记/1.jpg)\n\n# 计算机网络体系结构与参考模型  \n\n## 计算机网络体系结构  \n\n计算机网路经常采用的思路是将复杂的网络通信功能划分为协议分别完成，然后将这些协议按照一定的方式组织起来，实现网络通信所有功能。\n\n最典型的是分层划分，核心思路是上一层的功能建立在下一层的功能基础上，并且在每一层均要遵守协议。\n\nIBM公司1974年提出SNA（系统网络体系结构）\n\n## OSI参考模型  \n\n采用分层结构化技术，一共分为7层。  \n\n协议数据单元 == PDU\n\n1. 物理层  \n\n主要功能是在传输介质上实现无结构比特流传输。另一项主要任务就是规定数据终端设备与数据通信设备之间的相关特性，主要包括机械、电气、功能和规程4方面特性。\n\n无结构是指不关心比特流代表的信息，只关心一合适的信号传送到目的地。\n\n2. 数据链路层  \n\n主要功能实现在相邻节点之间数据可靠而有效的传输。  \n\n另外一项重要功能就是寻址，用来确保每一帧都能准确地传送到正确的接受方。\n\n为了能实现有效的差错控制，采用一种以`帧`为单元的数据快传输方式。要采用帧格式传输，就必须有相应的帧同步技术，即“成帧”（帧同步）功能，包括定义帧的格式、类型、成帧的方法等。  \n\n3. 网络层  \n\n网络层解决的核心问题是如何将分组通过交换网络传送之目的地，因此，主要功能是数据转发与路由。\n\n在交换网络中，信息从源结点出发，经过若干中继结点存储转发后，才能到达目的结点称为从源结点到目的结点的路径。\n\n网络层要对进入交换网络的通信量进行控制，避免通信量过大造成交换网络性能下降。\n\n网络层也具备寻址功能，确保分组可以被正确的传输到目的主机。\n\n4. 传输层  \n\n传输层是第一个端到端的层次，也是一个进程-进程的层次，数据的通信实质是发生在两个主机的进程之间。\n\n主要功能包括复用/分解（分区发送和接受主机上的进程）、端到端的可靠数据传输、连接控制、流量控制和拥塞控制机制等。\n\n5. 会话层  \n\n指用户与用户的连接，通过两台计算机建立、管理和终止通信来完成对话。\n\n主要功能包括在建立会话时核实双方身份是否有权参加会话;确定双方支付通信费用;双方在各种选择功能方面取得一致;在会话建立以后，需要对进程间的对话进行管理和控制。\n\n6. 表示层  \n\n主要用于处理应用实体之间的交换数据的语法，其目的是解决格式和数据表示的差别，从而为应用提供一致的数据格式，使字符、格式等有差异的设备之间相互通信。\n\n表示层还可以实现文本压缩/解压缩、数据加密/解密、字符编码的转换等功能。  \n\n7. 应用层  \n\n提供给用户网络服务，包括文件传送、电子邮件、P2P应用等。为用户提供一个使用网络应用的接口。\n\n- 数据单元(PDU)\n\n物理层称为流或比特流，在数据链路称为帧，在网络层称为分组或包、在传输层称为数据段或报文段，在应用层称为报文等。\n\n- 服务访问点  \n\n相邻层间的服务通过其接口上的服务访问点(SAP)进行的，N层SAP就是N+1层可以访问N层的地方。\n\n每个SAP都有唯一的地址号码  \n\n- 服务原语  \n\n相邻层间提供服务都是用一组原语来描述的。\n\n1. 请求：用户实体请求服务做某种工作。\n\n2. 指示：用户实体被告知某件事发生。\n\n3. 响应：用户实体表示对某件事的响应。\n\n4. 证实：用户实体收到关于它的请求的答复。\n\n## 面向连接和无连接的服务  \n\n1. 面向连接  \n\n以电话系统最为典型。第一步：建立连接;第二步：传送数据;第三步：结束之后拆除链路。\n\n2. 面向无连接  \n\n没有建立和拆除链路的过程  \n\n又称数据报服务，要求每一个分组信息带有全称地址、独立选择路径，其到达目的地的顺序也是不定的，到底目的地后，还要重新对分组排序。\n\n## TCP/IP参考模型  \n\n1. 应用层  \n\n将OSI中会话层和表示层的功能合并到了应用层来实现。\n\n用户通过应用层使用Internet提供的各种服务。每一种应用使用相应协议将用户数据按照协议的格式封装，达到对应的控制功能，然后利用下一层协议进行传输。\n\n例如：WWW服务的HTTP、文件传输的FTP、电子邮件的SMTP和POP3等，每一个应用层协议都会用到两个传输层协议之一进行数据传输：面向连接的传输控制协议TCP和无连接用户数据报协议UDP。\n\n2. 传输层  \n\n负责将应用层封装好的这些数据传输到对方主机上对等的应用层程序。  \n\n传输层主要包括面向连接、提供可靠数据流传输的传输控制协议TCP和无连接不提供可靠数据流传输的用户数据报协议UDP。  \n\n3. 网络互联层  \n\n主要解决把数据分组发往目的网络或主机的问题，网络互联层是整个TCP/IP参考模型的核心  \n\n网络互联层还包括互联网控制报文协议的ICMP、互联网多播组管理协议IGMP以及路由协议，如BGP\\OSPE\\RIP。  \n\n4. 网络接口层  \n\n实际上，这一层对应OSI参考模型中的数据链路层和物理层，网络层IP分组在这一层封装到链路层数据帧中，并最终以比特流的形式在物理介质上进行传输。  \n\n## 五层参考模型  \n\n物理层、数据链路层、网络层、传输层、应用层。  \n","slug":"计算机网络安全原理-笔记","published":1,"updated":"2019-10-26T14:46:34.467Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck29akpuh001g7qsgpon0ypu2","content":"<p>11111<br><a id=\"more\"></a></p>\n<h1 id=\"网络基本原理\"><a href=\"#网络基本原理\" class=\"headerlink\" title=\"网络基本原理\"></a>网络基本原理</h1><ol>\n<li>为什么需要计算机网络?  </li>\n</ol>\n<p>因为我们计算机之间需要进行快速、大量的信息交换。因此，在技术范畴来看，计算机网络是计算机技术与通信技术相互融合的产物。</p>\n<ol start=\"2\">\n<li>简短、概括性的计算机网络定义  </li>\n</ol>\n<p>计算机网络是互连的、自治的计算机的集合。</p>\n<p>自治  是指互联的计算机系统是各自独立的</p>\n<p>互连  是指利用通信链路链接相互独立的计算机系统。</p>\n<ol start=\"3\">\n<li>最大、应用最广泛的计算机网络</li>\n</ol>\n<p>Internet是由很多网络互联而构成的全球性网络;<br>nternet是由很多网络互联而构成的全球性网络nternet是由很多网络互联而构成的全球性网络<br>计算机网络设备通过有线或者无线方式连接服务提供商(ISP)网络，进而接入Internet。</p>\n<p>连接到Internet上的计算机设备都被称为主机或者端系统。  </p>\n<p>Internet的网络连接：小型家用网络连接本地ISP或者区域ISP网络。然后再与规模更大的国家级网络互连，国家ISP再互连其他国家ISP或者全球性ISP，实现全球所有ISP网络的互连。</p>\n<ol start=\"4\">\n<li>ISP网络  </li>\n</ol>\n<p>由许多有线或者无线通信链路互连分组交换设备构成。</p>\n<p>分组交换设备可以实现数据分组的接受与转发，是构成Internet的重要基础，存在多种形式，最典型的是交换机和路由器。</p>\n<h1 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h1><p>计算机网络中的实体在进行数据交换的过程中必须遵守的一些规则或约定。</p>\n<p>概括地说，协议约定了实体之间交换的信息类型、信息各部分的含义、信息交换顺序以及收到特定信息或出现异常时应采取的行为。</p>\n<p>协议三要素</p>\n<ul>\n<li><p>语法：实体之间交换信息的格式与结构  </p>\n</li>\n<li><p>语义：实体之间交换的信息除了需要传输的数据外，通常还包括其他控制信息;语义就是定义了需要发送哪些控制信息，这些控制信息的含义，以及针对不同的控制信息，接受端如何响应。</p>\n</li>\n<li><p>时序：又称为同步，定义了实体之间交换信息的顺序及如何匹配或适应彼此的速度。</p>\n</li>\n</ul>\n<h1 id=\"计算机网络的功能\"><a href=\"#计算机网络的功能\" class=\"headerlink\" title=\"计算机网络的功能\"></a>计算机网络的功能</h1><p>通过信息交换，计算机网络可实现资源共享这一核心功能。  </p>\n<ol>\n<li>硬件资源共享  </li>\n</ol>\n<p>一台主机可以共享另一台主机上的硬件资源，包括CPU、存储资源、打印机、扫描仪I/O设备等 </p>\n<p>实例：云计算机和云存储可以提供硬件计算资源和存储资源的共享。</p>\n<ol start=\"2\">\n<li>软件资源共享 </li>\n</ol>\n<p>网络上的主机可以远程访问、使用服务器计算机上运行的各类大型软件。  </p>\n<p>SaaS：通过互联网提供软件服务。</p>\n<ol start=\"3\">\n<li>信息资源共享  </li>\n</ol>\n<p>即我们在互联网上查看新闻，资料。</p>\n<p>计算机网络支持的信息交换就是典型的信息共享。  </p>\n<h1 id=\"计算机网络的分类\"><a href=\"#计算机网络的分类\" class=\"headerlink\" title=\"计算机网络的分类\"></a>计算机网络的分类</h1><h2 id=\"按覆盖范围分类\"><a href=\"#按覆盖范围分类\" class=\"headerlink\" title=\"按覆盖范围分类\"></a>按覆盖范围分类</h2><ol>\n<li>个域网(PAN)  </li>\n</ol>\n<p>由个人设备通过无线通信技术构成小范围的网络，实现个人设备之间的数据传输。</p>\n<p>覆盖范围1-10 m</p>\n<ol start=\"2\">\n<li>局域网（LAN）  </li>\n</ol>\n<p>通常使用在校园，办公楼等局部区域，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。</p>\n<p>覆盖范围1-10 km</p>\n<ol start=\"3\">\n<li>城域网(MAN)  </li>\n</ol>\n<p>覆盖一个城市的网络。</p>\n<p>覆盖范围5-50 km  </p>\n<ol start=\"4\">\n<li>广域网(WAN)  </li>\n</ol>\n<p>跨越更大的地理空间，可以实现异地局域网或局域网的互连。</p>\n<p>覆盖范围几十到几千千米  </p>\n<h2 id=\"按拓扑-tuo-pu-结构分类\"><a href=\"#按拓扑-tuo-pu-结构分类\" class=\"headerlink\" title=\"按拓扑(tuo pu)结构分类\"></a>按拓扑(tuo pu)结构分类</h2><p>什么是网络拓扑？  </p>\n<p>网络中的主机、网络设备间的物理连接关系与布局。</p>\n<ol>\n<li>星型拓扑结构  </li>\n</ol>\n<p>星型拓扑结构网络中包括一个中央节点网络中的主机通过点对点通信链路与中央节点连接。</p>\n<p>中央节点通常是集线器、交换机等设备。</p>\n<p>多见于局域网、个域网中</p>\n<p>优点：易于监控与管理，故障诊断与隔离容易。</p>\n<p>缺点：中央节点是网络的瓶颈，一旦故障，全网瘫痪，网络规模受限于中央节点的端口数量。</p>\n<ol start=\"2\">\n<li>总线型拓扑结构  </li>\n</ol>\n<p>总线型拓扑结构网络采用一条广播信号作为公共传输介质，称为总线，所有结点均与总线连接</p>\n<p>在任一节点发送信息，其他节点都会接收到这些信息的信号。</p>\n<p>多见于早期的局域网  </p>\n<p>优点：结构简单，易于扩展，所需电缆数量少。</p>\n<p>缺点：通信范围受限，故障诊断与隔离比较困难，容易产生冲突。</p>\n<ol start=\"3\">\n<li>环形拓扑结构  </li>\n</ol>\n<p>利用通信链路将所有节点连接成一个闭合的环。</p>\n<p>优点：所需电缆长度短，可以使用光纤，易于避免冲突。</p>\n<p>缺点：某节点的故障容易导致全局瘫痪，节点的加入或撤出过程比较麻烦，存在等待时间问题。</p>\n<ol start=\"4\">\n<li>网状拓扑结构  </li>\n</ol>\n<p>通过多条链路与不同的节点直接连接。</p>\n<p>多见于广域网、核心网络。</p>\n<p>优点：网络可靠性高，一条或多条链路故障时，网络仍然可联通。   </p>\n<p>缺点：网络结构复杂，造价成本高，选路协议复杂。</p>\n<ol start=\"5\">\n<li>树形拓扑结构  </li>\n</ol>\n<p>总线型或是星型的扩展  </p>\n<p>很多局域网采用这种结构  </p>\n<p>优点：易于扩展，故障隔离容易。</p>\n<p>缺点：对根节点的可靠要求性很高，一旦根节点故障，可能导致网络大范围无法通信。</p>\n<ol start=\"6\">\n<li>混合拓扑结构  </li>\n</ol>\n<p>两种以上的简单拓扑结构混合连接而成的网络。</p>\n<p>绝大多数实际网络都属于混合拓扑结构，比如Internet。</p>\n<p>优点：易于扩展，可以构建不同规模的网络，并可根据需要优选网络结构。</p>\n<p>缺点：网络结构复杂，管理与维护复杂。</p>\n<h2 id=\"按交换方式分类\"><a href=\"#按交换方式分类\" class=\"headerlink\" title=\"按交换方式分类\"></a>按交换方式分类</h2><p>什么是数据交换？</p>\n<p>网络通过彼此互连的结点间数据转接，实现将数据从发送结点送达目的结点的过程和技术。  </p>\n<p>可分为电路交换网络、报文交换网络和分组交换网络。  </p>\n<h2 id=\"按网络用户属性分类\"><a href=\"#按网络用户属性分类\" class=\"headerlink\" title=\"按网络用户属性分类\"></a>按网络用户属性分类</h2><ol>\n<li>公用网  </li>\n</ol>\n<p>由国家或企业出资建设，面向公众提供收费或免费的网络。</p>\n<p>比如电信企业、Internet等</p>\n<ol start=\"2\">\n<li>私有网  </li>\n</ol>\n<p>不向公众开放的网络。</p>\n<p>比如军用网络铁路专用网络等。</p>\n<h1 id=\"计算机网络结构\"><a href=\"#计算机网络结构\" class=\"headerlink\" title=\"计算机网络结构\"></a>计算机网络结构</h1><h2 id=\"网络边缘\"><a href=\"#网络边缘\" class=\"headerlink\" title=\"网络边缘\"></a>网络边缘</h2><p>连接到网络上的所有端系统构成了网络边缘。  </p>\n<p>普通网络用户就是在网络边缘通过网络应用，实现在网络边缘的端系统之间信息交换，因此，可以说网络边缘为网络用户提供了网络应用服务。</p>\n<h2 id=\"接入网络\"><a href=\"#接入网络\" class=\"headerlink\" title=\"接入网络\"></a>接入网络</h2><p>接入网络实现网络边缘的端系统与网络核心连接与接入的网络。</p>\n<ol>\n<li>电话拨号接入  </li>\n</ol>\n<p>利用电话网络，模拟数字电路传送到远端。  </p>\n<p>最大带宽通常为56kbit/s</p>\n<ol start=\"2\">\n<li>非对称用户线路ADSL  </li>\n</ol>\n<p>利用现有的电话网络的用户路线接入网络</p>\n<p>基于频分多路复用(FDM)技术实现电话语音通信与数字通信共享一条用户路线。</p>\n<p>之所以成为“非对称”，是因为ADSL接入网络中，在用户线路实现上行带宽(上传速度)比下行带宽(下载速度)小。</p>\n<p>用户线路长度为3～5km内，典型的上行带宽为512kbit/s～1Mbit/s，下行宽带为1~8Mbit/s  </p>\n<p>用户线路长度为1.3km以内，上行达到19.2Mbit/s，下行为55Mbit/s。</p>\n<ol start=\"3\">\n<li>混合光纤同轴电缆HFC接入网路</li>\n</ol>\n<p>利用有线电视网络实现网络接入的技术</p>\n<p>上行带宽30.7Mbit/s，下行带宽为42.8Mbit/s。</p>\n<p>HFC接入没有ADSL接入速率快，因为ADSL是独享式接入，HFC是利用同轴电缆共享式接入。</p>\n<ol start=\"4\">\n<li>局域网  </li>\n</ol>\n<p>企业、学校内建设局域网，连接所有需要接入外部网络的主机，然后通过企业网络或学校网的边缘路由器连接网络核心。  </p>\n<p>局域网技术是以太网、Wi-Fi等。</p>\n<ol start=\"5\">\n<li>移动接入网络  </li>\n</ol>\n<p>利用移动通信网络，实现智能手机、移动终端等设备的网络接入。</p>\n<h2 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h2><p>由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继与转发。</p>\n<p>比较典型的分组交换设备是路由器和交换机等。</p>\n<h1 id=\"数据交换技术\"><a href=\"#数据交换技术\" class=\"headerlink\" title=\"数据交换技术\"></a>数据交换技术</h1><p>为了连接更大范围、更多数量的主机，将交换设备互连，构成一个数据中继与转发的中间网络，然后在将主机链接到距离较近的交换设备上，主机之间通过中间网络实现中继和转发。</p>\n<p>这个中间网络不需要关心所传的数据内容，而只是为了为这些数据从一个节点到另一个节点直至到达目的提供数据与交换的功能，称之为数据交换网路。</p>\n<p>组成交换网路的节点称之为交换节点，交换节点和传输介质的集合为通信子网。</p>\n<p>数据交换是实现在大规模网络核心上进行网路传输的技术基础。</p>\n<h2 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h2><p>首先需要中间交换节点为两台主机之间建立一条专用的通信线路，称为电路，然后再利用该电路进行通信，通信结束后在拆除电路。</p>\n<p>利用电路交换通信包括建立电路，交换数据，拆除电路三个阶段。</p>\n<p>优点是实时性高，时延和时延抖动都较小。</p>\n<p>缺点是对于突发性数据传输，通信利用率低，且传输速率单一。</p>\n<h2 id=\"报文交换\"><a href=\"#报文交换\" class=\"headerlink\" title=\"报文交换\"></a>报文交换</h2><p>发送方把要发送的信息附加上发送/接受主机的地址及其他控制信息，构成一个完整的报文，然后以报文为单位在交换网路的各结点之间以存储-转发的方式传送，直至送达目的主机。  </p>\n<h2 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h2><p>需要将待传输的数据分割成较小的数据快，每个数据块附加上地址、讯号等控制信息构成数据分组，每个分组独立传输到目的地，目的地将收到的分组重新组装，还原为报文。</p>\n<p>采用存储-转发交换方式，与报文交换的主要区别在于是否拆分报文。</p>\n<p>优点：</p>\n<ol>\n<li><p>交换设备存储容量要求低</p>\n</li>\n<li><p>交换速度快  </p>\n</li>\n<li><p>可靠传输速率高  </p>\n</li>\n<li><p>更加公平  </p>\n</li>\n</ol>\n<h2 id=\"分组长度的确定\"><a href=\"#分组长度的确定\" class=\"headerlink\" title=\"分组长度的确定\"></a>分组长度的确定</h2><ol>\n<li>分组长度与延迟时间  </li>\n</ol>\n<p>分组交换网络的存储-转发过程可以抽象为一个排队系统，基于排队论的分析发现，当分组具有相同的长度时，分组在交换过程中的延迟时间较小。</p>\n<ol start=\"2\">\n<li>分组长度与误码率  </li>\n</ol>\n<p>通信链路的信道误码率是确定分组长度另外一个需要重点考虑的因素。设分组长度为L位，其中h位为分组头长度，数据长度为x位   x+h=L</p>\n<p>若信道误码率为</p>\n<h1 id=\"计算机性能的主要性能指标\"><a href=\"#计算机性能的主要性能指标\" class=\"headerlink\" title=\"计算机性能的主要性能指标\"></a>计算机性能的主要性能指标</h1><ol>\n<li>速率与带宽  </li>\n</ol>\n<p>速率指网络单位内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率。</p>\n<p>计算机网络以位为传输单位，所以用bit/s表示基本单位。</p>\n<ol start=\"2\">\n<li>时延  </li>\n</ol>\n<p>数据从网络中的一个结点到达另一个结点的时间。</p>\n<ul>\n<li>结点处理延迟  </li>\n</ul>\n<p>验证是否有差错，如何转发，还有可能修改部分控制信息。  </p>\n<ul>\n<li>排队时延  </li>\n</ul>\n<p>在该分组前有相同链路在进行传输时，分组要在交换节点进行暂时缓存，排队等待输出链路可用。</p>\n<ul>\n<li>传输时延  </li>\n</ul>\n<p>从发送第一位开始，到发送完最后一位的时间。</p>\n<ul>\n<li>传播时延  </li>\n</ul>\n<p>信号从发送端发送出来，经过一定距离的物理链路到达接收端的时间。  </p>\n<ol start=\"3\">\n<li>时延带宽积  </li>\n</ol>\n<p>一段物理链路的传播时延于链路带宽的乘积  </p>\n<ol start=\"4\">\n<li>丢包率  </li>\n</ol>\n<p>用于评价和衡量网络性能的指标，在很大程度上可以反映网络的拥塞程度，因为引发网络丢包的主要因素是网络拥塞。  </p>\n<ol start=\"5\">\n<li>吞吐量  </li>\n</ol>\n<p>表示在单位时间内源主机通过网络向目的主机实际送达的数据量，单位为bit/s或B/s（字节/秒），记为Thr。吞吐量经常用于度量网络的实际数据传送能力，即网络实际可以达到的源主机到目的主机的数据传送速率。</p>\n<p>公式图  </p>\n<p><img src=\"/2019/08/20/计算机网络安全原理-笔记/2.jpg\" alt><br><img src=\"/2019/08/20/计算机网络安全原理-笔记/3.jpg\" alt><br><img src=\"/2019/08/20/计算机网络安全原理-笔记/1.jpg\" alt></p>\n<h1 id=\"计算机网络体系结构与参考模型\"><a href=\"#计算机网络体系结构与参考模型\" class=\"headerlink\" title=\"计算机网络体系结构与参考模型\"></a>计算机网络体系结构与参考模型</h1><h2 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h2><p>计算机网路经常采用的思路是将复杂的网络通信功能划分为协议分别完成，然后将这些协议按照一定的方式组织起来，实现网络通信所有功能。</p>\n<p>最典型的是分层划分，核心思路是上一层的功能建立在下一层的功能基础上，并且在每一层均要遵守协议。</p>\n<p>IBM公司1974年提出SNA（系统网络体系结构）</p>\n<h2 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h2><p>采用分层结构化技术，一共分为7层。  </p>\n<p>协议数据单元 == PDU</p>\n<ol>\n<li>物理层  </li>\n</ol>\n<p>主要功能是在传输介质上实现无结构比特流传输。另一项主要任务就是规定数据终端设备与数据通信设备之间的相关特性，主要包括机械、电气、功能和规程4方面特性。</p>\n<p>无结构是指不关心比特流代表的信息，只关心一合适的信号传送到目的地。</p>\n<ol start=\"2\">\n<li>数据链路层  </li>\n</ol>\n<p>主要功能实现在相邻节点之间数据可靠而有效的传输。  </p>\n<p>另外一项重要功能就是寻址，用来确保每一帧都能准确地传送到正确的接受方。</p>\n<p>为了能实现有效的差错控制，采用一种以<code>帧</code>为单元的数据快传输方式。要采用帧格式传输，就必须有相应的帧同步技术，即“成帧”（帧同步）功能，包括定义帧的格式、类型、成帧的方法等。  </p>\n<ol start=\"3\">\n<li>网络层  </li>\n</ol>\n<p>网络层解决的核心问题是如何将分组通过交换网络传送之目的地，因此，主要功能是数据转发与路由。</p>\n<p>在交换网络中，信息从源结点出发，经过若干中继结点存储转发后，才能到达目的结点称为从源结点到目的结点的路径。</p>\n<p>网络层要对进入交换网络的通信量进行控制，避免通信量过大造成交换网络性能下降。</p>\n<p>网络层也具备寻址功能，确保分组可以被正确的传输到目的主机。</p>\n<ol start=\"4\">\n<li>传输层  </li>\n</ol>\n<p>传输层是第一个端到端的层次，也是一个进程-进程的层次，数据的通信实质是发生在两个主机的进程之间。</p>\n<p>主要功能包括复用/分解（分区发送和接受主机上的进程）、端到端的可靠数据传输、连接控制、流量控制和拥塞控制机制等。</p>\n<ol start=\"5\">\n<li>会话层  </li>\n</ol>\n<p>指用户与用户的连接，通过两台计算机建立、管理和终止通信来完成对话。</p>\n<p>主要功能包括在建立会话时核实双方身份是否有权参加会话;确定双方支付通信费用;双方在各种选择功能方面取得一致;在会话建立以后，需要对进程间的对话进行管理和控制。</p>\n<ol start=\"6\">\n<li>表示层  </li>\n</ol>\n<p>主要用于处理应用实体之间的交换数据的语法，其目的是解决格式和数据表示的差别，从而为应用提供一致的数据格式，使字符、格式等有差异的设备之间相互通信。</p>\n<p>表示层还可以实现文本压缩/解压缩、数据加密/解密、字符编码的转换等功能。  </p>\n<ol start=\"7\">\n<li>应用层  </li>\n</ol>\n<p>提供给用户网络服务，包括文件传送、电子邮件、P2P应用等。为用户提供一个使用网络应用的接口。</p>\n<ul>\n<li>数据单元(PDU)</li>\n</ul>\n<p>物理层称为流或比特流，在数据链路称为帧，在网络层称为分组或包、在传输层称为数据段或报文段，在应用层称为报文等。</p>\n<ul>\n<li>服务访问点  </li>\n</ul>\n<p>相邻层间的服务通过其接口上的服务访问点(SAP)进行的，N层SAP就是N+1层可以访问N层的地方。</p>\n<p>每个SAP都有唯一的地址号码  </p>\n<ul>\n<li>服务原语  </li>\n</ul>\n<p>相邻层间提供服务都是用一组原语来描述的。</p>\n<ol>\n<li><p>请求：用户实体请求服务做某种工作。</p>\n</li>\n<li><p>指示：用户实体被告知某件事发生。</p>\n</li>\n<li><p>响应：用户实体表示对某件事的响应。</p>\n</li>\n<li><p>证实：用户实体收到关于它的请求的答复。</p>\n</li>\n</ol>\n<h2 id=\"面向连接和无连接的服务\"><a href=\"#面向连接和无连接的服务\" class=\"headerlink\" title=\"面向连接和无连接的服务\"></a>面向连接和无连接的服务</h2><ol>\n<li>面向连接  </li>\n</ol>\n<p>以电话系统最为典型。第一步：建立连接;第二步：传送数据;第三步：结束之后拆除链路。</p>\n<ol start=\"2\">\n<li>面向无连接  </li>\n</ol>\n<p>没有建立和拆除链路的过程  </p>\n<p>又称数据报服务，要求每一个分组信息带有全称地址、独立选择路径，其到达目的地的顺序也是不定的，到底目的地后，还要重新对分组排序。</p>\n<h2 id=\"TCP-IP参考模型\"><a href=\"#TCP-IP参考模型\" class=\"headerlink\" title=\"TCP/IP参考模型\"></a>TCP/IP参考模型</h2><ol>\n<li>应用层  </li>\n</ol>\n<p>将OSI中会话层和表示层的功能合并到了应用层来实现。</p>\n<p>用户通过应用层使用Internet提供的各种服务。每一种应用使用相应协议将用户数据按照协议的格式封装，达到对应的控制功能，然后利用下一层协议进行传输。</p>\n<p>例如：WWW服务的HTTP、文件传输的FTP、电子邮件的SMTP和POP3等，每一个应用层协议都会用到两个传输层协议之一进行数据传输：面向连接的传输控制协议TCP和无连接用户数据报协议UDP。</p>\n<ol start=\"2\">\n<li>传输层  </li>\n</ol>\n<p>负责将应用层封装好的这些数据传输到对方主机上对等的应用层程序。  </p>\n<p>传输层主要包括面向连接、提供可靠数据流传输的传输控制协议TCP和无连接不提供可靠数据流传输的用户数据报协议UDP。  </p>\n<ol start=\"3\">\n<li>网络互联层  </li>\n</ol>\n<p>主要解决把数据分组发往目的网络或主机的问题，网络互联层是整个TCP/IP参考模型的核心  </p>\n<p>网络互联层还包括互联网控制报文协议的ICMP、互联网多播组管理协议IGMP以及路由协议，如BGP\\OSPE\\RIP。  </p>\n<ol start=\"4\">\n<li>网络接口层  </li>\n</ol>\n<p>实际上，这一层对应OSI参考模型中的数据链路层和物理层，网络层IP分组在这一层封装到链路层数据帧中，并最终以比特流的形式在物理介质上进行传输。  </p>\n<h2 id=\"五层参考模型\"><a href=\"#五层参考模型\" class=\"headerlink\" title=\"五层参考模型\"></a>五层参考模型</h2><p>物理层、数据链路层、网络层、传输层、应用层。  </p>\n","site":{"data":{}},"excerpt":"<p>11111<br></p>","more":"<p></p>\n<h1 id=\"网络基本原理\"><a href=\"#网络基本原理\" class=\"headerlink\" title=\"网络基本原理\"></a>网络基本原理</h1><ol>\n<li>为什么需要计算机网络?  </li>\n</ol>\n<p>因为我们计算机之间需要进行快速、大量的信息交换。因此，在技术范畴来看，计算机网络是计算机技术与通信技术相互融合的产物。</p>\n<ol start=\"2\">\n<li>简短、概括性的计算机网络定义  </li>\n</ol>\n<p>计算机网络是互连的、自治的计算机的集合。</p>\n<p>自治  是指互联的计算机系统是各自独立的</p>\n<p>互连  是指利用通信链路链接相互独立的计算机系统。</p>\n<ol start=\"3\">\n<li>最大、应用最广泛的计算机网络</li>\n</ol>\n<p>Internet是由很多网络互联而构成的全球性网络;<br>nternet是由很多网络互联而构成的全球性网络nternet是由很多网络互联而构成的全球性网络<br>计算机网络设备通过有线或者无线方式连接服务提供商(ISP)网络，进而接入Internet。</p>\n<p>连接到Internet上的计算机设备都被称为主机或者端系统。  </p>\n<p>Internet的网络连接：小型家用网络连接本地ISP或者区域ISP网络。然后再与规模更大的国家级网络互连，国家ISP再互连其他国家ISP或者全球性ISP，实现全球所有ISP网络的互连。</p>\n<ol start=\"4\">\n<li>ISP网络  </li>\n</ol>\n<p>由许多有线或者无线通信链路互连分组交换设备构成。</p>\n<p>分组交换设备可以实现数据分组的接受与转发，是构成Internet的重要基础，存在多种形式，最典型的是交换机和路由器。</p>\n<h1 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h1><p>计算机网络中的实体在进行数据交换的过程中必须遵守的一些规则或约定。</p>\n<p>概括地说，协议约定了实体之间交换的信息类型、信息各部分的含义、信息交换顺序以及收到特定信息或出现异常时应采取的行为。</p>\n<p>协议三要素</p>\n<ul>\n<li><p>语法：实体之间交换信息的格式与结构  </p>\n</li>\n<li><p>语义：实体之间交换的信息除了需要传输的数据外，通常还包括其他控制信息;语义就是定义了需要发送哪些控制信息，这些控制信息的含义，以及针对不同的控制信息，接受端如何响应。</p>\n</li>\n<li><p>时序：又称为同步，定义了实体之间交换信息的顺序及如何匹配或适应彼此的速度。</p>\n</li>\n</ul>\n<h1 id=\"计算机网络的功能\"><a href=\"#计算机网络的功能\" class=\"headerlink\" title=\"计算机网络的功能\"></a>计算机网络的功能</h1><p>通过信息交换，计算机网络可实现资源共享这一核心功能。  </p>\n<ol>\n<li>硬件资源共享  </li>\n</ol>\n<p>一台主机可以共享另一台主机上的硬件资源，包括CPU、存储资源、打印机、扫描仪I/O设备等 </p>\n<p>实例：云计算机和云存储可以提供硬件计算资源和存储资源的共享。</p>\n<ol start=\"2\">\n<li>软件资源共享 </li>\n</ol>\n<p>网络上的主机可以远程访问、使用服务器计算机上运行的各类大型软件。  </p>\n<p>SaaS：通过互联网提供软件服务。</p>\n<ol start=\"3\">\n<li>信息资源共享  </li>\n</ol>\n<p>即我们在互联网上查看新闻，资料。</p>\n<p>计算机网络支持的信息交换就是典型的信息共享。  </p>\n<h1 id=\"计算机网络的分类\"><a href=\"#计算机网络的分类\" class=\"headerlink\" title=\"计算机网络的分类\"></a>计算机网络的分类</h1><h2 id=\"按覆盖范围分类\"><a href=\"#按覆盖范围分类\" class=\"headerlink\" title=\"按覆盖范围分类\"></a>按覆盖范围分类</h2><ol>\n<li>个域网(PAN)  </li>\n</ol>\n<p>由个人设备通过无线通信技术构成小范围的网络，实现个人设备之间的数据传输。</p>\n<p>覆盖范围1-10 m</p>\n<ol start=\"2\">\n<li>局域网（LAN）  </li>\n</ol>\n<p>通常使用在校园，办公楼等局部区域，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。</p>\n<p>覆盖范围1-10 km</p>\n<ol start=\"3\">\n<li>城域网(MAN)  </li>\n</ol>\n<p>覆盖一个城市的网络。</p>\n<p>覆盖范围5-50 km  </p>\n<ol start=\"4\">\n<li>广域网(WAN)  </li>\n</ol>\n<p>跨越更大的地理空间，可以实现异地局域网或局域网的互连。</p>\n<p>覆盖范围几十到几千千米  </p>\n<h2 id=\"按拓扑-tuo-pu-结构分类\"><a href=\"#按拓扑-tuo-pu-结构分类\" class=\"headerlink\" title=\"按拓扑(tuo pu)结构分类\"></a>按拓扑(tuo pu)结构分类</h2><p>什么是网络拓扑？  </p>\n<p>网络中的主机、网络设备间的物理连接关系与布局。</p>\n<ol>\n<li>星型拓扑结构  </li>\n</ol>\n<p>星型拓扑结构网络中包括一个中央节点网络中的主机通过点对点通信链路与中央节点连接。</p>\n<p>中央节点通常是集线器、交换机等设备。</p>\n<p>多见于局域网、个域网中</p>\n<p>优点：易于监控与管理，故障诊断与隔离容易。</p>\n<p>缺点：中央节点是网络的瓶颈，一旦故障，全网瘫痪，网络规模受限于中央节点的端口数量。</p>\n<ol start=\"2\">\n<li>总线型拓扑结构  </li>\n</ol>\n<p>总线型拓扑结构网络采用一条广播信号作为公共传输介质，称为总线，所有结点均与总线连接</p>\n<p>在任一节点发送信息，其他节点都会接收到这些信息的信号。</p>\n<p>多见于早期的局域网  </p>\n<p>优点：结构简单，易于扩展，所需电缆数量少。</p>\n<p>缺点：通信范围受限，故障诊断与隔离比较困难，容易产生冲突。</p>\n<ol start=\"3\">\n<li>环形拓扑结构  </li>\n</ol>\n<p>利用通信链路将所有节点连接成一个闭合的环。</p>\n<p>优点：所需电缆长度短，可以使用光纤，易于避免冲突。</p>\n<p>缺点：某节点的故障容易导致全局瘫痪，节点的加入或撤出过程比较麻烦，存在等待时间问题。</p>\n<ol start=\"4\">\n<li>网状拓扑结构  </li>\n</ol>\n<p>通过多条链路与不同的节点直接连接。</p>\n<p>多见于广域网、核心网络。</p>\n<p>优点：网络可靠性高，一条或多条链路故障时，网络仍然可联通。   </p>\n<p>缺点：网络结构复杂，造价成本高，选路协议复杂。</p>\n<ol start=\"5\">\n<li>树形拓扑结构  </li>\n</ol>\n<p>总线型或是星型的扩展  </p>\n<p>很多局域网采用这种结构  </p>\n<p>优点：易于扩展，故障隔离容易。</p>\n<p>缺点：对根节点的可靠要求性很高，一旦根节点故障，可能导致网络大范围无法通信。</p>\n<ol start=\"6\">\n<li>混合拓扑结构  </li>\n</ol>\n<p>两种以上的简单拓扑结构混合连接而成的网络。</p>\n<p>绝大多数实际网络都属于混合拓扑结构，比如Internet。</p>\n<p>优点：易于扩展，可以构建不同规模的网络，并可根据需要优选网络结构。</p>\n<p>缺点：网络结构复杂，管理与维护复杂。</p>\n<h2 id=\"按交换方式分类\"><a href=\"#按交换方式分类\" class=\"headerlink\" title=\"按交换方式分类\"></a>按交换方式分类</h2><p>什么是数据交换？</p>\n<p>网络通过彼此互连的结点间数据转接，实现将数据从发送结点送达目的结点的过程和技术。  </p>\n<p>可分为电路交换网络、报文交换网络和分组交换网络。  </p>\n<h2 id=\"按网络用户属性分类\"><a href=\"#按网络用户属性分类\" class=\"headerlink\" title=\"按网络用户属性分类\"></a>按网络用户属性分类</h2><ol>\n<li>公用网  </li>\n</ol>\n<p>由国家或企业出资建设，面向公众提供收费或免费的网络。</p>\n<p>比如电信企业、Internet等</p>\n<ol start=\"2\">\n<li>私有网  </li>\n</ol>\n<p>不向公众开放的网络。</p>\n<p>比如军用网络铁路专用网络等。</p>\n<h1 id=\"计算机网络结构\"><a href=\"#计算机网络结构\" class=\"headerlink\" title=\"计算机网络结构\"></a>计算机网络结构</h1><h2 id=\"网络边缘\"><a href=\"#网络边缘\" class=\"headerlink\" title=\"网络边缘\"></a>网络边缘</h2><p>连接到网络上的所有端系统构成了网络边缘。  </p>\n<p>普通网络用户就是在网络边缘通过网络应用，实现在网络边缘的端系统之间信息交换，因此，可以说网络边缘为网络用户提供了网络应用服务。</p>\n<h2 id=\"接入网络\"><a href=\"#接入网络\" class=\"headerlink\" title=\"接入网络\"></a>接入网络</h2><p>接入网络实现网络边缘的端系统与网络核心连接与接入的网络。</p>\n<ol>\n<li>电话拨号接入  </li>\n</ol>\n<p>利用电话网络，模拟数字电路传送到远端。  </p>\n<p>最大带宽通常为56kbit/s</p>\n<ol start=\"2\">\n<li>非对称用户线路ADSL  </li>\n</ol>\n<p>利用现有的电话网络的用户路线接入网络</p>\n<p>基于频分多路复用(FDM)技术实现电话语音通信与数字通信共享一条用户路线。</p>\n<p>之所以成为“非对称”，是因为ADSL接入网络中，在用户线路实现上行带宽(上传速度)比下行带宽(下载速度)小。</p>\n<p>用户线路长度为3～5km内，典型的上行带宽为512kbit/s～1Mbit/s，下行宽带为1~8Mbit/s  </p>\n<p>用户线路长度为1.3km以内，上行达到19.2Mbit/s，下行为55Mbit/s。</p>\n<ol start=\"3\">\n<li>混合光纤同轴电缆HFC接入网路</li>\n</ol>\n<p>利用有线电视网络实现网络接入的技术</p>\n<p>上行带宽30.7Mbit/s，下行带宽为42.8Mbit/s。</p>\n<p>HFC接入没有ADSL接入速率快，因为ADSL是独享式接入，HFC是利用同轴电缆共享式接入。</p>\n<ol start=\"4\">\n<li>局域网  </li>\n</ol>\n<p>企业、学校内建设局域网，连接所有需要接入外部网络的主机，然后通过企业网络或学校网的边缘路由器连接网络核心。  </p>\n<p>局域网技术是以太网、Wi-Fi等。</p>\n<ol start=\"5\">\n<li>移动接入网络  </li>\n</ol>\n<p>利用移动通信网络，实现智能手机、移动终端等设备的网络接入。</p>\n<h2 id=\"网络核心\"><a href=\"#网络核心\" class=\"headerlink\" title=\"网络核心\"></a>网络核心</h2><p>由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继与转发。</p>\n<p>比较典型的分组交换设备是路由器和交换机等。</p>\n<h1 id=\"数据交换技术\"><a href=\"#数据交换技术\" class=\"headerlink\" title=\"数据交换技术\"></a>数据交换技术</h1><p>为了连接更大范围、更多数量的主机，将交换设备互连，构成一个数据中继与转发的中间网络，然后在将主机链接到距离较近的交换设备上，主机之间通过中间网络实现中继和转发。</p>\n<p>这个中间网络不需要关心所传的数据内容，而只是为了为这些数据从一个节点到另一个节点直至到达目的提供数据与交换的功能，称之为数据交换网路。</p>\n<p>组成交换网路的节点称之为交换节点，交换节点和传输介质的集合为通信子网。</p>\n<p>数据交换是实现在大规模网络核心上进行网路传输的技术基础。</p>\n<h2 id=\"电路交换\"><a href=\"#电路交换\" class=\"headerlink\" title=\"电路交换\"></a>电路交换</h2><p>首先需要中间交换节点为两台主机之间建立一条专用的通信线路，称为电路，然后再利用该电路进行通信，通信结束后在拆除电路。</p>\n<p>利用电路交换通信包括建立电路，交换数据，拆除电路三个阶段。</p>\n<p>优点是实时性高，时延和时延抖动都较小。</p>\n<p>缺点是对于突发性数据传输，通信利用率低，且传输速率单一。</p>\n<h2 id=\"报文交换\"><a href=\"#报文交换\" class=\"headerlink\" title=\"报文交换\"></a>报文交换</h2><p>发送方把要发送的信息附加上发送/接受主机的地址及其他控制信息，构成一个完整的报文，然后以报文为单位在交换网路的各结点之间以存储-转发的方式传送，直至送达目的主机。  </p>\n<h2 id=\"分组交换\"><a href=\"#分组交换\" class=\"headerlink\" title=\"分组交换\"></a>分组交换</h2><p>需要将待传输的数据分割成较小的数据快，每个数据块附加上地址、讯号等控制信息构成数据分组，每个分组独立传输到目的地，目的地将收到的分组重新组装，还原为报文。</p>\n<p>采用存储-转发交换方式，与报文交换的主要区别在于是否拆分报文。</p>\n<p>优点：</p>\n<ol>\n<li><p>交换设备存储容量要求低</p>\n</li>\n<li><p>交换速度快  </p>\n</li>\n<li><p>可靠传输速率高  </p>\n</li>\n<li><p>更加公平  </p>\n</li>\n</ol>\n<h2 id=\"分组长度的确定\"><a href=\"#分组长度的确定\" class=\"headerlink\" title=\"分组长度的确定\"></a>分组长度的确定</h2><ol>\n<li>分组长度与延迟时间  </li>\n</ol>\n<p>分组交换网络的存储-转发过程可以抽象为一个排队系统，基于排队论的分析发现，当分组具有相同的长度时，分组在交换过程中的延迟时间较小。</p>\n<ol start=\"2\">\n<li>分组长度与误码率  </li>\n</ol>\n<p>通信链路的信道误码率是确定分组长度另外一个需要重点考虑的因素。设分组长度为L位，其中h位为分组头长度，数据长度为x位   x+h=L</p>\n<p>若信道误码率为</p>\n<h1 id=\"计算机性能的主要性能指标\"><a href=\"#计算机性能的主要性能指标\" class=\"headerlink\" title=\"计算机性能的主要性能指标\"></a>计算机性能的主要性能指标</h1><ol>\n<li>速率与带宽  </li>\n</ol>\n<p>速率指网络单位内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率。</p>\n<p>计算机网络以位为传输单位，所以用bit/s表示基本单位。</p>\n<ol start=\"2\">\n<li>时延  </li>\n</ol>\n<p>数据从网络中的一个结点到达另一个结点的时间。</p>\n<ul>\n<li>结点处理延迟  </li>\n</ul>\n<p>验证是否有差错，如何转发，还有可能修改部分控制信息。  </p>\n<ul>\n<li>排队时延  </li>\n</ul>\n<p>在该分组前有相同链路在进行传输时，分组要在交换节点进行暂时缓存，排队等待输出链路可用。</p>\n<ul>\n<li>传输时延  </li>\n</ul>\n<p>从发送第一位开始，到发送完最后一位的时间。</p>\n<ul>\n<li>传播时延  </li>\n</ul>\n<p>信号从发送端发送出来，经过一定距离的物理链路到达接收端的时间。  </p>\n<ol start=\"3\">\n<li>时延带宽积  </li>\n</ol>\n<p>一段物理链路的传播时延于链路带宽的乘积  </p>\n<ol start=\"4\">\n<li>丢包率  </li>\n</ol>\n<p>用于评价和衡量网络性能的指标，在很大程度上可以反映网络的拥塞程度，因为引发网络丢包的主要因素是网络拥塞。  </p>\n<ol start=\"5\">\n<li>吞吐量  </li>\n</ol>\n<p>表示在单位时间内源主机通过网络向目的主机实际送达的数据量，单位为bit/s或B/s（字节/秒），记为Thr。吞吐量经常用于度量网络的实际数据传送能力，即网络实际可以达到的源主机到目的主机的数据传送速率。</p>\n<p>公式图  </p>\n<p><img src=\"/2019/08/20/计算机网络安全原理-笔记/2.jpg\" alt><br><img src=\"/2019/08/20/计算机网络安全原理-笔记/3.jpg\" alt><br><img src=\"/2019/08/20/计算机网络安全原理-笔记/1.jpg\" alt></p>\n<h1 id=\"计算机网络体系结构与参考模型\"><a href=\"#计算机网络体系结构与参考模型\" class=\"headerlink\" title=\"计算机网络体系结构与参考模型\"></a>计算机网络体系结构与参考模型</h1><h2 id=\"计算机网络体系结构\"><a href=\"#计算机网络体系结构\" class=\"headerlink\" title=\"计算机网络体系结构\"></a>计算机网络体系结构</h2><p>计算机网路经常采用的思路是将复杂的网络通信功能划分为协议分别完成，然后将这些协议按照一定的方式组织起来，实现网络通信所有功能。</p>\n<p>最典型的是分层划分，核心思路是上一层的功能建立在下一层的功能基础上，并且在每一层均要遵守协议。</p>\n<p>IBM公司1974年提出SNA（系统网络体系结构）</p>\n<h2 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h2><p>采用分层结构化技术，一共分为7层。  </p>\n<p>协议数据单元 == PDU</p>\n<ol>\n<li>物理层  </li>\n</ol>\n<p>主要功能是在传输介质上实现无结构比特流传输。另一项主要任务就是规定数据终端设备与数据通信设备之间的相关特性，主要包括机械、电气、功能和规程4方面特性。</p>\n<p>无结构是指不关心比特流代表的信息，只关心一合适的信号传送到目的地。</p>\n<ol start=\"2\">\n<li>数据链路层  </li>\n</ol>\n<p>主要功能实现在相邻节点之间数据可靠而有效的传输。  </p>\n<p>另外一项重要功能就是寻址，用来确保每一帧都能准确地传送到正确的接受方。</p>\n<p>为了能实现有效的差错控制，采用一种以<code>帧</code>为单元的数据快传输方式。要采用帧格式传输，就必须有相应的帧同步技术，即“成帧”（帧同步）功能，包括定义帧的格式、类型、成帧的方法等。  </p>\n<ol start=\"3\">\n<li>网络层  </li>\n</ol>\n<p>网络层解决的核心问题是如何将分组通过交换网络传送之目的地，因此，主要功能是数据转发与路由。</p>\n<p>在交换网络中，信息从源结点出发，经过若干中继结点存储转发后，才能到达目的结点称为从源结点到目的结点的路径。</p>\n<p>网络层要对进入交换网络的通信量进行控制，避免通信量过大造成交换网络性能下降。</p>\n<p>网络层也具备寻址功能，确保分组可以被正确的传输到目的主机。</p>\n<ol start=\"4\">\n<li>传输层  </li>\n</ol>\n<p>传输层是第一个端到端的层次，也是一个进程-进程的层次，数据的通信实质是发生在两个主机的进程之间。</p>\n<p>主要功能包括复用/分解（分区发送和接受主机上的进程）、端到端的可靠数据传输、连接控制、流量控制和拥塞控制机制等。</p>\n<ol start=\"5\">\n<li>会话层  </li>\n</ol>\n<p>指用户与用户的连接，通过两台计算机建立、管理和终止通信来完成对话。</p>\n<p>主要功能包括在建立会话时核实双方身份是否有权参加会话;确定双方支付通信费用;双方在各种选择功能方面取得一致;在会话建立以后，需要对进程间的对话进行管理和控制。</p>\n<ol start=\"6\">\n<li>表示层  </li>\n</ol>\n<p>主要用于处理应用实体之间的交换数据的语法，其目的是解决格式和数据表示的差别，从而为应用提供一致的数据格式，使字符、格式等有差异的设备之间相互通信。</p>\n<p>表示层还可以实现文本压缩/解压缩、数据加密/解密、字符编码的转换等功能。  </p>\n<ol start=\"7\">\n<li>应用层  </li>\n</ol>\n<p>提供给用户网络服务，包括文件传送、电子邮件、P2P应用等。为用户提供一个使用网络应用的接口。</p>\n<ul>\n<li>数据单元(PDU)</li>\n</ul>\n<p>物理层称为流或比特流，在数据链路称为帧，在网络层称为分组或包、在传输层称为数据段或报文段，在应用层称为报文等。</p>\n<ul>\n<li>服务访问点  </li>\n</ul>\n<p>相邻层间的服务通过其接口上的服务访问点(SAP)进行的，N层SAP就是N+1层可以访问N层的地方。</p>\n<p>每个SAP都有唯一的地址号码  </p>\n<ul>\n<li>服务原语  </li>\n</ul>\n<p>相邻层间提供服务都是用一组原语来描述的。</p>\n<ol>\n<li><p>请求：用户实体请求服务做某种工作。</p>\n</li>\n<li><p>指示：用户实体被告知某件事发生。</p>\n</li>\n<li><p>响应：用户实体表示对某件事的响应。</p>\n</li>\n<li><p>证实：用户实体收到关于它的请求的答复。</p>\n</li>\n</ol>\n<h2 id=\"面向连接和无连接的服务\"><a href=\"#面向连接和无连接的服务\" class=\"headerlink\" title=\"面向连接和无连接的服务\"></a>面向连接和无连接的服务</h2><ol>\n<li>面向连接  </li>\n</ol>\n<p>以电话系统最为典型。第一步：建立连接;第二步：传送数据;第三步：结束之后拆除链路。</p>\n<ol start=\"2\">\n<li>面向无连接  </li>\n</ol>\n<p>没有建立和拆除链路的过程  </p>\n<p>又称数据报服务，要求每一个分组信息带有全称地址、独立选择路径，其到达目的地的顺序也是不定的，到底目的地后，还要重新对分组排序。</p>\n<h2 id=\"TCP-IP参考模型\"><a href=\"#TCP-IP参考模型\" class=\"headerlink\" title=\"TCP/IP参考模型\"></a>TCP/IP参考模型</h2><ol>\n<li>应用层  </li>\n</ol>\n<p>将OSI中会话层和表示层的功能合并到了应用层来实现。</p>\n<p>用户通过应用层使用Internet提供的各种服务。每一种应用使用相应协议将用户数据按照协议的格式封装，达到对应的控制功能，然后利用下一层协议进行传输。</p>\n<p>例如：WWW服务的HTTP、文件传输的FTP、电子邮件的SMTP和POP3等，每一个应用层协议都会用到两个传输层协议之一进行数据传输：面向连接的传输控制协议TCP和无连接用户数据报协议UDP。</p>\n<ol start=\"2\">\n<li>传输层  </li>\n</ol>\n<p>负责将应用层封装好的这些数据传输到对方主机上对等的应用层程序。  </p>\n<p>传输层主要包括面向连接、提供可靠数据流传输的传输控制协议TCP和无连接不提供可靠数据流传输的用户数据报协议UDP。  </p>\n<ol start=\"3\">\n<li>网络互联层  </li>\n</ol>\n<p>主要解决把数据分组发往目的网络或主机的问题，网络互联层是整个TCP/IP参考模型的核心  </p>\n<p>网络互联层还包括互联网控制报文协议的ICMP、互联网多播组管理协议IGMP以及路由协议，如BGP\\OSPE\\RIP。  </p>\n<ol start=\"4\">\n<li>网络接口层  </li>\n</ol>\n<p>实际上，这一层对应OSI参考模型中的数据链路层和物理层，网络层IP分组在这一层封装到链路层数据帧中，并最终以比特流的形式在物理介质上进行传输。  </p>\n<h2 id=\"五层参考模型\"><a href=\"#五层参考模型\" class=\"headerlink\" title=\"五层参考模型\"></a>五层参考模型</h2><p>物理层、数据链路层、网络层、传输层、应用层。  </p>"}],"PostAsset":[{"_id":"source/_posts/MY_first_Blog/功能.png","slug":"功能.png","post":"ck29akpty000l7qsg05xc2lj7","modified":0,"renderable":0},{"_id":"source/_posts/MY_first_Blog/优势.png","slug":"优势.png","post":"ck29akpty000l7qsg05xc2lj7","modified":0,"renderable":0},{"_id":"source/_posts/ctime-的常用函数/Ctime.png","slug":"Ctime.png","post":"ck29akpu2000r7qsgblfp2pnh","modified":0,"renderable":0},{"_id":"source/_posts/ctime-的常用函数/time格式符.png","slug":"time格式符.png","post":"ck29akpu2000r7qsgblfp2pnh","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络安全原理-笔记/1.jpg","slug":"1.jpg","post":"ck29akpuh001g7qsgpon0ypu2","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络安全原理-笔记/2.jpg","slug":"2.jpg","post":"ck29akpuh001g7qsgpon0ypu2","modified":0,"renderable":0},{"_id":"source/_posts/计算机网络安全原理-笔记/3.jpg","slug":"3.jpg","post":"ck29akpuh001g7qsgpon0ypu2","modified":0,"renderable":0},{"_id":"source/_posts/C-类的案例/1.png","slug":"1.png","post":"ck29akpt600007qsg46tbkz9n","modified":0,"renderable":0},{"_id":"source/_posts/C-类的案例/2.png","slug":"2.png","post":"ck29akpt600007qsg46tbkz9n","modified":0,"renderable":0},{"_id":"source/_posts/C-类的案例/3.png","slug":"3.png","post":"ck29akpt600007qsg46tbkz9n","modified":0,"renderable":0},{"_id":"source/_posts/C-类的案例/步骤1.png","slug":"步骤1.png","post":"ck29akpt600007qsg46tbkz9n","modified":0,"renderable":0},{"_id":"source/_posts/C-类的案例/步骤二.png","slug":"步骤二.png","post":"ck29akpt600007qsg46tbkz9n","modified":0,"renderable":0},{"_id":"source/_posts/C-类的案例/流程图.jpg","slug":"流程图.jpg","post":"ck29akpt600007qsg46tbkz9n","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ck29akpt600007qsg46tbkz9n","category_id":"ck29akptf00047qsgevnp151x","_id":"ck29akptw000g7qsg1wp9w0pn"},{"post_id":"ck29akptn00097qsgzph2wboi","category_id":"ck29akptf00047qsgevnp151x","_id":"ck29akpty000j7qsggdgj877g"},{"post_id":"ck29akptc00027qsglttid4br","category_id":"ck29akptf00047qsgevnp151x","_id":"ck29akpu0000n7qsggm0k052o"},{"post_id":"ck29akpti00057qsgx6bldk7w","category_id":"ck29akptf00047qsgevnp151x","_id":"ck29akpu3000s7qsgz388c147"},{"post_id":"ck29akptr000b7qsg7ah6b0jh","category_id":"ck29akpu0000m7qsg9h1wkq9g","_id":"ck29akpu6000z7qsg2u1b2uik"},{"post_id":"ck29akpu2000r7qsgblfp2pnh","category_id":"ck29akptf00047qsgevnp151x","_id":"ck29akpu800117qsgumlspzzc"},{"post_id":"ck29akptt000e7qsgrinfo2gf","category_id":"ck29akpu0000m7qsg9h1wkq9g","_id":"ck29akpu900137qsg8vu1lk5e"},{"post_id":"ck29akptx000i7qsg75hwmvg4","category_id":"ck29akpu0000m7qsg9h1wkq9g","_id":"ck29akpuc00177qsgo11ys4lq"},{"post_id":"ck29akpu800127qsgv9mmn5s2","category_id":"ck29akpu0000m7qsg9h1wkq9g","_id":"ck29akpue001a7qsgujrvljwt"},{"post_id":"ck29akpu900147qsg4upxzl7l","category_id":"ck29akpu0000m7qsg9h1wkq9g","_id":"ck29akpuf001d7qsgkgnpmcow"},{"post_id":"ck29akpub00167qsgl9kv4u0m","category_id":"ck29akptf00047qsgevnp151x","_id":"ck29akpug001f7qsgw39dzxk3"}],"PostTag":[{"post_id":"ck29akptn00097qsgzph2wboi","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akptt000d7qsgzypgn4fm"},{"post_id":"ck29akptc00027qsglttid4br","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akptw000h7qsgr6iu7z5m"},{"post_id":"ck29akptr000b7qsg7ah6b0jh","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpty000k7qsg1fla5yso"},{"post_id":"ck29akptt000e7qsgrinfo2gf","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpu0000o7qsg0pystkz3"},{"post_id":"ck29akpti00057qsgx6bldk7w","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpu2000q7qsgh41lc3ci"},{"post_id":"ck29akptx000i7qsg75hwmvg4","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpu3000u7qsgzidip80r"},{"post_id":"ck29akpu2000r7qsgblfp2pnh","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpu5000w7qsghz8077ql"},{"post_id":"ck29akpu800127qsgv9mmn5s2","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpub00157qsgmpcdrxe3"},{"post_id":"ck29akpu900147qsg4upxzl7l","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpuc00187qsg8lo6o84d"},{"post_id":"ck29akpub00167qsgl9kv4u0m","tag_id":"ck29akptk00077qsgy3isevig","_id":"ck29akpue001b7qsg7iq8lxjw"}],"Tag":[{"name":"note","_id":"ck29akptk00077qsgy3isevig"}]}}