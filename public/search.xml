<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自学网络原理的第一天]]></title>
    <url>%2F2019%2F10%2F06%2F%E8%87%AA%E5%AD%A6%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%9A%84%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[有趣的网络原理 第二章：网络应用计算机网络应用体系结构先来简单的介绍下有哪些体系结构 客户/服务器(C/S)结构网络应用(C/S)结构的网络应用最基本，最典型的网络应用。它需要服务器程序先运行，客户程序后运行并主动请求于服务器进行通信。例如www应用，文件传输FTP、电子邮件等。区别于其他的结构体系方法就是它的通信只在客户于服务器之间。 纯P2P结构网络应用结构很明显，这是一个客户对客户的体系结构，P2P应用中的每个对等端都同时具备C/S应用的客户与服务的特征，是一个服务器与客户的结合体。例如Gnurella、BitTorent等在这里，我们已经认识到两种体系结构了，他们各自有优缺点，所以按照取长补短的原则就出现了混合型的体系结构(Ps:好像每次有这种结构啥的都有混合型) 混合结构网络应用它既有中心服务器的存在，又有对等端间的直接通信。是C/S和P2P的结合。客户通过C/S方式想服务器注册自己的网络地址，然后就可以在中心服务器找到其他的客户共享资源或分享资源。 网络应用通信基本原理 首先，网络应用的本质就是应用进程之间的通信。 基本通信方式是C/S通信。 应用进程之间遵循应用层协议交换应用层报文 应用层协议定义了语法、语序、语义三要素内容。 按道理说，应该是应用层和应用层之间直接进行传输，但其实是应用层需要通过层间接口将报文发送给传输层，请求端到端传输服务。 编程接口是套接字，它是网络进程之间进行网络通信时，真正收发报文的通道。 对于传输层协议，我们需要为其接口的每个套接字编号，用来标识这个套接字，该编号就是端口号。 比如web服务器的默认端口号是80，是为熟知端口号 每个应用层通过一个或多个套接字于传输层进行接口，因此，我们可以通过进程运行的主机ip地址和套接字绑定的端口号来标识应用进程。 Internet提供两种传输层协议 面向连接的可靠字节流传输服务对应传输层的TCP协议，提供面向连接的服务和可靠的数据传送服务。 无连接的不可靠数据报传输服务对应UDP，不提供传输服务保障的轻量级传输层协议，仅提供最小的尽力服务。 但是这两种协议都不提供端到端吞吐量以及时延保障服务。 域名系统用户使用网络应用时，需要通过指定的IP地址和端口号才能访问。这非常不利于记忆，所以人们就发明了域名，用来访问指定的服务器主机。域名系统(DNS)可以将域名映射为IP地址。实现将域名映射成为IP地址的过程，称为域名解析。 层次化域名空间DNS为了实现高效的管理和查找，域名的结构由标点序列组成，各标号用点隔开 国家顶级域名nTLD: cn(中国)，us(美国) 通用顶级域名gTLD: com(公司和企业)，net(网络服务机构),org(非盈利性组织),edu(教育机构)，gov(政府部门结构)，mil(军事)，int(国际). 基础结构域名: 只有一个，arpa,用于反向域名解析，因此又称反向域名 域名服务器 根域名服务器最重要的域名服务器，在因特网上又13个不同ip地址的根域名服务器。从a开始，比如说a.rootservers.net 顶级域名服务器负责管理在该顶级域名服务器注册的所有二级域名 权威域名服务器负责一个区的域名服务器，保存该区的所有主机域名到IP地址的映射 域名解析过程 递归解析 迭代解析 万维网应用web应用操作简单，其按需浏览、图形化界面，主要包括web服务器、浏览器、超文件传输协议等。 HTTPweb的应用层协议，定义浏览器如何向web服务器发送请求以及web服务器如何向浏览器进行反应。 HTTP连接 并行连接 持久连接 HTTP报文 Cookie小型文本文件，为了辨别用户身份、进行会话跟踪而存储本地的消息。 Internet电子邮件电子邮件结构 邮件服务器 简单邮件传输协议(SMTP) 用户代理 邮件读取协议 SMTP是Internet电子邮件中核心应用层协议，实现邮件服务器之间或用户代理到邮件服务器之间的邮件传输。 电子邮件格式于MIME邮件读取协议 POP3 IMAP HTTP FTP文件传送协议，是在互联上的两台不同主机间实现文件互传的网络应用 socket网络编程]]></content>
  </entry>
  <entry>
    <title><![CDATA[汇编语言基础]]></title>
    <url>%2F2019%2F09%2F11%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[C++_高级特性]]></title>
    <url>%2F2019%2F09%2F07%2FC-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[C++中的高级特性 类的继承继承可以理解为父子，子类继承父类的的基因，父类又称作基类，子类又称作派生类 派生类的写法：class A : B ; 内存中的派生类在内存中派生类实际上是基类的内容加上自己的内容。 protected派生类可以访问到基类的保护成员，但不可以访问私有成员 基类访问控制在定义派生类的基类列表时，可以指定对基类访问控制的类型，即继承方式。 公有继承时：原基类的非私有成员访问属性在派生类中不变 私有继承时：原基类的非私有成员访问属性在派生类中变为私有成员 保护继承时：原基类的非私有成员访问属性在派生类中变为保护成员 构造与析构派生类不会继承基类的构造函数和析构函数 基类的初始化派生类可以在构造函数中使用初始值列表对基类进行初始化 默认构造函数隐式的默认构造函数创建有两个条件 用户没有为该类创建任何构造函数 如果为派生类，其基类必须要有默认构造函数，否则不知道如何初始化基类 派生类的析构析构的顺序为：基类的构造在派生类之前，析构在派生类之后。 名字隐藏实质上就是跟探讨作用域的问题一样 派生类就如同局部，基类为全局;如果一个派生类和基类有一个数据成员一样，那么编译器会先找到派生类的数据成员，并且使用他。如若在派生类找不到才会向基类再去寻找。 类的多态性继承与虚函数构成了多态性。 向上转换派生类可以转换为基类，但是基类不可以转换成派生类 向下转换有时候，我们知道当前指针指向的对象为什么类型，可以使用强制转换完成向下转换 向下转换必须显式的向编译器提出，向下转换具有一定的风险，如果给定的并非是一个派生类的对象，那么，将他进行强制转换，是不可预料的。 虚函数关键字virtual用以声明基类的某个函数为虚函数 我们通常把基类虚函数的实现称作“覆盖”。 虚析构函数如果基类的虚析构函数不是虚函数，针对基类的析构操作将无法引起派生类的析构。 保险起见，一般建议将基类的析构函数声明为虚的 纯虚函数纯虚函数是一种特殊的虚函数，它没有函数的实现。 virtual void say() = 0; 注意区分函数体为空的情形，不可再为虚函数定义函数体 抽象类具有纯虚函数的类即为抽象类。抽象类不能被实例化 抽象类一般用来设计一套统一的接口，派生类必须实现其中的虚函数，才能被实例化。 多级继承派生类的继承可以是任何一个合法的类，也可以继承于某一个派生类。 虚函数的多次填充虚函数的特性是自动遗传的，也就是说，在基类定义了某个虚函数，不管派生类覆盖不覆盖这个函数，其属性仍然是虚的，那么，虚函数可以随着多级继承而被多次填充 多继承派生类可以继承多个基类 多继承带来的问题二义性和内存冗余即可能会在派生类的对象同时保存基类的多份复制 虚拟继承可以实现多个派生类之间共同享受某个相同的基类 在要继承的基类名之前加virtual 在UML使用虚线表示虚拟继承 模板函数模板即带有参数的函数 模板的参数与函数的参数相似与不同 函数的参数列表由()引起,模板的参数列表由&lt;&gt;括起 函数的参数为对象，模板的参数大部分为类型，例如：typename T。T的类型必须是typename或者class。 函数的参数是0～N个，而模板的参数是1～N个 函数模板也可以被重载 使用模板时，可以不指定模板的参数。编译器根据实际调用正确猜测出模板参数的值 模板的参数不能具有默认值，但是类模板中模板参数可以有默认值 函数模板的实例化函数模板必须被实例化才能被正常调用 注意函数的实例化可以隐式完成 函数模板的重载函数模板可以重载 普通的函数与模板函数同名同参数时，C++会优先选择普通函数 函数模板的特化可以针对某个类型进行特化（？特殊化）。特化的函数以“template&lt;&gt;”开头 类模板类模板的成员函数定义之前必须包含一段模板参数的声明 类模板可以声明多个参数 可以具有默认参数类型 异常处理抛出异常使用异常机制，就是在错误的地方，抛出一个异常变量。 throw关键字用以抛出一个异常，这个异常可以是任何类型的对象。 捕获异常可以使用try…catch捕获抛出的异常。try中文含义为尝试，catch为捕获，意思就是先尝试执行一段代码，如果捕获到异常，则执行catch的代码。 捕获不同类型的异常异常可以由程序员自定义异常类。 捕获所有异常可以使用带有省略号的catch语句块，它用以捕获所有未经捕获的异常。 在catch块抛出异常我们可以在catch语句块中再次抛出异常 未经捕获的异常异常不一定都被捕获 如果一个异常没有被捕获，C++不知道怎么处理这个异常的情况下。它将会调用temiante()函数，默认情况下，该函数只会简单的调用abort()函数，用以中断程序的执行。 定制terminate()的行为可以认为terminate()函数使用一个全局的函数指针进行调用 因此，可以使用set_terminate()函数来指定一个新的处理函数。 对抛出异常的声明当声明函数的时候，可以同时指明该函数可能会抛出的异常 对抛出异常作出声明不是强制性的 如果一个函数可能抛出异常，不一定要使用throw抛出异常，反之一样 声明的异常不必与实际抛出的类型相符 在catch语句中，其捕获的异常不必与函数声明的异常中的类型相符 对抛出的异常作出声明，只是为了指导意义，为了让使用者知道调用此函数可能会带来的风险。 名字空间与域用以解决名字冲突问题 名字空间定义可以定义一个名字空间，将自己的类、和对象括起来。 using声明using声明告诉编译器尝试从名字空间查找对象 using指令可以直接声明待使用的名字空间的成员名 名字空间的别名可以使用namespace为已定义的名字空间指定别名 作用域C++支持三种作用域 局部作用域 每段语句块都包含一个局部的作用域，在语句块声明的对象只在本语句块内部其作用 局部变量的存储类型 局部变量可以具有不同的存储类型 自动存储类型：当程序执行超出当前作用域，变量自动销毁 寄存器存储类型：将变量存储在寄存器中进行存取，可以提高函数的执行程度，但是编译器有可能会选择其他方式处理 静态存储类型：超出局部作用域，静态局部变量不会被销毁 名字空间域 由名字空间所指定的作用域 外部存储类型：extern，可以在a源文件声明b源文件的对象 最外成的空间即全局域 类域类域包括定义体和所有的成员函数体 类可以具有static数据成员 作用域、语句块、名字空间、类都可以嵌套 语句块中定义的类为内部类 对象的生命周期生命周期与作用域有某种关系，如：一段语句块中定义的自动对象在离开当前局部作用域的时候，总会被销毁。 C++标准库字符串库 字符串的构造和赋值 由多个重复的字符构成的string：string s(8,’f’) 字符串连接 可以使用+号将两个字符串连接起来 字符串可以用运算符直接比较 字符串的下标 可以通过字符串的下标来访问字符串中的某个字符 通过length()获取字符串的长度 子串：字符串中的一部分 字符串的查找 可以从字符串中查找某个字串，并返回字串所在的位置，使用是string类的find()方法，查找失败返回-1 string与C-style字符串：可以通过c_str()函数获取string的字符数组，c_str返回的是一个const的字符指针，指向string内部的实际存储地址，值会随着string的改变。 空字符串：不包含任何内容，使用clear()清空字符串，empty()判断字符串是否为空 复数类 复数的构造 complex是一个类模板，它可以采用float、double、long double 3种类型进行定制，如：complex c(1,2) 复数可以进行四则运算 复数的操作函数 real()返回复数的实部 imag()返回复数的虚部 abs(x)返回复数x的模 arg(x)返回复数x的相角 conj(x)返回复数x的共軛复数 narm(x)返回复数x的模的平方 异常类包含了C++中各种各样的异常 C标准库assert宏在中定义一个很有用的宏：assert()用以调试代码 如果想取消掉assert()的功能，可以在包含头文件之前定义NDEBUG宏： 类型函数定义了一堆字符处理函数和宏 isdigit(c):判断c是否为数字 isupper(c):判断c是否为大写字母 islower(c):判断c是否为小写字母 isalpha(c):判断c是否为字母 isalnum(c):判断c是否为字母或者数字 isprint(c):判断c是否是可显示的ASCII字符 isspace(c):判断c是否为空字符 touper(c):将c转换成大写字符 tolower(c):将c转换成小写字符 类型转换函数 double atof(char*a):将字符串a转换成浮点数并返回 int atoi(char*a):将字符串a转换成整数并返回 long atol(char*a):将字符串a转换成长整型并返回 char itoa(int value,char string,int radix):将整数value转换成字符串存入string 随机数函数随机数函数定义在 rang()返回0～RAND_MAX中随机的一个整数 rang()的产生依赖于一个发生器序列，一般需要调用srand()函数初始化，初始值一般被称作随机种子 可变参数处理提供了几个宏和类型，以支持可变参数 va_list：记录参数类型 va_start(list,p0):建议扫描参数表的起始指针，并保存参数信息至va_list的变量list va_arg(list,type):提取参数表list中的参数，并转换成type类型 va_end(list):结束可变参数处理 内存操作函数和中定义了如下内存操作函数 void *memchr(buffer,c,count):在内存中查找指定字符 int memcmp(buf1,buf2,count):比较两块内存中的字符 void *memcpy(dest,src,count):拷贝源内存块至目的的内存块 void *memmove(dest,src,count):移动源内存块至目的内存块 void *memset(dest,c,count):使用指定数值设置内存块的内容 void *malloc(size):分配一块内存 void calloc(size,n):分配size\n字节的内存，并清零 void *free(buffer):释放分配的内存 系统控制函数 void abort():异常终止程序 int exit(int status):终止当前程序 int system(chat *command):执行Shell命令 C++流格式化输出流iostream提供了格式化输出函数，用以制定输出的格式 width(n):将输出宽度设置为n个字符，默认情况下，输出宽度等于字符串实际长度 idth():获取当前的宽度设置 fill(ch):设置填充字符为ch，默认情况为空格 fill():获取当前的填充字符 precision(p):设置浮点数精度为p precision():获取浮点数精度 setf(m):打开格式化标志m unsetf(m):关闭格式化标志m setf(m1,m2):打开m1,关闭m2 格式化标志可以上网搜索 格式操纵符可以直接使用&lt;&lt;输出 格式操纵符见互联网 文件流使用ofstream对象写入文件 open打开文件 -&gt; &lt;&lt;或者write函数写入文件 -&gt; close关闭文件 使用ifstream对象读取文件 open打开文件 -&gt; &gt;&gt;或者read函数读取文件 -&gt; close关闭文件 打开文件的模式包括 ios::app:追加模式 ios::ate:打开文件定位到文件尾 ios::binary:二进制方式打开 ios::in:输入方式打开 ios::out:输出方式打开 可以配合|使用 文件的定位 ifstream&amp; seekg(streampos pos);]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络安全原理_笔记]]></title>
    <url>%2F2019%2F08%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8E%9F%E7%90%86-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[11111 网络基本原理 为什么需要计算机网络? 因为我们计算机之间需要进行快速、大量的信息交换。因此，在技术范畴来看，计算机网络是计算机技术与通信技术相互融合的产物。 简短、概括性的计算机网络定义 计算机网络是互连的、自治的计算机的集合。 自治 是指互联的计算机系统是各自独立的 互连 是指利用通信链路链接相互独立的计算机系统。 最大、应用最广泛的计算机网络 Internet是由很多网络互联而构成的全球性网络;nternet是由很多网络互联而构成的全球性网络nternet是由很多网络互联而构成的全球性网络计算机网络设备通过有线或者无线方式连接服务提供商(ISP)网络，进而接入Internet。 连接到Internet上的计算机设备都被称为主机或者端系统。 Internet的网络连接：小型家用网络连接本地ISP或者区域ISP网络。然后再与规模更大的国家级网络互连，国家ISP再互连其他国家ISP或者全球性ISP，实现全球所有ISP网络的互连。 ISP网络 由许多有线或者无线通信链路互连分组交换设备构成。 分组交换设备可以实现数据分组的接受与转发，是构成Internet的重要基础，存在多种形式，最典型的是交换机和路由器。 网络协议计算机网络中的实体在进行数据交换的过程中必须遵守的一些规则或约定。 概括地说，协议约定了实体之间交换的信息类型、信息各部分的含义、信息交换顺序以及收到特定信息或出现异常时应采取的行为。 协议三要素 语法：实体之间交换信息的格式与结构 语义：实体之间交换的信息除了需要传输的数据外，通常还包括其他控制信息;语义就是定义了需要发送哪些控制信息，这些控制信息的含义，以及针对不同的控制信息，接受端如何响应。 时序：又称为同步，定义了实体之间交换信息的顺序及如何匹配或适应彼此的速度。 计算机网络的功能通过信息交换，计算机网络可实现资源共享这一核心功能。 硬件资源共享 一台主机可以共享另一台主机上的硬件资源，包括CPU、存储资源、打印机、扫描仪I/O设备等 实例：云计算机和云存储可以提供硬件计算资源和存储资源的共享。 软件资源共享 网络上的主机可以远程访问、使用服务器计算机上运行的各类大型软件。 SaaS：通过互联网提供软件服务。 信息资源共享 即我们在互联网上查看新闻，资料。 计算机网络支持的信息交换就是典型的信息共享。 计算机网络的分类按覆盖范围分类 个域网(PAN) 由个人设备通过无线通信技术构成小范围的网络，实现个人设备之间的数据传输。 覆盖范围1-10 m 局域网（LAN） 通常使用在校园，办公楼等局部区域，采用高速有线或无线链路连接主机，实现局部范围内高速数据传输。 覆盖范围1-10 km 城域网(MAN) 覆盖一个城市的网络。 覆盖范围5-50 km 广域网(WAN) 跨越更大的地理空间，可以实现异地局域网或局域网的互连。 覆盖范围几十到几千千米 按拓扑(tuo pu)结构分类什么是网络拓扑？ 网络中的主机、网络设备间的物理连接关系与布局。 星型拓扑结构 星型拓扑结构网络中包括一个中央节点网络中的主机通过点对点通信链路与中央节点连接。 中央节点通常是集线器、交换机等设备。 多见于局域网、个域网中 优点：易于监控与管理，故障诊断与隔离容易。 缺点：中央节点是网络的瓶颈，一旦故障，全网瘫痪，网络规模受限于中央节点的端口数量。 总线型拓扑结构 总线型拓扑结构网络采用一条广播信号作为公共传输介质，称为总线，所有结点均与总线连接 在任一节点发送信息，其他节点都会接收到这些信息的信号。 多见于早期的局域网 优点：结构简单，易于扩展，所需电缆数量少。 缺点：通信范围受限，故障诊断与隔离比较困难，容易产生冲突。 环形拓扑结构 利用通信链路将所有节点连接成一个闭合的环。 优点：所需电缆长度短，可以使用光纤，易于避免冲突。 缺点：某节点的故障容易导致全局瘫痪，节点的加入或撤出过程比较麻烦，存在等待时间问题。 网状拓扑结构 通过多条链路与不同的节点直接连接。 多见于广域网、核心网络。 优点：网络可靠性高，一条或多条链路故障时，网络仍然可联通。 缺点：网络结构复杂，造价成本高，选路协议复杂。 树形拓扑结构 总线型或是星型的扩展 很多局域网采用这种结构 优点：易于扩展，故障隔离容易。 缺点：对根节点的可靠要求性很高，一旦根节点故障，可能导致网络大范围无法通信。 混合拓扑结构 两种以上的简单拓扑结构混合连接而成的网络。 绝大多数实际网络都属于混合拓扑结构，比如Internet。 优点：易于扩展，可以构建不同规模的网络，并可根据需要优选网络结构。 缺点：网络结构复杂，管理与维护复杂。 按交换方式分类什么是数据交换？ 网络通过彼此互连的结点间数据转接，实现将数据从发送结点送达目的结点的过程和技术。 可分为电路交换网络、报文交换网络和分组交换网络。 按网络用户属性分类 公用网 由国家或企业出资建设，面向公众提供收费或免费的网络。 比如电信企业、Internet等 私有网 不向公众开放的网络。 比如军用网络铁路专用网络等。 计算机网络结构网络边缘连接到网络上的所有端系统构成了网络边缘。 普通网络用户就是在网络边缘通过网络应用，实现在网络边缘的端系统之间信息交换，因此，可以说网络边缘为网络用户提供了网络应用服务。 接入网络接入网络实现网络边缘的端系统与网络核心连接与接入的网络。 电话拨号接入 利用电话网络，模拟数字电路传送到远端。 最大带宽通常为56kbit/s 非对称用户线路ADSL 利用现有的电话网络的用户路线接入网络 基于频分多路复用(FDM)技术实现电话语音通信与数字通信共享一条用户路线。 之所以成为“非对称”，是因为ADSL接入网络中，在用户线路实现上行带宽(上传速度)比下行带宽(下载速度)小。 用户线路长度为3～5km内，典型的上行带宽为512kbit/s～1Mbit/s，下行宽带为1~8Mbit/s 用户线路长度为1.3km以内，上行达到19.2Mbit/s，下行为55Mbit/s。 混合光纤同轴电缆HFC接入网路 利用有线电视网络实现网络接入的技术 上行带宽30.7Mbit/s，下行带宽为42.8Mbit/s。 HFC接入没有ADSL接入速率快，因为ADSL是独享式接入，HFC是利用同轴电缆共享式接入。 局域网 企业、学校内建设局域网，连接所有需要接入外部网络的主机，然后通过企业网络或学校网的边缘路由器连接网络核心。 局域网技术是以太网、Wi-Fi等。 移动接入网络 利用移动通信网络，实现智能手机、移动终端等设备的网络接入。 网络核心由通信链路互连的分组交换设备构成的网络，作用是实现网络边缘中主机之间的数据中继与转发。 比较典型的分组交换设备是路由器和交换机等。 数据交换技术为了连接更大范围、更多数量的主机，将交换设备互连，构成一个数据中继与转发的中间网络，然后在将主机链接到距离较近的交换设备上，主机之间通过中间网络实现中继和转发。 这个中间网络不需要关心所传的数据内容，而只是为了为这些数据从一个节点到另一个节点直至到达目的提供数据与交换的功能，称之为数据交换网路。 组成交换网路的节点称之为交换节点，交换节点和传输介质的集合为通信子网。 数据交换是实现在大规模网络核心上进行网路传输的技术基础。 电路交换首先需要中间交换节点为两台主机之间建立一条专用的通信线路，称为电路，然后再利用该电路进行通信，通信结束后在拆除电路。 利用电路交换通信包括建立电路，交换数据，拆除电路三个阶段。 优点是实时性高，时延和时延抖动都较小。 缺点是对于突发性数据传输，通信利用率低，且传输速率单一。 报文交换发送方把要发送的信息附加上发送/接受主机的地址及其他控制信息，构成一个完整的报文，然后以报文为单位在交换网路的各结点之间以存储-转发的方式传送，直至送达目的主机。 分组交换需要将待传输的数据分割成较小的数据快，每个数据块附加上地址、讯号等控制信息构成数据分组，每个分组独立传输到目的地，目的地将收到的分组重新组装，还原为报文。 采用存储-转发交换方式，与报文交换的主要区别在于是否拆分报文。 优点： 交换设备存储容量要求低 交换速度快 可靠传输速率高 更加公平 分组长度的确定 分组长度与延迟时间 分组交换网络的存储-转发过程可以抽象为一个排队系统，基于排队论的分析发现，当分组具有相同的长度时，分组在交换过程中的延迟时间较小。 分组长度与误码率 通信链路的信道误码率是确定分组长度另外一个需要重点考虑的因素。设分组长度为L位，其中h位为分组头长度，数据长度为x位 x+h=L 若信道误码率为 计算机性能的主要性能指标 速率与带宽 速率指网络单位内传送的数据量，用以描述网络传输数据的快慢，也称为数据传输速率。 计算机网络以位为传输单位，所以用bit/s表示基本单位。 时延 数据从网络中的一个结点到达另一个结点的时间。 结点处理延迟 验证是否有差错，如何转发，还有可能修改部分控制信息。 排队时延 在该分组前有相同链路在进行传输时，分组要在交换节点进行暂时缓存，排队等待输出链路可用。 传输时延 从发送第一位开始，到发送完最后一位的时间。 传播时延 信号从发送端发送出来，经过一定距离的物理链路到达接收端的时间。 时延带宽积 一段物理链路的传播时延于链路带宽的乘积 丢包率 用于评价和衡量网络性能的指标，在很大程度上可以反映网络的拥塞程度，因为引发网络丢包的主要因素是网络拥塞。 吞吐量 表示在单位时间内源主机通过网络向目的主机实际送达的数据量，单位为bit/s或B/s（字节/秒），记为Thr。吞吐量经常用于度量网络的实际数据传送能力，即网络实际可以达到的源主机到目的主机的数据传送速率。 公式图 计算机网络体系结构与参考模型计算机网络体系结构计算机网路经常采用的思路是将复杂的网络通信功能划分为协议分别完成，然后将这些协议按照一定的方式组织起来，实现网络通信所有功能。 最典型的是分层划分，核心思路是上一层的功能建立在下一层的功能基础上，并且在每一层均要遵守协议。 IBM公司1974年提出SNA（系统网络体系结构） OSI参考模型采用分层结构化技术，一共分为7层。 协议数据单元 == PDU 物理层 主要功能是在传输介质上实现无结构比特流传输。另一项主要任务就是规定数据终端设备与数据通信设备之间的相关特性，主要包括机械、电气、功能和规程4方面特性。 无结构是指不关心比特流代表的信息，只关心一合适的信号传送到目的地。 数据链路层 主要功能实现在相邻节点之间数据可靠而有效的传输。 另外一项重要功能就是寻址，用来确保每一帧都能准确地传送到正确的接受方。 为了能实现有效的差错控制，采用一种以帧为单元的数据快传输方式。要采用帧格式传输，就必须有相应的帧同步技术，即“成帧”（帧同步）功能，包括定义帧的格式、类型、成帧的方法等。 网络层 网络层解决的核心问题是如何将分组通过交换网络传送之目的地，因此，主要功能是数据转发与路由。 在交换网络中，信息从源结点出发，经过若干中继结点存储转发后，才能到达目的结点称为从源结点到目的结点的路径。 网络层要对进入交换网络的通信量进行控制，避免通信量过大造成交换网络性能下降。 网络层也具备寻址功能，确保分组可以被正确的传输到目的主机。 传输层 传输层是第一个端到端的层次，也是一个进程-进程的层次，数据的通信实质是发生在两个主机的进程之间。 主要功能包括复用/分解（分区发送和接受主机上的进程）、端到端的可靠数据传输、连接控制、流量控制和拥塞控制机制等。 会话层 指用户与用户的连接，通过两台计算机建立、管理和终止通信来完成对话。 主要功能包括在建立会话时核实双方身份是否有权参加会话;确定双方支付通信费用;双方在各种选择功能方面取得一致;在会话建立以后，需要对进程间的对话进行管理和控制。 表示层 主要用于处理应用实体之间的交换数据的语法，其目的是解决格式和数据表示的差别，从而为应用提供一致的数据格式，使字符、格式等有差异的设备之间相互通信。 表示层还可以实现文本压缩/解压缩、数据加密/解密、字符编码的转换等功能。 应用层 提供给用户网络服务，包括文件传送、电子邮件、P2P应用等。为用户提供一个使用网络应用的接口。 数据单元(PDU) 物理层称为流或比特流，在数据链路称为帧，在网络层称为分组或包、在传输层称为数据段或报文段，在应用层称为报文等。 服务访问点 相邻层间的服务通过其接口上的服务访问点(SAP)进行的，N层SAP就是N+1层可以访问N层的地方。 每个SAP都有唯一的地址号码 服务原语 相邻层间提供服务都是用一组原语来描述的。 请求：用户实体请求服务做某种工作。 指示：用户实体被告知某件事发生。 响应：用户实体表示对某件事的响应。 证实：用户实体收到关于它的请求的答复。 面向连接和无连接的服务 面向连接 以电话系统最为典型。第一步：建立连接;第二步：传送数据;第三步：结束之后拆除链路。 面向无连接 没有建立和拆除链路的过程 又称数据报服务，要求每一个分组信息带有全称地址、独立选择路径，其到达目的地的顺序也是不定的，到底目的地后，还要重新对分组排序。 TCP/IP参考模型 应用层 将OSI中会话层和表示层的功能合并到了应用层来实现。 用户通过应用层使用Internet提供的各种服务。每一种应用使用相应协议将用户数据按照协议的格式封装，达到对应的控制功能，然后利用下一层协议进行传输。 例如：WWW服务的HTTP、文件传输的FTP、电子邮件的SMTP和POP3等，每一个应用层协议都会用到两个传输层协议之一进行数据传输：面向连接的传输控制协议TCP和无连接用户数据报协议UDP。 传输层 负责将应用层封装好的这些数据传输到对方主机上对等的应用层程序。 传输层主要包括面向连接、提供可靠数据流传输的传输控制协议TCP和无连接不提供可靠数据流传输的用户数据报协议UDP。 网络互联层 主要解决把数据分组发往目的网络或主机的问题，网络互联层是整个TCP/IP参考模型的核心 网络互联层还包括互联网控制报文协议的ICMP、互联网多播组管理协议IGMP以及路由协议，如BGP\OSPE\RIP。 网络接口层 实际上，这一层对应OSI参考模型中的数据链路层和物理层，网络层IP分组在这一层封装到链路层数据帧中，并最终以比特流的形式在物理介质上进行传输。 五层参考模型物理层、数据链路层、网络层、传输层、应用层。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Qt_信号槽_对象树_Lambda]]></title>
    <url>%2F2019%2F08%2F03%2FQt-%E4%BF%A1%E5%8F%B7%E6%A7%BD-%E5%AF%B9%E8%B1%A1%E6%A0%91-Lambda%2F</url>
    <content type="text"><![CDATA[专门讲述信号槽、对象树的概念以及使用Lambda表达式 信号与槽信号和槽是qt中很重要的一个机制，信号即发送者发送信号，槽即接收者处理信号所做的操作 这里即引出名词： 发送者、信号、接收者、槽函数 例如：发送者可以是一个按钮，点击它就是一个信号，这个信号连接着接收者，接受者对信号作出处理 在这里我们用connect方法来连接这些参数即connect(sender,signal,receiver,method); 当遇到函数重载是我们可以使用函数指针来解决问题 我们还可以自定义信号还有槽函数 自定义信号只需要函数声明即可，不需要具体实现。而槽函数就需要声明并且要有实现的代码。 信号和槽的函数的返回值都是void，但可以重载。 信号的参数个数可以大于槽的参数个数，但是参数要一一对应，也就是对应的参数类型必须要一样，反之则不行。 扩展信号可以连接信号 一个信号连接多个槽函数 槽函数的执行顺序是随机的 槽函数可以使用Lambda表达式 信号连接之后可以用disconnect断开 对象树在Qt中，存在对象树的概念，他的功能是在一定程度上简化内存的释放。 在基于QObject的类中或者继承了QObject类的子类，都会自动回收内存。所以说我们new出来的对象指定好父类，他就会自动回收。 例如： 以new的方式创建一个按钮，将它放在Widget的对象中，那么这个按钮他将会在这个Widget释放前自动释放掉。 Lambda表达式在C++11中，Lambda表达式用于定义并创建匿名的函数对象，相当于一个匿名函数。 Lambda表达式声明： 函数对象参数{函数体} []是识别一个lambda表达式的开始。 参数为空时，没有调用外面的任何局部变量 参数为=时，可以以值传递的方式调用Lambda表达式所在作用域的局部变量 参数为&amp;时，可以以引用传递的方式调用Lambda表达式所在作用域的局部变量 参数为this时，可以调用Lambda表达式所在类的成员变量 也可以单独取一个或多个变量使用，使用&amp;则为引用传递，否则为值传递 ()这个是放函数参数的地方，同普通的函数参数一样，不过只能使用值传递和引用传递 {} 函数体 返回值类型使用-&gt;类型名写在函数体的前面，例如：-&gt;int{return 1}; 可修改标识符mutable 可以修改值传递拷贝出来的变量，改变不了本体 例如: mutable{}; 在我这里的学习中，要调用Lambda表达式还需要在函数体后加上() ,例如：{}(); Lambda表达式的作用就是在连接信号的时候可以代替槽函数的位置。 例如： cconnect(sender,signal,receiver,{ //这这里可以写更多的操作，更直观 })]]></content>
  </entry>
  <entry>
    <title><![CDATA[Qt_快速入门(二)]]></title>
    <url>%2F2019%2F08%2F03%2FQt-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[本节讲述Qt中的一些窗口控件如何使用代码创建 菜单栏头文件： #include &lt;QMenuBar&gt; 创建方法： QMenuBar * MenuBar = menuBar() 这种方法创建的菜单栏需要使用setMenuBar方法设置到窗口中,菜单栏只能有一个 状态栏头文件：#include &lt;QStatusBar&gt; 创建方法： QStatusBar * status = new QStatusBar(this) 状态栏也只能 工具栏头文件： #include &lt;QToolBar&gt; 创建方法： QToolBar * toolbar = new QToolBar(this) 标签头文件： #include &lt;QLabel&gt; 创建方法： QLabel * label = new QLabel(this) 按钮头文件: #include &lt;QPushButton&gt; 创建方法: QPushButton * btn = new QPushButton(&quot;test&quot;,this) 按钮要使用new的方式创建在堆区中，否则就会一闪而过。这里使用了两个参数构造函数，第一个是按钮的名称，第二个是要依赖的窗口，因为代码是在Qwidget类中写的，所以直接使用this。 浮动窗口头文件：#include &lt;QDockWidget&gt; 创建方法： QDockWidget * dock = new QDockWidget(&quot;浮动窗口&quot;,this) 文本编辑器头文件： #include &lt;QTextEdit&gt; 创建方法： QTextEdit * edit = new QTextEdit(this)]]></content>
  </entry>
  <entry>
    <title><![CDATA[Qt_快速入门(一)]]></title>
    <url>%2F2019%2F08%2F03%2FQt-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[本节讲述qt一些基本知识 Qt的简介Qt是一个跨平台的C++开发库，主要用来开发图形用户应用程序。 Qt是纯C++开发的，所以建议有C++的基础再来学习。 Qt的优点非常多，比如说跨平台，接口丰富等等。 Qt的成功案例：Linux KDE桌面就是用Qt开发的。 Qt开发环境的选择个人使用的是Qt creator。 manjaro Linux的下载方法就是一条简单的命令 sudo pacman -S qtcreator 下载完成之后，可以打开软件修改中文界面（默认是英语） Tools -&gt; Options -&gt; Environment -&gt; Interface 里的Language 修改成Chinese(china) 不过我的系统在这里有一个小问题，就是选项中没有中文语言，可以用一条命令解决 sudo pacman -S qt5-translations 之后就可以正常选择了 Qt的第一个程序新建项目 -&gt; 选择Qt Widgets App… -&gt;Location: 可以修改项目名称和路径 -&gt;Kits: 构建套件，在实际开发可以选择，我们直接下一步就行了 -&gt;Details: 可以选择一些基类和界面文件并设置名称，这里我们选择Qwidget，然后把界面文件勾选掉 -&gt; 汇总: 添加版本控制，点击完成即可。 完成之后会生成一些文件 pro文件 、main.cpp文件和 你创建的类的头文件和实现文件 .pro文件：这个文件可以说是配置文件，可以添加一些模块 main.cpp会自动生成一些代码，直接运行就可以弹出一个窗口 1234567891011121314151617#include &quot;widget.h&quot;//包含我们自己新建的类的头文件#include &lt;QApplication&gt;//包含一个应用程序类的头文件int main(int argc, char *argv[])//main程序入口 argc命令行变量的数量 argv命令行变量的数组&#123; QApplication a(argc, argv); //实例化应用程序对象，在Qt中，有且只有一个 Widget w; //实例化一个窗口对象 w.show(); //调用方法显示窗口 return a.exec(); //防止窗口一闪而过，进入消息循环&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[《ctime》的常用函数]]></title>
    <url>%2F2019%2F07%2F23%2Fctime-%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在写小程序时接触到的一个C标准函数库 简介表示时间的数据类型 tm 结构123456789101112//需要包含&lt;ctime&gt;头文件struct tm&#123; int tm_sec; //秒 int tm_min; //分 int tm_hour; //时 int tm_mday; //每个月的第几天 int tm_mon; //月份 int tm_year; //1900年到现在的年份 int tm_wday; //表示星期几，周日开始 int tm_yday; //一年中的第几天 int tm_isdst; //夏令时标识&#125;; time_t实质上就是long数据类型的别名，另外clock_t也是一样。 time得到从1970年1月1日 0：00到现在的秒数 函数原型: time_t time(time_t *timer) asctime()将tm结构的日期时间返回成一个字符串。字符串格式：星期,月,日,小时：分：秒,年 函数原型: char asctime(struct tm ptr) ctime将time_t类型时间戳返回成一个字符串。格式与上面相同 函数原型: char ctime(const time_t time) strftime()将tm结构转换为自定义格式的字符串。 函数原型：size_t strftime(char s, size_t n, const char format, const struct tm* tptr) localtime()用本地时区来表示时间 函数原型：struct tm localtime(const time_t timer) gmtime()标准的UTC时间，也就是世界时钟 函数原型：struct tm gmtime(const time_t timer) mktime()将tm结构转换为time_t类型 函数原型：time_t mktime(struct tm* ptm)]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假计划]]></title>
    <url>%2F2019%2F07%2F09%2F%E6%9A%91%E5%81%87%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[暑期的一些计划和对之前生活的小结 小结又有好久没有写博客了，给前一段时间的自己做一个概述和小结，顺便为两个月的暑假定一些目标，时时刻刻给自己提个醒。 我发现自己自从把宿舍搬到跟我一起学习的小伙伴那里，他们就变了一个人似的，一个劲的把我给带坏，图书馆也不带我去，代码也不写，尽带我打游戏，玩牌，托坏我的节奏。(其实我自己定力也不够，总喜欢给自己找各种理由)其实吧，也不怪他们啦，搬过去的时候也已经是临近期末考试了，大家都想要放松一下。这一段时间就当时宿舍之间的磨合吧！ 暑期计划对于暑假的一些计划是根据认识自身的一些不足的方面制定的，比如说C++项目实践，Linux的更多基本玩机知识等。补充一点就是抓紧学习，然后扩展英语词汇量和Qt5的设计方法。 计划表格 计划任务 任务开始时间 C++基础 7-10 Linux基础 7-10 英语 7-21 项目实践 8-1 Qt5 8-10 网络原理 8-10 学习方向仔细的梳理了一下，发现任务还是挺多的。 对于C++的学习看学学习虽然比较全面，但是太枯燥了，我打算结合视频去实现小项目来加深学习。 Linux是正在使用的系统，要想高效率的开发可以下下功夫，但是需要时间去钻研、玩机，暂时按照需要学习，要用哪方面就了解哪一方面。 英语真得花心思去学习一下基本的词汇，在计算机领域有太多英文文档需要去了，如果不想每次都去百度翻译的话，那就把翻译这个插件装在自己脑子里吧。 项目实践是很有必要的一个任务，这是一个检验自身能力的一项计划，有很多问题在实际开发中才能遇到，只有把这些坑踩了以后的路才会平坦。 Qt5是用GUI用户交互设计，想做出好看的界面，还是要努力学习一下的。 网络原理既是本科考试的科目，又是我想学习的黑客技术的必经之路，那学习肯定是不容置疑的啦，只不过现在学习只是为了应付考试，暂时没有时间去折腾。 最后学习计划说完了，希望自己能争气，把这些计划如期的完成，还有就是锻炼身体不能落下，如果没有健身到130的肌肉我可能都不好意思回到学校了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[《Linxu_命令行》笔记]]></title>
    <url>%2F2019%2F07%2F05%2FLinxu-%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[忽略我 常见的错误信息 Command not found — 没有发现命令 Access denied — 拒绝访问 Write protect error — 写保护错误 Drive not ready — 驱动器未准备好 General error — 通常错误]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基本知识2]]></title>
    <url>%2F2019%2F06%2F08%2FLinux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%862%2F</url>
    <content type="text"><![CDATA[继续 用户与组用户分类系统管理员(root)、系统用户(不可登录)、普通用户（可登录）。 建立帐号系统会为用户帐号分配至少两个ID，一个是用户ID(UID)，一个是组ID(GID),管理员的两个ID都为0，非管理员为1000～65535 。 用户帐号及其相关信息均存放在/etc/passwd配置文件中，密码信息存放在/etc/shadow配置文件中 /etc/passwd文件结构意义 用户名称 用户密码 UID GID 用户说明信息 用户家目录 用户的shell root x 0 0 root /root /bin/bash 添加、修改与删除用户的命令useradd添加新的用户帐号命令useradd 参数选项 用户名 参数 作用 -d 制定用户家目录 -M 不创建家目录 -e 指定账户过期的时间，格式为MM/DD/YY or YYYY-MM-DD -g 指定账户的主组群（存在的） -G 指定账户的附属组，多组用逗号分隔 -n 不创建和用户帐号同名的私有用户组 -s 指定账户登录时使用的shell解释器 -u 指定用户的默认UID passwd设置用户密码passwd 参数选项 用户账户名 参数 作用 -l 锁定用户，禁止其登录 -u 解除锁定，允许用户登录 -S 显示用户的密码是否被锁定，以及密码所采用的加密算法名称 -d 清空账户密码，将不能登录系统，除非重新设置密码 -stdin 允许通过标准输入修改密码 usermod修改用户属性usermod 参数选项 用户账户名 参数 作用 -m,-d 重新指定用户的家目录并自动把旧的数据转移过去 -e 修改账户过期的时间 -g 修改主组群 -G 修改附属组 -l 修改用户名称 -L 锁定用户 -U 解锁用户 -s 修改用户登录时使用的shell解释器 -u 修改用户的UID userdel删除用户userdel -r 用户账户名 添加、修改和删除用户组的命令groupadd增加一个新的用户组groupadd 参数选项 用户组名 参数 作用 -g 指定GID groupmod修改用户组名信息groupmod 参数选项 用户组名 参数 作用 -g 修改GID -n 修改组名 groupdel删除用户组名groupdel 用户组名 文件权限管理文件详细信息，共分七列，所含信息的含义如下: 文件类型权限包含文件所属类型和用户对该文件的权限，共有11位或者10位，最后一位.与selinux和acl有关 第一位用来描述文件类型，如下表所示: 第一位 描述 - 普通文件 d 目录文件 l 软链接文件 b 块设备 c 窜行端口设备，如键盘、鼠标等 s 套接字文件，用于进程间通信 后边的九位，没三位为一组，均是可读”r” 可写”w” 可执行”x” 参数的组合，前三，中三，后三分 别代表所属用户(u)的权限，所属组(g)的权限和其他所有用户(o)的权限 文件权限的数字法，基于字符的rwx的权限计算而来，r(4)、w(2)、x(1) 链接占用的节点数;普通文件的节点数和链接数有关，目录与目录下的所有目录及文件有关 文件所属用户 文件所属组 文件大小，kb为单位 最后一次修改日期 文件名 文件权限的更改 chown更改文件的所属用户和所属组chown 参数 账户名 || :组名 文件名文件夹需要加-R chmod改变用户对文件的读写权限chmod 参数 ijk 文件名 参数 作用 ijk 文件权限的数组法来修改权限 -R 当文件是文件夹时需要 a 全部权限，以下参数的用法，例如：chmod u+w test u 用户权限 g 组权限 o 其他组群权限 umask设置需要减去的权限umask ijk 参数 作用 ijk 文件权限的数字法 无参数 查看预设值 文件特殊权限SUID在一个可执行文件加上s权限，任何人在执行该命令时会临时具有所属用户的权限chmod u+s 可执行文件 SUID仅对命令有效 执行者要有x的权限 仅在执行时有效 执行者将具有所属用户的权限 SGIDSGID针对命令是获得命令所属组的权限，针对目录的话，那么目录下创建的文件自动会继承目录所属组chmod g+s 文件 || 目录 SBIT如果对一个目录加上SBIT权限，那么仅root用户和该目录下的文件拥有人才能删除该文件chmod o+t 文件 || 目录 如果采用数字方式，在三位数字前再加上一位代表特殊权限，4代表SUID，2代表SGID，1代表SBIT 文件隐藏属性与访问控制列表chattr设置文件的隐藏权限chattr 参数 文件 参数 作用 +i，-i +可以让文件不能被删除，重命名，不能写入，添加数据，不能创建硬链接;-恢复 +a,-a +让文件添加数据，不能删除，修改数据 lsattr显示文件的隐藏权限lsattr 参数 文件 访问控制列表setfacl管理设置文件/目录的ACL规则setfacl 参数 文件名 参数 作用 -R 对目录文件使用 -m 普通文件 -b 删除文件的ACL getfacl显示文件的ACL信息getfacl 文件名 su与sudo命令su切换用户su 用户名 su -切换用户且重新读取环境变量su - 用户名 sudo以管理员身份运行命令sudo 命令 vim输入命令vimtutor自行学习 Gcc和G++编译和运行123gcc/g++ -c 源代码文件名 //编译gcc/g++ -o 可执行文件名 源代码文件 //生成可执行文件 ./可执行文件名 //执行文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基本知识]]></title>
    <url>%2F2019%2F06%2F05%2FLinux%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录初学Linux所学习的知识 特点 命令区分大小写 使用Tab来补全命令,按两下显示可补全的命令 上下键可以查看历史命令 Ctrl + L可以清屏 使用分号隔开语句可以实现多条命令 \可以断开长命令，增强可读性 命令后加一个&amp;可使命令后台运行 Linux文件系统目录结构 目录 说明 / 根目录 /bin 存放必要的命令的目录 /dev 任何硬件与接口设备以文件的形式放在这个目录下 /etc 存放系统配置文件的目录 /home 系统默认的普通用户家目录 /lib 存放必要运行库的目录 /mnt 各项设备的文件系统挂载点 /proc 存放存储进程和系统信息的目录 /root 系统管理员的家目录 /sbin 存放系统管理员的目录 /tmp 临时文件的存放位置，可供所有用户执行写入操作的特有权限 /usr UNIX software resource的缩写，是操作系统软件资源所默认放置的目录 绝对命令与相对命令绝对命令是从/开始的，也就是根目录;而相对路径是从当前目录开始 Linux基本命令大部分的命令可以参考我的另一篇文章，下面补充一些命令： rmdir删除空目录rmdir 参数选项 目录名称 ln为文件创建链接，链接分为硬链接和符号链接两种，默认的链接类型为硬链接ln 参数选项 源文件或目录 目标文件或目录 参数 作用 -s 建立符号链接 gzip/gunzip压缩/解压缩文件，文件压缩类命令还有bzip2、bunzip2等gizp/gunzip 参数选项 文件 参数 作用 -r 递归压缩 whereis寻找命令的可执行文件所在的位置whereis 参数 命令名称 ss导出socket的统计数据，它显示与netstat命令类似的信息，但能显示比其他工具更详情的TCP状态信息ss 参数 输入/输出重定向和管道命令符的使用输入/输出重定向 符号 作用 command &lt; file 将file文件作为command命令的标准输入 command &gt; file 将command命令的结果输出到file文件中，若有则覆盖，反之新建 command &gt;&gt; file 将command命令的结果输出到file文件中，若有则追加，反之则新建 command 2&gt; file 将command命令结果的错误信息输出到file文件中，若有则覆盖，反之新建 command &amp;&gt; file 将command命令结果的所有信息输出到file文件中，若有则覆盖，反之新建 管道命令符将前一个命令的标准输出作为后一个命令的标准输入命令1 | 命令2]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ note3]]></title>
    <url>%2F2019%2F06%2F04%2FC%2B%2B%20note3%2F</url>
    <content type="text"><![CDATA[关于面向对象编程的笔记 面向对象 new 动态内存分配1234567891011int* i = new int; //类型*变量 = new 类型int* ip = new int[5];//分配数组int* (*ip)[5] = new int[5][4] //分配多维数组delete [] ip; //数组的销毁方式/**思考题 *1、new如何动态分配多维数组？ int (*ipp)[4] = new int[5][4]; *2、分配出来的多维数组如何销毁？ delete[] ipp; **/delete i; //销毁地址 常见错误 忘记销毁new出来的地址，会造成内存泄露 多次销毁一段内存；建议采用如下方法判断某段内存是否被销毁过； 1234if(ip)&#123; delete ip; ip = 0;&#125; 销毁一段非new分配的内存 使用被delete的内存 务必要记住，new和delete必须要成对使用 new的对象不要盲目使用自增运算符 取值运算需要加上取值操作符* 默认参数 C++函数中可以带有默认参数 12345678double Add(int num1,int num2 = 0)&#123; return num1 + num2;&#125;· 所有参数都可以具有默认参数· 默认参数必须从最右边开始· 不可以使用形参作为默认参数· 一般来说，默认参数一般使用在函数参数很多的情况下，它避免了函数调用者必须记住太多太长的参数 可变参数 C++提供一种“可变参数”的机制，即允许参数的数目是可变的。 1234567891011121314151617181920212223242526272829/* 要定义一个支持可变参数的函数，需要用到头文件&lt;cstdarg&gt;中的一些东西 */#include &lt;iostream&gt;#include &lt;cstdarg&gt;using namespace std;int Add(int first...);int main() &#123; int sum = Add(11, 22, 33, -1);&#125;int Add(int first...) &#123; //准备读取可变参数 va_list nums; va_start(nums, first); //使用&lt;cstdarg&gt;中的va_xxx宏函数处理可变参数 int sum = 0; int num = first; //依次读取参数，-1表示结束 while (num != -1) &#123; cout &lt;&lt; &quot;+&quot; &lt;&lt; num &lt;&lt; endl; sum += num; num = va_arg(nums, int); &#125; va_end(nums); return sum;&#125;------------以上主要思想是使用va_xxx读取参数列表，并进行加和。遇到-1结束，可变参数处理起来比较麻烦。 内联函数 在进行函数调用前，会将调用函数的地址和参数列表等信息保留在堆栈中，以便在函数执行结束后，可以返回到原先调用的程序继续执行。因此对于某些频繁调用的小型函数来说，这些堆栈存取动作，会降低的程序的执行效率，此时即可使用内敛函数解决问题。内联函数允许函数内部的内容正在调用点直接展开，这样就避免了传统调用函数过程带来的性能损失。123456789101112131415inline int add(int,int);void add(int a,int b)&#123; cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl; cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl;&#125;int main()&#123; add(1,2); /*编译器会改写成*/ cout &lt;&lt; &quot;接收两个数计算和&quot; &lt;&lt; endl; cout &lt;&lt; &quot;和值为:&quot; &lt;&lt; a+b &lt;&lt; endl; ---------- 实际上，inline只是对编译器进行优化的一个建议， 编译器完全可能会不理会该建议，所以，不要滥用inl ine函数&#125; 函数重载 函数名相同，参数列表不同，就是函数的重载特性12345678910111213141516函数重载经常出现的错误示例：int add(int a)&#123; return a；&#125;float add(int a)&#123; return a&#125;//不能依赖于返回值的类型不同选定一个函数//实参与形参类型不同//不要认为的制造二义性冲突，例如int add(int a)&#123; return a;&#125;int add(int a,int b = 10)&#123; return a + b; &#125; 安全连接和名字重组自行百度了解 递归函数 函数自己调用自己，即递归函数12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;void test(int);int main() &#123; test(10);&#125;void test(int num1) &#123; cout &lt;&lt; &quot;函数开始&quot; &lt;&lt; endl; if (num1 == 0) return; test(num1 / 2); cout &lt;&lt; &quot;函数结束&quot; &lt;&lt; endl;&#125;输出结果如下:函数开始函数开始函数开始函数开始函数开始函数结束函数结束--gg函数结束函数结束--------------个人是这样理解的,递归就是一个函数嵌套的过程，像上面的程序有五个函数开始，这是在执行递归之前的语句，也就是说算上第一次进入函数，这个函数执行了五次，但对应的函数结束却只出现了四次，那是因为最后一次执行了 return语句，直接跳出了函数，也就没有后面的语句的执行。结合理解使用调试功能进行观察效果会更好。 函数指针 在C++中提供函数指针，它用以指向一个函数 123456void (*fp)(); //声明一个类型为void，没有参数的函数指针fp = &amp;add; //指向add函数的地址fp = add //等同与指向//调用的方法fp(); //相当于add()(*fp)(); //相当于add()，一般用这种来区别这是一个函数指针的调用 理解函数指针 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int add(int a ,int b) &#123; return a + b;&#125;int min(int a, int b);int main() &#123; void (*fp1)(int); int (*fp2)(int, int); cout &lt;&lt; typeid(fp1).name() &lt;&lt; endl; cout &lt;&lt; typeid(fp2).name() &lt;&lt; endl; cout &lt;&lt; typeid(add).name() &lt;&lt; endl; cout &lt;&lt; typeid(min).name() &lt;&lt; endl;&#125;int min(int a, int b) &#123; return a - b;&#125;------------利用typeid输出函数指针类型来理解它根据这样的特性，我们可以定义函数指针数字组int (*fp[])(int ,int ) = &#123;&amp;add,&amp;min&#125;函数指针的定义有点繁琐，建议用typedef来改善可读性。typedef int (*fp)(int,int);fp fp1 = add;fp fp2 = &amp;min;fp fp3[] = &#123;&amp;add,&amp;min&#125;; 函数与值传递 1234·值传递有三种方式：传值方式，引用方式，传址方式·向函数传递参数的时候，除了引用方式外，其他方式都是在函数内部将参数内容复制一份使用。 类的设计 类是对象的类型，对象是类的实例 类的设计 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071· 类的语法定义：class 类名&#123;访问控制符: 成员列表&#125;;· 类也可以先声明后定义，声明方式如下class 类名;· 对象的定义类名 对象名;类名 * 对象名 = new 类名();//类的两种实例化方法还可以定义类对象的指针和引用类名 * 指针名 = &amp;对象名;类名 &amp; 引用名 = 对象名;· 数据成员的访问可以使用&quot;.&quot;来访问数据成员对象指针用&quot;-&gt;&quot;来访问还支持用&quot;::&quot;域名操作符访问成员，但常用以上两种· 成员访问控制访问控制符一般包括两种public:共有的，可以在任意地方访问成员private:私有的，只能在类的内部访问成员有一种不成文的规矩，就是把私有的数据成员加上下划线· 成员函数成员函数其实与普通的函数没有太大的差别，它可以被内联，也可以被重载，也可以使用默认参数，唯一的区别就是定义是要加上类域的帽子，但声明不需要，如class A&#123; void a();&#125;;void A :: a()&#123; //数据类型 所属类名 :: 函数名 cout &lt;&lt; &quot;我属于A类&quot; &lt;&lt; endl;&#125;· this指针在成员函数体内，有一种特殊的指针，this指针。this指针指向当前类对象本身，可以用this调用对象的成员：this -&gt; a();注意:this不能被改变，也不能在类作用域以外的地方使用· 内存中的类类包括数据成员和成员函数，但内存中的类只包括其数据成员，成员函数其实并不属于对象，它只是一个特殊的全局函数。· 类的长度等于所有数据成员的长度之和，但是考虑如下情况：#include &lt;iostream&gt;using namespace std;class A &#123;public: int a; int b; char c; char d;&#125;;class B &#123;public: int a; char c; int b; char d;&#125;;int main() &#123; cout &lt;&lt; sizeof(A) &lt;&lt; endl; cout &lt;&lt; sizeof(B) &lt;&lt; endl;&#125;输出如下：1216为了程序运行的效率，编译器在一定的设置下可能对成员排放位置做一些调整，使得整个结构体为一个字节长的整数倍，这就是所谓的“字节对齐”，上面演示了这种布局的差异，可以看出来，，不同的排列方式会引起类字节长度的差别，大家写代码一定要考虑这一点。 UML类图可以表示一个类，便于理解，如 私有是”-“前缀，共有则是”+”前缀 类名 数据成员 函数成员 类的讨论 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657· 类与结构C++中提供结构和类。在数据成员上，它们唯一的差别在于：结构成员的默认访问控制为public，类的默认访问控制为private。class是一个全新的概念，所以人们更愿意接受class是真正的面向对象概念。而对于struct，人们更愿意用来描述那些没有行为或者行为能力很弱的数据结构体。· 抽象性在软件开发的分析、设计时对具体问题进行归纳、概括，并将这一类对象的公共特性加以条理化和严格描述，它主张集中思想和精力，考虑关键、主要、实质性的问题，去掉非主要的部分，便于开发人员对整个问题准确地认识。为具体的对象定义一个类的过程就是抽象。· 封装性保证程序员用正确的方式操作对象，并将一些操作细节隐藏起来。主要体现如下方面:--- 保护私有数据:不允许外部程序直接访问私有的数据--- 隐藏了操作细节:提供公用成员函数提供外部调用根据这两个方面,我们可以举一个例子来说明:#include &lt;iostream&gt;using namespace std;class A &#123; /** *声明一个A类，包含两个数据成员并封装成4个成员函数 *这里使用this指针加深印象 **/ string _name; string _sex;public: void setname(string name) &#123; this -&gt;_name = name; &#125; void setsex(string sex) &#123; this-&gt;_sex = sex; &#125; string getname() &#123; return this -&gt;_name; &#125; string getsex() &#123; return this -&gt;_sex; &#125;&#125;;int main() &#123; /** *使用指针的方法实例化A的一个对象 *定义两个string临时变量 *调用公共的数据成员封装函数进行赋值和输出 **/ A * a1 = new A(); string temp1,temp2; cout &lt;&lt; &quot;请输入你的姓名&quot;; cin &gt;&gt; temp1; a1-&gt;setname(temp1); cout &lt;&lt; &quot;请输入你的性别&quot;; cin &gt;&gt; temp2; a1-&gt;setsex(temp2); cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; a1-&gt;getname() &lt;&lt; endl; cout &lt;&lt; &quot;性别:&quot; &lt;&lt; a1-&gt;getsex() &lt;&lt; endl;&#125;程序员的责任就是封装复杂的数据和操作，以简单明了的共有函数的方式为外部程序提供对象操作接口 类的封装性封装性保证程序员通过正确的方式操作对象，并将操作的细节隐藏起来。 保护私有数据：不允许外部程序访问私有的数据 隐藏了操作细节：提供公共方法，以供外部程序调用 注意点 类的组合 类的数据成员可以是基本类型、复合类型、或者是一个自定义类的对象。 类的声明 要在调用类之前先声明这个类 构造函数是一个有特殊的成员函数，定义类的实例被隐式调用 函数名与类名一致 与正常的函数规则一致，可重载但不能有返回值例如，可以带有参数，默认值等 一般用来初始化数据 没有定义构造函数时C++会自动创建默认构造函数 成员初始值列表构造函数的特有的初始化方式。用以指定在调用该构造函数是完成的初始化序列 以：引起，多个值以，间隔;初始化语句写成()形式 析构函数是与构造函数相反的一个特殊函数，销毁对象或某个对象离开作用域时会调用析构函数。 以～引起，函数名与类名一致 没有返回值，参数列表为空 一般用来销毁对象 没有定义时会自动创建默认析构函数 转换构造函数当某个构造函数只有一个参数，而该参数又不是本类的const引用，称为转换构造函数 explicit不允许显式调用函数 拷贝构造函数拷贝构造函数即复制一个对象。 操作符重载为类定义操作符函数 例：如果一个对象将 ～操作符 重载，则～a等同于a.operator~() 注意点 操作符重载函数可以有形参 一元操作符不能混当二元操作符使用，同理，二元也一样。 对于查找顺序来说，编译器会先查找对象操作符的重载，再去查找全局操作符的重载 类型转换：将对象转换成对应的类型，如：Actor::operator string() const用来指示某个变量不能被修改 如果在对象实例前加上const，那么你就只能使用const类型的成员函数 mutable用来修饰数据成员，表示可变的。 加了const的函数遇到使用mutable数据成员的修改会忽略它。 友元当一个类或一个函数声明为另一个类的朋友时，它就可以访问该类的私有成员 注意点 使用友元在前面加上friend 注意声明的顺序 如果A类声明B类为友元，那么B类可以访问A类的私有数据成员，A类则不能访问B类 友元在一定程度上破坏了类的封装性，尽量不要过多使用]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ note1]]></title>
    <url>%2F2019%2F06%2F04%2FC%2B%2B%20note1-1%2F</url>
    <content type="text"><![CDATA[函数的一些积累 常用头文件#include -&gt; 包含头文件:输入输出流详情了解cin请点击传送门 using namespace std -&gt; std命名空间 #include -&gt; 包含向量的头文件 #include -&gt; 包含排序方法sort() -&gt; 数组升序排序reverse() -&gt; 数组逆序排序 #include -&gt; 迭代器 #include -&gt; 设置输出格式12setw(2) //设置字符宽度为2个字节 setiosflags(ios::left) //设置文字左对齐 #include -&gt; 字符串操作 123456789#include &lt;string&gt;string s; //定义string对象ss.length() //返回字符串长度，即字符个数s.empty() //判读字符串是否为空串s.at(i) //返回字符串的第i个字符s[i] //等同于s.at(i)s.substr(int i,int j) //获取从i到j的字符串其他方法getline(cin\cout,变量) //输入或输出变量 常用函数 memset() -&gt; 数组初始化函数]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ note2]]></title>
    <url>%2F2019%2F06%2F04%2FC%2B%2B%20note2%2F</url>
    <content type="text"><![CDATA[C++的一些知识补充 1 C++笔记学习方法 学习C++有一个捷径，那就是学会编译器的思维，了解它可能的行为，再来读C++源程序。一旦发现了编译器的行为与预期的差异，那么再去通过学习和分析，调整自己错误的理解。这样就会编写出正确、高效的C++程序。 条件操作符 用法 :: &lt;表达式1#?&lt;表达式2#:&lt;表达式3#如果表达式为true，返回表达式2的值；否则返回表达式3的值 typeid操作符 用法 :: typeid(类型 || 变量).name()通过name()函数获取该类型或变量的名字。 安全使用数组下标 当使用数组尺寸之外的的下标访问元素时，C++编译器不会给出任何提示！这一点非常可怕。非法的赋值会改变某块内存中的值。防止使用非法的下标，以免埋下重大隐患。 安全使用字符串 字符数组不是C++的基本类型，所以字符数组的安全必须由程序员自己保证。我们看下面的例子: 1234567891011char str1[] = &quot;hello&quot;;cout &lt;&lt; str1 &lt;&lt; endl;str1[5] = &apos;!&apos;;cout &lt;&lt; str1 &lt;&lt; endl;改代码输出了str1的末字符，输出如下:hello hello!烫烫烫？很显然，这不是我们想要的结果。使用&apos;\0&apos;作为字符串时C++的非强制性约定，编译器不负责字符串的安全。另一方面，由于字符串本身就是字符数组，也会带来越界访问的隐患。 void*指针 一种特殊的指针类型，可以存放任意对象的地址 注意:void*指针地址存放一个内存地址，地址指向内容不确定void*指针一般用来和别的指针比较，作为函数的输入输出 || 赋值给另外一个void*指针 引用12int i;int &amp; ri = i; //类型 &amp; 变量 = 引用对象 结构常见错误 使用了未初始化的结构成员 指定了太多的初始值 枚举 枚举采用关键字enum，用来定义一组常量 12345678enum Arrow&#123; UP,DOWN,LEFT,RIGHT&#125;;Arrow a1 = UP; //okArrow a2 = 100; //errorcout &lt;&lt; a1 &lt;&lt; endl;输出结果为:0 默认情况下，枚举值第一个成员对应的值为0，以此类推。当然了，也可以在定义枚举时手动指定每个枚举值。 typedef typedef提供了为某种既有类型取别名的功能。 123456789typedef int zhengxing;int t1;zhengxing t2; //int == zhengxing常见用法· 定义新的类型，以提高代码的可读性，并有效封装代码中的内部类型。· 另外一种就是函数的指针的类型定义，如：在Windows线程编程中，就有类似的线程函数接口定义：typedef void * LPVOID;typedef DWORD WINARI ThreadProc(LPVOID 1pParamter); 定义带参数的main()函数 main()函数支持另外一种原型 1234567891011int main(int argc,char * argv[]) &#123; cout &lt;&lt; &quot;参数数目:\t&quot; &lt;&lt; argc &lt;&lt; endl; for (int i = 0; i &lt; argc; i++) &#123; cout &lt;&lt; &quot;参数&quot; &lt;&lt; i &lt;&lt; &quot;:\t\t&quot; &lt;&lt; argv[i] &lt;&lt; endl; &#125; return 0;&#125;输出结果为exe文件所在目录可以打开命令窗口进入到程序所在目录输入命令程序名+空格+bluejoe+vcer.net会输出程序的参数列表 预处理指令1234567891011121314预处理器一般完成如下操作：· 格式化代码，去多余的空格和注释；· 进行一些宏替换· 包含另外一段代码· 通过一些条件的判断，动态决定是否编译某段代码预处理指令#define //定义宏#undef //取消宏的定义#if //判断#else #elif#endif#error //输出错误信息#include //包含文件 宏指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657· 一般的，定义宏的时候可以为其指定替换的文本· 也可以把宏定义成某个表达式· rand()函数可以返回一个0~RAND_MAX之间的随机整数，RAND_MAX是由标准库函数定义的宏。如果需要取指定范围的随机数可以用到RAND_MAX,如int i = rand * 10 / RAND_MAX; //0~10之间的数· 宏可以包含参数，这样的宏也可以叫做宏函数，如：#define S(x) x * xint main()&#123; cout &lt;&lt; &quot;9的平方是:&quot; &lt;&lt; S(9) &lt;&lt; endl;&#125;· 宏函数具有一个很明显的优点，那就是避免了C++的强类型检测，如#define S(a,b) a+bint main() &#123; string s1 = &quot;Hello&quot;; string s2 = &quot;World&quot;; cout &lt;&lt; S(s1, s2) &lt;&lt; endl;&#125;· 宏与常量很相似，所以不能引用和指向宏定义的常量· 宏函数也是会有副作用的，如#define S(x) ((x) * (x))int i = 100;cout &lt;&lt; &quot;S(101);&quot; &lt;&lt; S(i++) &lt;&lt; endl;输出如下: S(101): 10000结果并不是我们期待的101*101，避免副作用的方法，那就是正确运用宏，把宏看成一种预编译时期的文本替换，而这，也正是宏原本的含义。· #操作符如果宏定义中出现了‘#’，预处理器会将#后面的参数括成一个字符串进行替换，如#define S(i) cout &lt;&lt; &quot;S(&quot;#i&quot;)&quot; &lt;&lt; ((i) * (i)) &lt;&lt; endl;S(90);//等同于cout &lt;&lt; &quot;S(&quot;90&quot;)&quot; &lt;&lt; ((90) * (90)) &lt;&lt; endl;· #操作符“#”用于将两侧的参数合并成一个。如#define RGB(rr,gg,bb) 0x#rr#gg#bbint red = RGB(FF,00,00);//会被替换成int red = 0xFF0000;· 取消宏“#undef”用于取消指定名字的宏，然后修改宏的值吐槽一下：个人不知道为什么不能直接删除然后修改· C++预定义宏_LINE_ //整数，代表代号所在行号 _FILE_ //字符串，代表当前代码所在的文件路径_DATe_ //字符串代表当前文件的编译日期_TIME_ //字符串代表当前文件的编译时间_STDC_ //代表是否为标准C_cplusplus_ //当前当前的C++版本· 可以使用这些宏实现特定的功能bool ok = false;if(!ok)&#123; cout &lt;&lt; &quot;发生错误:&quot; &lt;&lt; _FILE_ &lt;&lt; &quot;(&quot; &lt;&lt; _LINK_ &lt;&lt; &quot;)&quot; &lt;&lt; endl; cout &lt;&lt; &quot;该软件最后发布时间：&quot; &lt;&lt; _DATE_ &lt;&lt; &quot; &quot; &lt;&lt; _TIME_ &lt;&lt; endl;&#125; 条件编译指令 预处理通过某些条件的判断有选择的进行处理 123456789101112131415161718192021222324252627282930· #if···#endif(条件编译的结尾) · #else 和 #elif 与if语句相似分别与if语句中的else和else if相似#define IS 9int main()&#123;#if IS &lt; 10 cout &lt;&lt; &quot;TEST&quot; &lt;&lt; endl;#elif Is &lt; 5 cout &lt;&lt; &quot;TEST2&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;#endif return 0;&#125;· #if define 和 #if !define前者用于检测指定的宏是否定义#if define IS cout &lt;&lt; &quot;已定义&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;#endif这这种情况可以使用#undef取消对IS的定义（解决了前面不知道它的用法）还可以使用&quot;!&quot;操作符，指定某个宏没有被定义的情形，也就是#if !define.(个人感觉等同于#undef)#if !define IS cout &lt;&lt; &quot;未定义&quot; &lt;&lt; endl;#endif· #ifdef 和 #ifndef前者等价于#if define,后者等价于#if !define：相当于缩写 文件包含指令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647· #include用于包含一个源文件文件名用&lt;#时，它指示预处理器从预设的标准路径中搜索指定的头文件。预设路径一般是编译器自带的include目录，当前也可以自己添加其他的目录文件名用双引号括起来的时，预处理器会从当前文件所在的目录中查找文件。在一些编译器中，还可以使用相对路径查找头文件· C标准库头文件&lt;cassert# //assert宏的定义 &lt;cctype# //字符操作函数的操作&lt;cerrno# //错误码的定义&lt;cmath# //数学函数库&lt;setjmp# //错误处理库&lt;cstdarg# //可变参数处理宏的定义&lt;stdio# //标准输入输出的声明&lt;stdlib# //数字函数、内存管理函数、系统函数、随 机函数等的声明&lt;cstring# //C类型的字符串的操作函数的声明&lt;ctime# //日期、时间操作函数的声明· C++标准库的头文件&lt;string# //字符串&lt;iostream# //流操作&lt;fstream# //文件流&lt;complex# //复数&lt;stdexcept# //标准异常STL //标准模板库· 合理的使用头文件考虑如下情况：a.h 包含 point.h b.h 包含 point.hc.h 包含 a.h 和 b.h这种情况下，当编译器处理c.h时，重复定义就出现了解决办法是，类似如下的办法，重新设计point.h的内容#ifndef _HEADER_POINt_H_#define _HEADER_POINt_H_头文件内容#endif以上定义一个宏：_HEADER_POINt_H_(可以自定义)，并通过它来 判断当前文件是否已经被包含。这样一来，即使poin.h被包含多次，由#ifndef...#endif定义的point.h文件的内容也不会被包含多次· #error当编译器遇到#error指令时，会停止下来，并在编译窗口输出#error后面的信息· #line用于改变当前行的行号和文件名· #pragma属于自定义指令，每个编译器可以自己定义自己的功能 位域 定义结构时，可以指定每个数据成员所占的比特位数。这时数据成员则可以称作位域。位域是为了节省内存。 12345678struct Time&#123; unsigned hour : 5; //5 bits,0~31 unsigned minute : 6; //6 bits,0~63 unsigned second : 6; //6 bits,0~63&#125;;cout &lt;&lt; sizeof(Time) &lt;&lt;endl;输出结果：4 数据类型修饰符 const 中文含义为“固定不变的”，所以const变量被称为常量或者常熟变量。const毕竟还是一个变量， 它具有自己的内存地址，不过它不可以被修改。 int i = 100; int m = 200; int* ip0 = &amp;i; //非const int* const ip1 = &amp;i; //const 修饰int* int const * ip2 = &amp;i; //const 修饰int const int* ip3 = &amp;i; //const 修饰int const int* const ip4 = &amp;i; //const 同时修饰ip4和*ip4 ip0 = &amp;m; *ip0 = 101; //ip1 = &amp;m; *ip1 = 101; ip2 = &amp;m; //*ip2 = 101; ip3 = &amp;m; //*ip3 = 101; //ip4 = &amp;m; //*ip4 = 101; 注意到ip1、ip2、ip3之间的差别。ip1时指针常量，而ip2 和ip3都是常量指针。ip1指针不能被指来指去，而ip2和ip 3恰恰相反。它们本身可以被指来指去，但是它们指向的内 容只读，不能被修改。ip4综合了两种特点，提供一个最安全的指针。 ·常见用法 取代宏，定义一些不可更改的值 volatile不多见，一般情况下，只有底层才会有到，有兴趣可以百度。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell常用命令]]></title>
    <url>%2F2019%2F06%2F02%2Fshell-note1%2F</url>
    <content type="text"><![CDATA[大部分命令都可以通过man的方法获取 常用系统工作命令 echo命令输出字符串或变量提取后的值echo 字符串 || $变量 参数 作用 -n 不换行输出内容 -e 解析转义字符 \n 换行 \t 制表符 \r 回车 date显示及设置系统的时间或日期date 参数 参数 作用 %t 制表位 %Y 年 %m 月 %d 日 %H 0～23小时 %I 0～12小时 %M 分钟 %S 秒 %F 日期全格式 %j 今年的第几天 reboot重启系统，使用管理权限sudo reboot : 管理员权限重启系统 poweroff关闭系统，使用管理员权限sudo poweroff : 管理员权限关闭系统 wget在终端中下载网络文件，格式为wget 参数 下载地址 参数 作用 -b 后台下载模式 -p 下载到制定目录 -t 最大尝试次数 -c 断电续传 -p 下载页面内所有资源，包括图片，视频等 -r 递归下载 ps查看系统中的进程状态，格式为ps 参数 参数 作用 -a 显示所有进程 -u 用户以及其他详细信息 -x 显示没有控制终端的进程 5种常见的进程状态:R 运行S 中断D 不可中断Z 僵死T 停止 top动态地监控进程活动与系统负载等信息–强化版任务管理器统计信息代表含义： 第一行：系统时间，运行时间,登录终端数，系统负载，（1,5,15分钟的数值，越小越好） 第二行：进程总数，运行中的进程数，睡眠中的进程数，停止的进程数，僵死的进程数。 第三行：用户资源占用百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的百分比等。 第四行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量 第五行：虚拟内存总量、虚拟内存总量、虚拟内存空闲量、已被提前加载的内存量 pidof查询某个指定服务进程的PID值pidof 参数 服务名称 kill终止某个指定PID的服务进程kill 参数 进程PID killall终止某个指定名称的服务所对应的全部进程killall 参数 进程名称 系统状态检测命令 ifconfig获取网卡配置与网络状态等信息ifconfig 网络设备 参数 usame查看系统内核与系统版本等信息uname 参数 uptimeuptime查看系统的负载信息 free显示当前系统中内存的使用量信息free 参数 who查看当前登入主机的用户终端信息who 参数 last查看所有系统的登录记录last 参数 history显示历史执行过的命令history 参数 sosreport收集系统配置及架构信息并输出诊断文档 工作目录切换命令 pwd显示用户当前所在工作目录pwd 选项 cd切换工作路径cd 目录名称 参数 作用 cd ~ 回到home目录 cd / 回到根目录下 cd .. 返回上一级目录 ls显示目录中的文件信息ls 选项 文件 参数 作用 -a 查看隐藏文件 -l 长格式显示 -d 详细信息 文本文件编辑命令 cat查看内容较少的纯文本文件cat 选项 文件 参数 作用 -n 显示行号 more查看内容较多的纯文本文件more 选项 文件 head查看纯文本文档的前N行head 选项 文本 tail查看文本的后N行tail 选项 文本 参数 作用 -n 指定查看多少行 tr替换文本的字符tr 原始字符 替换字符 wc统计文本行数、字节数、字数wc 参数 文本 参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 stat查看文件的具体存储信息和时间等信息等stat 文件名称 cut按列提取文本字符cut 参数 文本 diff比较多个文本的差异diff 参数 文件 参数 作用 –brief 判断文件是否相同 -c 描述内容的具体不同 文件目录管理命令 touch创建空白文件或设置文件的时间touch 参数 文件 参数 作用 -a 仅修改atime -m 仅修改mtime -d 同时修改atime和mtime mkdir创建空白的目录mkdir 选项 文件 参数 作用 -p 递归创建文件目录 cp复制文件或目录cp 选项 源文件 目标文件 参数 作用 -p 保留原始文件的属性 -d 若对象为链接文件，则保留该链接文件的属性 -r 递归持续复制 -i 若目标存在则询问是否存在 -a 相当于-pdr的作用 mv剪切文件或者重命名mv 选项 源文件 目标路径/目标文件名 rm删除文件或目录rm 选项 文件 参数 作用 -r 递归删除 -f 强制删除 dd按照指定大小和个数的数据快来复制文件或转换文件dd 参数 参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个块的大小 count 设置要复制块的个数 file查看文件的类型file 文件名 打包压缩与搜索命令 tar对文件进行打包压缩或者解压tar 选项 文件 参数 作用 -c 创建压缩文件 -x 解开压缩文件 -j 用bzip2压缩或解压 -v 显示解压或压缩过程 -f 目标文件名 -p 保留原始的权限与属性 -P 使用绝对路径来压缩 -C 指定解压到的目录 -t 列表查看包内的文件 -z 用gzipv程序进行压缩或解压 -r 追加文件至.tar格式文件结尾 grep在文本中执行关键词搜索，并显示匹配的结果grep 选项 文件 参数 作用 -b 将可执行文件当作文本文件来搜索 -c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择 find按照指定条件来查找文件find 查找路径 寻找条件 操作 参数 作用 -name 匹配名称 -perm 匹配权限 -user 匹配所有者 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间(-n指n天以內，+n指n天以后) -atime -n +n 匹配访问文件的时间 -ctime -n +n 匹配修改文件权限的时间 -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件f1新但比f2旧的文件 –type 文件类型 匹配文件类型 -size 匹配文件的大小 -prune 忽略某个目录 -exec …… {} \; 后面可跟用于进一步处理搜索结果的命令]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类的案例]]></title>
    <url>%2F2019%2F05%2F25%2FC-%E7%B1%BB%E7%9A%84%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[前言:最近学习了C++中的内容，一直没有动手实践，所以就花了一些时间做了一个小案例，总结一下自己从C++语法到类的一些知识。 项目截图下面是一些案例运行的截图，没有认真的去写游戏界面，见谅下╰(￣ω￣ｏ) 做项目需要的思维及流程图这里配上文字和一个简单还有点丑的流程图做介绍ヽ(￣ω￣(￣ω￣〃)ゝ 这里插上一句，大家如果有兴趣用代码写一些东西的话，最好是先做好一个流程图，这样子写代码就会有明确的方向，可以更有效率的完成项目。 下面是写流程图需要思考的一些东西： 1.先用人类的思维思考。eg:比大小这个项目，我们需要有玩家，扑克牌，规则才能进行游戏。2.抽象化理解。eg:玩家需要有姓名，分数的属性，需要的操作就是摸牌，出牌，在我们C++语言里就叫做方法；3.拆分。eg:对于摸牌这个操作，我们可以再仔细一点，摸牌需要一副牌，然后你摸一张牌，那副牌就减少你摸的那一张牌。4.优化细节。eg：游戏界面或者代码的注释或者更简单的写法。 扑克牌之比大小流程图 进入游戏 展示游戏界面 开始游戏 游戏进行中 游戏输赢判定 提示是否继续游戏 继续就循环，否则退出游戏 额，这里的文字描述范围比较大，没有更细的描述，感觉还是应该用电脑画流程图比较好。。。这次就这样吧，下次好好写。其实我感觉更重要的是上面的思维，有兴趣可以深入去了解。 项目的实现以及经验 主要是用了C++的一些其他基本语法知识和简单的类操作，还有一些其他项目积累的一些经验等。 在这里建议大家，如果想要好好的学习，可以培养对编程的兴趣。在这里肯定会有人问怎么培养，那我就说一下我自己的方法吧。培养编程兴趣最好就是将自己喜欢的东西与编程结合在一起。举个栗子吧：你喜欢游戏，那你可以多编写一些小游戏的项目。喜欢购物，那就自己编写你自己的购物车，想怎么买怎么买，虽然是假的，但只要你做的好，迟早有一天会变成真的。在生活中多思考哪些东西可以用你所学的东西编写出来，你写的东西越多，你兴趣慢慢就上来了。 项目的源代码源代码已经开放，点击项目源代码即可。 点进去直接打开源文件直接copy就行了 注意有两个源文件，一个头文件。你要创建两个源文件和一个头文件分别写入。 教大家一个如何简单的读懂代码，先看一遍注释，然后从main函数第一个语句设置断点调试，然后跟着系统的脚步一步一步的走。要是不懂怎么调试请点击这个链接。 如果有能力的同学可以扩展或者写一个更好( o=^•ェ•)o ┏━┓]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习面向对象思想的小结]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%AD%A6%E4%B9%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一些小小小小的感悟吧！ 面向对象以前：在我们学习C语言的内容时，我们首先是在main函数里一步一步书写代码，后面学习了函数，就把代码写进函数里，然后在main函数里面去调用函数。其实我们在学习的过程中一点点的深入中，在朝着对象前进中。 在我们面向过程的时候，我们一般都是对我们要做的操作写进函数里，然后一步步的实现我们的目的，但我发现一个问题就是，在我们代码量逐渐的增加，我们的函数和属性会变得越来越多，这个时候我们代码管理起来可能会非常的麻烦，所有我想，这就是我们后面会采用面向对象的原因之一吧！ 面向对象面向对象思想其实更像我们人类的思想，我们可以把同一个对象的属性和方法做一个集合，我们需要用他的时候就直接从里面调用就行了，这一个集合就称之为类；例如一个学生类：我们可以在类里面定义好他们的属性，比如说身高，体重，年龄等，还可以给他们定义方法，比如，吃饭，睡觉，学习，找女朋友啥的。当我们需要用到他的时候我们只需要调用方法或属性即可。而且我想添加，删除方法、属性都可以快速找到，方便管理。 结语：刚踏入的小萌新，多多指教。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell快捷键大全]]></title>
    <url>%2F2019%2F05%2F09%2Fshell%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[常用快捷键 移动光标快捷键 ctrl+f 向右移动一个字符 ctrl+b 向左移动一个字符 ctrl+a 移动到当前行首home ctrl+e 移动到当前行尾end ctrl+l 清屏，并在屏幕最上面开始一个新行 alt+f 向右移动一个单词 alt+b 向左移动一个单词 编辑命令行快捷键 ctrl+d 删除当前的字符（Del） ctrl+t 交换当前字符和左一个字符的位置 alt+t 交换当前单词d和左一个单词的位置 alt+u 把当前单词变成大写 alt+l 把当前单词变成小写(在manjaro等同于ls命令) alt+c 把当前位置字母变大写的字母并跳到词尾 剪切、粘贴快捷键 alt d：删除从光标到当前单词结尾的部分 ctrl+k 剪切文本直到行的末尾 ctrl+u 剪切文本直到行的起始 ctrl+w 剪切光标前的单词，删除最后输入的单词 ctrl+y 粘贴刚才所删除的字符 ctrl+c 删除整行，终端进程 ctrl+d 退出shell， ctrl+h 删除左边字符]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F05%2F06%2FMY_first_Blog%2F</url>
    <content type="text"><![CDATA[学了点git Git为什么要使用Git 协同修改 数据备份 版本管理 权限管理 历史纪录 分支管理 Git提交代码五步曲 初始化本地库git init 设置签名 123456//系统用户级别git config --global user.name 名称git config --global user.email 邮箱 //项目级别git config user.name 名称git config user.email 邮箱 添加文件到暂存区 12git add 文件名 //提交单个文件git add -A //提交所有文件 提交到本地库git commit -m 描述 上传到远程仓库git push 对读者的话Git是一个很好的代码托管中心，可以把你的代码放到服务器存放，还可以进行版本控制;大家有兴趣可以去自行找视频学习。]]></content>
  </entry>
</search>
